
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>程序员必会十大算法 | Yao Xiong</title>
        <meta name="author" content="Yao Xiong">
        <meta name="description" content="莫听穿林打叶声， 何妨吟啸且徐行">
        <meta name="keywords" content="Yao Xiong Projects">
        <link rel="icon" href="/img/favicon.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 7.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:2147483647;justify-content:space-between;background:#fff;transition:all 0.3s ease-out;-webkit-user-select:none;-moz-user-select:none;user-select:none"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="showpage" style="display: -not-none">
                    <div id="menushow">
                        <nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yao Xiong</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;projects</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yao Xiong</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">projects</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div class="article">
    <div>
        <h1>程序员必会十大算法 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2021/5/16
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/java/" style="color: #03a9f4">
                    java
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="color: #ffa2c4">
                    数据结构与算法
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h2 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1. 二分查找算法"></a>1. 二分查找算法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419111722840.png" alt="image-20210419111722840"></p>
<p>这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N)</p>
<span id="more"></span>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>二分查找有2种实现方法：递归版和非递归版</p>
<p><strong>非递归版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>; <span class="comment">//left表示左侧下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> array.length-<span class="number">1</span>; <span class="comment">//right表示右侧下标</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//结束的条件是左边大于右边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>; <span class="comment">//我们假设中间的数是目标</span></span><br><span class="line">        <span class="keyword">if</span>(array[mid] == num) &#123; <span class="comment">// 判断，是</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; num) &#123; <span class="comment">//判断发现中间的数比目标数大</span></span><br><span class="line">            right = mid -<span class="number">1</span>; <span class="comment">//把中间的数的下标设置为右边， 减1是因为mid已经判断过了，比num大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//若小，则设置为左边</span></span><br><span class="line">            left = mid+<span class="number">1</span>;<span class="comment">//加1的原因和上面类似</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//找完后发现没有找到，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>递归版本</strong></p>
<p>具体步骤和上面非递归版本类似，推荐非递归版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> num, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print(array, left, right);</span><br><span class="line">    <span class="keyword">if</span>(array[index] &gt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(array, num, left, index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(array[index] &lt; num) &#123;</span><br><span class="line">        <span class="keyword">return</span> search(array, num, index+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2. 分治算法"></a>2. 分治算法</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>分治算法，蕴含分而治之的思想，Divide and Conquer. 我们把难的问题逐个逐个拆分，拆分为小的问题，然后对于这个小的问题我们要给出解决办法，最后一步一步返回过去，将难的问题给解决，使用分治算法时，我们还利用了递归的思想，从拆分到组合</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们举汉诺塔的例子来讲分治算法</p>
<p>故事大家也都知道</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
</blockquote>
<p>64个盘看似很多，我们把这64个简化为3个</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419123047227.png" alt="image-20210419123047227"></p>
<p>3个盘，我们先把上面两个盘想办法<strong>从第1个柱子移到第2个柱子</strong></p>
<p>为了按照大小的顺序移动，先把第1个盘从第1个柱子移到第3个柱子，第2个盘从第1个柱子移到第2个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124339062.png" alt="image-20210419124339062"></p>
<p>接着把盘从第3个柱子移到第2个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124415703.png" alt="image-20210419124415703"></p>
<p>然后，把仅存在第1个柱子的盘移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124444560.png" alt="image-20210419124444560"></p>
<p>最后想办法把<strong>第2个柱子上的盘移到第3个柱子</strong></p>
<p>先把第2个柱子上的移到第1个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124656537.png" alt="image-20210419124656537"></p>
<p>再把最后一个移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124729238.png" alt="image-20210419124729238"></p>
<p><strong>最后一步</strong></p>
<p>把盘从第1个柱子移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124828794.png" alt="image-20210419124828794"></p>
<p>假设有n个盘，3个柱A, B, C</p>
<ol>
<li>把n-1个盘从A到B</li>
<li>最后1个从A到C</li>
<li>再把n-1个盘从B移到C</li>
</ol>
<p>落实到代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiTower</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		move(<span class="number">3</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//只有1个盘，从A移动到C</span></span><br><span class="line">			System.out.println(a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//把n-1个盘，从A移动到B</span></span><br><span class="line">			move(num-<span class="number">1</span>, a, c, b);<span class="comment">//由于实参和形参的不同，我们可以改变实参以达到变换的目的</span></span><br><span class="line">			System.out.println(a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">			count++;</span><br><span class="line">			<span class="comment">//再把剩下的从B移动到C</span></span><br><span class="line">			move(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419140825279.png" alt="image-20210419140825279"></p>
<h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>和上面的分治算法有点类似，都是把复杂或大的问题拆解为小的问题，然后求解</p>
<p>不同在于，动态规划算法每一步和上一步之间有联系，所以动态规划算法适用于重叠的子问题求解</p>
<p>常见的利用动态规划算法求解的莫过于背包问题（01背包问题）</p>
<p>去商店买东西，背包有固定的容量，我们每个物品有且只能装入1次，最后我们要挑选出价值最高的物品组合。</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419132120492.png" alt="image-20210419132120492"></p>
<p>为了获取每个子问题的最优解，我们用二维数组来解决背包问题</p>
<p>列表示背包容量</p>
<p>行表示对应的商品</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419132323341.png" alt="image-20210419132323341"></p>
<p>第1列我们也设置为0</p>
<p>用双重for循环，从左往右，从上往下</p>
<p>当然，由于我们第1行和第1列都设置为0，我们从第2列和第2行开始bag[1][1]</p>
<p>从左往右，判断背包容量是否可以装入吉他，不行读取上面1格的值，然后向后，发现2kg可以装入吉他，把吉他装入，设置为$200，</p>
<p>走到电脑这一行，1kg无法放下，读取上面1格的值，向后，还是不行，继续向后，直到能装下，4kg，和上一个做对比，看哪个最后的值大，把大的放入</p>
<p>最后一行是书， 与上文一样，直到bag容量为3kg时，我们先装入1本书，还剩余2kg，我们选取没加这本书的时候的最佳值，也就是书所在上一行，剩余容量所在的位置的值， 就是$200 + $100, 然后我们比较和上一行的大小</p>
<table>
<thead>
<tr>
<th></th>
<th>0 kg</th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
</tr>
<tr>
<td>吉他</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$200</td>
</tr>
<tr>
<td>电脑</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$300</td>
</tr>
<tr>
<td>书</td>
<td>$0</td>
<td>$100</td>
<td>$200</td>
<td>$200+$100</td>
<td>$300</td>
</tr>
</tbody></table>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们除了要知道背包能存入的最大值，还应该知道存入的是哪些物品，所以我们还需要一个二维数组用来表示存了哪些物品</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] path=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>存入path所在的位置为1， 没有就是默认的0</p>
<p>打印</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>吉他</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>电脑</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>书</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>打印从右下角开始向上读，如果此时的标记为1，打印这个下标对应商品的下标，横坐标减去这个商品对应的容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了显示装入的物品有哪些</span></span><br><span class="line">        </span><br><span class="line"><span class="type">int</span> i=path.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j=path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(path[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;把%s放入背包\n&quot;</span>,obj[i-<span class="number">1</span>]);</span><br><span class="line">        j -= w[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>最后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dynamic_Programming_Bag2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] obj = &#123;<span class="string">&quot;Guitar&quot;</span>,<span class="string">&quot;Computer&quot;</span>,<span class="string">&quot;Book&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[] v= &#123;<span class="number">200</span>,<span class="number">300</span>,<span class="number">100</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[] w= &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">4</span>;<span class="comment">//背包的容量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;<span class="comment">//物品的个数</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//背包</span></span><br><span class="line">		<span class="type">int</span>[][] bag =<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存储数组</span></span><br><span class="line">		<span class="type">int</span>[][] path=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bag.length;i++)</span><br><span class="line">			bag[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//第一列设置为0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bag[<span class="number">0</span>].length;i++)</span><br><span class="line">			bag[<span class="number">0</span>][i]=<span class="number">0</span>;<span class="comment">//第一行设置为0</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;bag.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;bag[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt;j) &#123;</span><br><span class="line">					<span class="comment">//容量不满足，直接继承上面一个</span></span><br><span class="line">					bag[i][j] = bag[i-<span class="number">1</span>][j];</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//容量满足，和上面一个对比，选取最佳的value</span></span><br><span class="line">					<span class="comment">//装入i-1个商品，到剩余空间j-w[i]的最大值</span></span><br><span class="line"><span class="comment">//					bag[i][j] = Math.max(bag[i-1][j], v[i-1]+bag[i-1][j-w[i-1]]);</span></span><br><span class="line">					<span class="keyword">if</span>(bag[i-<span class="number">1</span>][j]&lt;v[i-<span class="number">1</span>]+bag[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]]) &#123;</span><br><span class="line">						bag[i][j] = v[i-<span class="number">1</span>]+bag[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]];</span><br><span class="line">						<span class="comment">//把当前情况记录到path</span></span><br><span class="line">						path[i][j]=<span class="number">1</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						bag[i][j] = bag[i-<span class="number">1</span>][j];</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">      </span><br><span class="line"><span class="comment">//打印背包的Table</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//i表示行</span></span><br><span class="line">		<span class="comment">//j表示列</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bag.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bag[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">				System.out.printf(bag[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">//为了显示装入的物品有哪些</span></span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> i=path.length-<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> j=path[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(path[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;把%s放入背包\n&quot;</span>,obj[i-<span class="number">1</span>]);</span><br><span class="line">				j -= w[i-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419140711349.png" alt="image-20210419140711349"></p>
<h2 id="4-贪婪算法"><a href="#4-贪婪算法" class="headerlink" title="4. 贪婪算法"></a>4. 贪婪算法</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>贪婪算法，又称贪心算法，Greedy Algorithm。 在解决问题时，每次都选择最好的情况，用这种方法得出最后的解，注意：虽然贪婪算法每次都选最好的，但是最后的结果并不一定是最佳的</p>
<p>广播集合覆盖问题（贪心算法的应用）</p>
<p>我们要构建广播站，每个广播站覆盖的地区不一样，有些有交叉的地方，我们要用哪些广播站去覆盖全部地区。 </p>
<p>如图</p>
<table>
<thead>
<tr>
<th>地区： <strong>北京、上海、天津、广州、深圳、成都、杭州、大连</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>电台</td>
<td>覆盖数</td>
<td>地区</td>
</tr>
<tr>
<td>K1</td>
<td>3</td>
<td>北京、上海、天津</td>
</tr>
<tr>
<td>K2</td>
<td>3</td>
<td>广州、北京、深圳</td>
</tr>
<tr>
<td>K3</td>
<td>3</td>
<td>成都、上海、杭州</td>
</tr>
<tr>
<td>K4</td>
<td>2</td>
<td>上海、天津</td>
</tr>
<tr>
<td>K5</td>
<td>2</td>
<td>杭州、大连</td>
</tr>
</tbody></table>
<p>从电台里面选，哪些电台组合在一起就覆盖了全部地区？</p>
<p>首先，我们将每个电台与其覆盖的地区放入HashMap中， Key是电台名称， Value是储存此电台覆盖地区的HashSet。然后我们还要创建一个HashSet用来储存所有地区名称， 一个ArrayList储存最后的结果</p>
<p>我们构建一个循环，每次从循环找出地区数覆盖最多的电台，将这个电台加入到ArrayList中，然后从所有地区中清除这些地区，接着循环，当地区集合大小为0时停止。</p>
<p>这个看代码比较好理解</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreedyAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		HashMap&lt;String, HashSet&lt;String&gt;&gt; radios = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		HashSet&lt;String&gt; k1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		k1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">		k1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">		k1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; k2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		k2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">		k2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">		k2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; k3 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		k3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">		k3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">		k3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; k4 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		k4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">		k4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; k5 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		k5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">		k5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		radios.put(<span class="string">&quot;k1&quot;</span>, k1);</span><br><span class="line">		radios.put(<span class="string">&quot;k2&quot;</span>, k2);</span><br><span class="line">		radios.put(<span class="string">&quot;k3&quot;</span>, k3);</span><br><span class="line">		radios.put(<span class="string">&quot;k4&quot;</span>, k4);</span><br><span class="line">		radios.put(<span class="string">&quot;k5&quot;</span>, k5);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		allAreas.addAll(k1);</span><br><span class="line">		allAreas.addAll(k2);</span><br><span class="line">		allAreas.addAll(k3);</span><br><span class="line">		allAreas.addAll(k4);</span><br><span class="line">		allAreas.addAll(k5);</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">MaxKey</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">while</span>(!allAreas.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">for</span>(String key:radios.keySet()) &#123;</span><br><span class="line">				HashSet&lt;String&gt; temp = radios.get(key);</span><br><span class="line">				temp.retainAll(allAreas); <span class="comment">//选取交集</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//必须交集大于0 或者 交集的大小大于最大的大小</span></span><br><span class="line">				<span class="keyword">if</span>( temp.size() &gt;<span class="number">0</span> &amp;&amp; (MaxKey == <span class="literal">null</span> || temp.size() &gt; radios.get(MaxKey).size())) &#123;</span><br><span class="line">					MaxKey = key; <span class="comment">//才能赋值</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//当最大赋值不为NULL时，把答案添加进去，移除对应的地区</span></span><br><span class="line">			<span class="keyword">if</span>(MaxKey != <span class="literal">null</span>) &#123;</span><br><span class="line">				result.add(MaxKey);</span><br><span class="line">				allAreas.removeAll(radios.get(MaxKey));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419143839349.png" alt="image-20210419143839349"></p>
<h2 id="5-KMP算法"><a href="#5-KMP算法" class="headerlink" title="5. KMP算法"></a>5. KMP算法</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>KMP算法是常见的匹配字符串的算法，起初由名字里含有K, M, P的3个人所创建。讨论KMP算法之前我们要先了解暴力匹配字符串算法</p>
<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><p>为什么叫暴力匹配算法？这个方法虽然也是算法，也能帮我们解决问题，但是它的运行效率是比较低的。</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150304534.png" alt="image-20210419150304534"></p>
<p>找出‘FFD’所匹配的字符串的下标</p>
<p>第一行字符串假设为s1</p>
<p>第二行是s2</p>
<p>在While循环中，用s2的下标向s1的下标进行匹配，若所指下标不匹配，s2向后挪动1格</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150609480.png" alt="image-20210419150609480"></p>
<p>如此一直到s1上的FFD与s2上的FFD相互匹配，此时返回下标，当然这个下标应该要减去s2的长度</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150742638.png" alt="image-20210419150742638"></p>
<h4 id="暴力匹配代码实现"><a href="#暴力匹配代码实现" class="headerlink" title="暴力匹配代码实现"></a>暴力匹配代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViolentMatching</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//暴力匹配算法 </span></span><br><span class="line">		System.out.println(matching(<span class="string">&quot;ABCDBCEFFDHFCD&quot;</span>,<span class="string">&quot;FFD&quot;</span>));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">matching</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="type">char</span>[] s1 =str1.toCharArray();</span><br><span class="line">		<span class="type">char</span>[] s2 =str2.toCharArray();</span><br><span class="line">		<span class="keyword">while</span>(i&lt;s1.length &amp;&amp; j&lt;s2.length) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i] == s2[j]) &#123; <span class="comment">//相匹配，两下标各向后移动1</span></span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">//发现不匹配，s2的下标从头开始， s1的下标应该减去刚才匹配的长度然后+1</span></span><br><span class="line">                </span><br><span class="line">				i= i-j+<span class="number">1</span>;</span><br><span class="line">				j=<span class="number">0</span>;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后找到返回下标</span></span><br><span class="line">		<span class="keyword">if</span>(j==s2.length)</span><br><span class="line">			<span class="keyword">return</span> i-j;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在暴力匹配当中，s2每次只往后移动1格，有些之前匹配过的还要再匹配，一旦字符串较长时，匹配所需要的时间就会增加很多，所以我们需要用KMP算法来进行优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="string">&quot;ABCDABD&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>KMP在实现匹配之前要根据s2的前后缀最大公共元素的长度来建立一个匹配池</p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>D</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>字串</strong></th>
<th><strong>前缀</strong></th>
<th><strong>后缀</strong></th>
<th><strong>最大公共长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>空</td>
<td>空</td>
<td>0</td>
</tr>
<tr>
<td>AB</td>
<td>A</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>ABC</td>
<td>A, AB</td>
<td>BC, C</td>
<td>0</td>
</tr>
<tr>
<td>ABCD</td>
<td>A,AB,ABC</td>
<td>BCD, CD, D</td>
<td>0</td>
</tr>
<tr>
<td>ABCDA</td>
<td>A,AB,ABC,ABCD</td>
<td>BCDA, CDA, DA, A</td>
<td>1</td>
</tr>
<tr>
<td>ABCDAB</td>
<td>A, AB, ABC, ABCD, ABCDA</td>
<td>BCDAB, CDAB, DAB, AB, B</td>
<td>2</td>
</tr>
<tr>
<td>ABCDABD</td>
<td>A, AB, ABC, ABCD, ABCDA, ABCDAB</td>
<td>BCDABD, CDABD, DABD, ABD, BD, D</td>
<td>0</td>
</tr>
</tbody></table>
<p>有了匹配表后，我们要对之前暴力匹配的算法进行更新</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若字符匹配不相等</span></span><br><span class="line"><span class="comment">//KMP算法核心</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;<span class="number">0</span> &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;</span><br><span class="line">    j = map[j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</span></span><br></pre></td></tr></table></figure>





<h3 id="KMP代码实现"><a href="#KMP代码实现" class="headerlink" title="KMP代码实现"></a>KMP代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMPAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span><span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">		System.out.println(KMP(str1, str2, MatchMap(str2)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构建字符匹配表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dest 传入字符串 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回匹配后的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] MatchMap(String dest) &#123;</span><br><span class="line">		<span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[dest.length()];</span><br><span class="line">		map[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;dest.length();i++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//KMP算法核心</span></span><br><span class="line">			<span class="keyword">while</span>(j &gt;<span class="number">0</span> &amp;&amp; dest.charAt(i)!=dest.charAt(j)) &#123;</span><br><span class="line">				j = map[j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//部分匹配值+1</span></span><br><span class="line">			<span class="keyword">if</span>(dest.charAt(i)==dest.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			map[i] =j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> st1 被匹配的长字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> st2 拿来匹配的字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map 字符匹配表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回-1 或对应匹配的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">KMP</span><span class="params">(String st1, String st2, <span class="type">int</span>[] map)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;i&lt;st1.length();i++) &#123;</span><br><span class="line">			<span class="comment">//若字符匹配不相等</span></span><br><span class="line">			<span class="comment">//KMP算法核心</span></span><br><span class="line">			<span class="keyword">while</span>(j &gt;<span class="number">0</span> &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;</span><br><span class="line">				j = map[j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//字符匹配相等</span></span><br><span class="line">			<span class="keyword">if</span>(st1.charAt(i)==st2.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(j &gt;= st2.length())</span><br><span class="line">				<span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-Prim算法"><a href="#6-Prim算法" class="headerlink" title="6. Prim算法"></a>6. Prim算法</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>Prim算法用于解决修路最短路径问题，有7个村庄，要用路把它们连接，问怎么修路使总路程最短，且路可以到达每个村庄</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419184711756.png" alt="image-20210419184711756"></p>
<p>最小生成树问题</p>
<ol>
<li><p>这个问题要利用图的知识来求解</p>
</li>
<li><p>需要构建二维数组（邻接矩阵）来表示顶点间的关系</p>
</li>
<li><p>既然每个顶点只能访问一次，需要一个boolean 数组，来储存该顶点是否被访问过</p>
</li>
<li><p>最终边（路）的条数应该为顶点数-1</p>
</li>
<li><p>为了知道是哪2个顶点之间相互连接，我们要将顶点的数据（顶点是哪2个，边的权值是多少）存起来</p>
</li>
<li><p>图</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用静态内部类的形式来构建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> vertex;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] data;</span><br><span class="line">    <span class="type">int</span>[][] weight;</span><br><span class="line">    Graph(<span class="type">char</span>[] d, <span class="type">int</span>[][] w)&#123;</span><br><span class="line">        vertex = d.length;</span><br><span class="line">        data = d;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>二维数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][] weight= &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>boolean数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.vertex]; <span class="comment">//表示是否访问过</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>Prim算法的核心</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写Prim算法，得到最小生成树</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> v 从图的第几个顶点开始找</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.vertex]; <span class="comment">//表示是否访问过</span></span><br><span class="line">    isVisited[v] = <span class="literal">true</span>; <span class="comment">//默认设置从第v个顶点开始</span></span><br><span class="line">    <span class="comment">/**用 h1和h2 记录2个顶点的下标*/</span></span><br><span class="line">    <span class="type">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> max=getMax(); <span class="comment">// getMax是一个函数，用于获取此矩阵中的最大值，方便后面做比较</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//用于统计总路径长度</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  <span class="comment">//储存最后的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;graph.vertex;k++) &#123; <span class="comment">//根据算法，最后边个数应该为vertex-1个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minWeight</span> <span class="operator">=</span> max;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双重循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.vertex;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph.vertex;j++) &#123;</span><br><span class="line">                <span class="comment">//确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有</span></span><br><span class="line">                <span class="keyword">if</span>(isVisited[i]==<span class="literal">true</span> </span><br><span class="line">                   &amp;&amp; isVisited[j]==<span class="literal">false</span> </span><br><span class="line">                   &amp;&amp; graph.weight[i][j] &lt; minWeight <span class="comment">//比目前最大的数要小</span></span><br><span class="line">                   &amp;&amp; graph.weight[i][j] != <span class="number">0</span>) &#123; <span class="comment">//且不为0</span></span><br><span class="line">                    minWeight = graph.weight[i][j]; <span class="comment">//将最小的换为此时的权重</span></span><br><span class="line">                    h1=i; </span><br><span class="line">                    h2=j; <span class="comment">//标记这2个点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isVisited[h2] = <span class="literal">true</span>; <span class="comment">//第二个点设为已访问，之后会从这一行开始访问</span></span><br><span class="line">        result.put(graph.data[h1]+<span class="string">&quot;-&quot;</span>+graph.data[h2], graph.weight[h1][h2]);</span><br><span class="line">        count += graph.weight[h1][h2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;String, Integer&gt; rst:result.entrySet())</span><br><span class="line">        System.out.println(rst.getKey()+<span class="string">&quot; : &quot;</span>+rst.getValue());</span><br><span class="line">    System.out.println(<span class="string">&quot;Min Path: &quot;</span>+count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlgorithm</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">char</span>[] data = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">		<span class="comment">//邻接矩阵的关系用二维数组来表示</span></span><br><span class="line">		<span class="type">int</span> [][] weight= &#123;</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">				&#123;<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">				&#123;<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">				&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">MinTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinTree</span>();</span><br><span class="line">		tree.createGraph(<span class="keyword">new</span> <span class="title class_">Graph</span>(data, weight));</span><br><span class="line">		tree.showGraph();</span><br><span class="line">		</span><br><span class="line">		tree.Prim(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MinTree</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Graph graph;</span><br><span class="line">		<span class="comment">//创建图的邻接矩阵</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createGraph</span><span class="params">(Graph g)</span> &#123;</span><br><span class="line">			graph = g;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//打印图</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>[] w:graph.weight)</span><br><span class="line">				System.out.println(Arrays.toString(w));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//编写Prim算法，得到最小生成树</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> v 从图的第几个顶点开始找</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">			<span class="type">boolean</span>[] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[graph.vertex]; <span class="comment">//表示是否访问过</span></span><br><span class="line">			isVisited[v] = <span class="literal">true</span>; <span class="comment">//默认设置从第v个顶点开始</span></span><br><span class="line">			<span class="comment">/**用 h1和h2 记录2个顶点的下标*/</span></span><br><span class="line">			<span class="type">int</span> h1=-<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> h2=-<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> max=getMax();</span><br><span class="line">			<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">			HashMap&lt;String, Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">	</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;graph.vertex;k++) &#123; <span class="comment">//根据算法，最后边个数应该为vertex-1个</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">minWeight</span> <span class="operator">=</span> max;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//双重循环</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.vertex;i++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph.vertex;j++) &#123;</span><br><span class="line">						<span class="comment">//确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有</span></span><br><span class="line">						<span class="keyword">if</span>(isVisited[i]==<span class="literal">true</span> &amp;&amp; isVisited[j]==<span class="literal">false</span> &amp;&amp; graph.weight[i][j] &lt; minWeight &amp;&amp; graph.weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">							minWeight = graph.weight[i][j];</span><br><span class="line">							h1=i;</span><br><span class="line">							h2=j;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				isVisited[h2] = <span class="literal">true</span>; <span class="comment">//设置成访问，之后会从这一行开始访问</span></span><br><span class="line">				result.put(graph.data[h1]+<span class="string">&quot;-&quot;</span>+graph.data[h2], graph.weight[h1][h2]);</span><br><span class="line">				count += graph.weight[h1][h2];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println();</span><br><span class="line">			<span class="keyword">for</span>(Entry&lt;String, Integer&gt; rst:result.entrySet())</span><br><span class="line">				System.out.println(rst.getKey()+<span class="string">&quot; : &quot;</span>+rst.getValue());</span><br><span class="line">			System.out.println(<span class="string">&quot;Min Path: &quot;</span>+count);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">int</span> max=graph.weight[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;graph.vertex;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;graph.vertex;j++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(graph.weight[i][j]&gt;max)</span><br><span class="line">						max = graph.weight[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> max;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> vertex;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">char</span>[] data;</span><br><span class="line">		<span class="type">int</span>[][] weight;</span><br><span class="line">		Graph(<span class="type">char</span>[] d, <span class="type">int</span>[][] w)&#123;</span><br><span class="line">			vertex = d.length;</span><br><span class="line">			data = d;</span><br><span class="line">			weight = w;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419194332111.png" alt="image-20210419194332111"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的代码是自学写的，时间复杂度很高，（n^3）， 一般的Prim算法时间复杂度仅（n^2），下面贴出更改后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimAlgorithm2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> INF=Integer.MAX_VALUE;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">char</span>[] data = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不相邻的顶点，用INF表示</span></span><br><span class="line">		<span class="type">int</span> [][] map= &#123;</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,INF,INF,INF,<span class="number">2</span>&#125;,</span><br><span class="line">				&#123;<span class="number">5</span>,<span class="number">0</span>,INF,<span class="number">9</span>,INF,INF,<span class="number">3</span>&#125;,</span><br><span class="line">				&#123;<span class="number">7</span>,INF,<span class="number">0</span>,INF,<span class="number">8</span>,INF,INF&#125;,</span><br><span class="line">				&#123;INF,<span class="number">9</span>,INF,<span class="number">0</span>,INF,<span class="number">4</span>,INF&#125;,</span><br><span class="line">				&#123;INF,INF,<span class="number">8</span>,INF,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">				&#123;INF,INF,INF,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">				&#123;<span class="number">2</span>,<span class="number">3</span>,INF,INF,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(<span class="string">&quot;Start&quot;</span>);</span><br><span class="line">		Prim(<span class="number">1</span>, map, data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入起始顶点，邻接矩阵，顶点信息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[][] map, <span class="type">char</span>[] data)</span> &#123;</span><br><span class="line">        <span class="comment">//用于存储最终的各种信息</span></span><br><span class="line">		HashMap&lt;String, Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储整个data长度</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> data.length;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存放前顶点</span></span><br><span class="line">		<span class="type">int</span>[] pre =<span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="comment">//权重 </span></span><br><span class="line">		<span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[num]; </span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weights.length;i++) &#123;</span><br><span class="line">			weights[i] = map[start][i]; <span class="comment">//默认权重以start为基准</span></span><br><span class="line">            <span class="comment">//与start顶点相连</span></span><br><span class="line">			<span class="keyword">if</span>(weights[i] !=INF)</span><br><span class="line">				pre[i] =start; <span class="comment">//把前节点设为start</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//start自身权重为0 </span></span><br><span class="line">		weights[start] =<span class="number">0</span>; </span><br><span class="line">        <span class="comment">//start前结点为-1，即不存在</span></span><br><span class="line">		pre[start] =-<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//主体程序</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; num;i++) &#123;</span><br><span class="line">            <span class="comment">//start顶点前面已经初始化过了</span></span><br><span class="line">			<span class="keyword">if</span>(i == start)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">//设置2 个下标，用来记录最短边的顶点</span></span><br><span class="line">			<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//最小长度</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INF;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从左往右对weights遍历， 找出最小边</span></span><br><span class="line">			<span class="keyword">while</span>(j &lt; num) &#123;</span><br><span class="line">				<span class="comment">//权重最小且不为0</span></span><br><span class="line">				<span class="keyword">if</span>(weights[j]!=<span class="number">0</span> &amp;&amp;weights[j] &lt; min) &#123;</span><br><span class="line">					min = weights[j];</span><br><span class="line">					k = j; <span class="comment">//赋值</span></span><br><span class="line">				&#125;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//把最小边相连的一个顶点设为0</span></span><br><span class="line">			weights[k] =<span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//重置权重（比较重要）</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;num;n++) &#123;</span><br><span class="line">                <span class="comment">//权重不为0， 且新的两顶点之间权重小于目前的</span></span><br><span class="line">				<span class="keyword">if</span>(weights[n]!=<span class="number">0</span> &amp;&amp; map[k][n] &lt; weights[n]) &#123;</span><br><span class="line">                    <span class="comment">//更新权重和前节点</span></span><br><span class="line">					pre[n] = k; </span><br><span class="line">					weights[n] = map[k][n];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//最小生成树信息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(pre[i] !=-<span class="number">1</span>) &#123;</span><br><span class="line">				paths.put(data[pre[i]]+<span class="string">&quot;-&quot;</span>+data[i], map[pre[i]][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//打印信息</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(Entry&lt;String, Integer&gt; p:paths.entrySet()) &#123;</span><br><span class="line">			count += p.getValue();</span><br><span class="line">			System.out.println(p.getKey()+<span class="string">&quot; : &quot;</span>+p.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//打印最终长度</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Least : &quot;</span>+count);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210528231519025.png" alt="image-20210528231519025"></p>
<h2 id="7-Kruskal算法"><a href="#7-Kruskal算法" class="headerlink" title="7. Kruskal算法"></a>7. Kruskal算法</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>克鲁斯卡尔算法和上面的Prim算法功能都一样，是找出最短总路径；但是Kruskal算法用另外一种方式来解决这个问题</p>
<ul>
<li><ol>
<li>创建每条边的List</li>
</ol>
</li>
<li><ol start="2">
<li>把边添加进List</li>
</ol>
</li>
<li><ol start="3">
<li>对List排序</li>
</ol>
</li>
<li><ol start="4">
<li>从头到尾读取List， 判断边的两个顶点是否形成回路</li>
</ol>
</li>
</ul>
<p>为了将顶点间的边进行排序，我们需要创建一个Edge类且实现comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Edge也是一个静态内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&lt;String&gt;&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    Edge(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">        weight = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(E[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data[x]+<span class="string">&quot; &quot;</span>+data[y]+<span class="string">&quot; : &quot;</span>+weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge&lt;String&gt; e)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> weight -e.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>把所有可能加入list并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[data.length][data.length];</span><br><span class="line">LinkedList&lt;Edge&lt;String&gt;&gt; list =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weight.length;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;weight.length;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isVisited[i][j] == <span class="literal">false</span> &amp;&amp; weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Edge</span>&lt;String&gt;(i, j, weight[i][j]));</span><br><span class="line">            isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            isVisited[j][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure>



<p>克鲁斯卡尔算法的精髓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[data.length];</span><br><span class="line"><span class="keyword">for</span>(Edge&lt;String&gt; e:list) &#123;</span><br><span class="line">    <span class="keyword">if</span>(result.size() == data.length-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//克鲁斯卡尔算法精髓</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> GetEnd(ends, e.x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> GetEnd(ends, e.y);</span><br><span class="line">    <span class="comment">//判断终点是否是一样的，即是否形成回路</span></span><br><span class="line">    <span class="keyword">if</span>(m !=n) &#123;</span><br><span class="line">        ends[m]=n;</span><br><span class="line">        result.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取对应下标的终点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ends</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">GetEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(ends[i] !=<span class="number">0</span>)</span><br><span class="line">        i = ends[i];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>





<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kruskar算法</span></span><br><span class="line"><span class="comment"> * 1. 创建每条边的List</span></span><br><span class="line"><span class="comment"> * 2. 把边添加进List</span></span><br><span class="line"><span class="comment"> * 3. 对List排序</span></span><br><span class="line"><span class="comment"> * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 23881</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;;</span></span><br><span class="line"><span class="comment">//		int[][] weight= &#123;</span></span><br><span class="line"><span class="comment">//				&#123;0,3,3,7&#125;,</span></span><br><span class="line"><span class="comment">//				&#123;3,0,2,4&#125;,</span></span><br><span class="line"><span class="comment">//				&#123;3,2,0,6&#125;,</span></span><br><span class="line"><span class="comment">//				&#123;7,4,6,0&#125;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line">		</span><br><span class="line">		String[] data = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[][] weight= &#123;</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">14</span>&#125;,</span><br><span class="line">				&#123;<span class="number">12</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,</span><br><span class="line">				&#123;<span class="number">16</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>&#125;,</span><br><span class="line">				&#123;<span class="number">14</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		Kruskar(data, weight);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Kruskar</span><span class="params">(String[] data, <span class="type">int</span>[][] weight)</span> &#123;</span><br><span class="line">		<span class="type">boolean</span>[][] isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[data.length][data.length];</span><br><span class="line">		LinkedList&lt;Edge&lt;String&gt;&gt; list =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		LinkedList&lt;Edge&lt;String&gt;&gt; result =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;weight.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;weight.length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(isVisited[i][j] == <span class="literal">false</span>&amp;&amp; isVisited[j][i] == <span class="literal">false</span> &amp;&amp; weight[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					list.add(<span class="keyword">new</span> <span class="title class_">Edge</span>&lt;String&gt;(i, j, weight[i][j]));</span><br><span class="line">					isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line">					isVisited[j][i] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Collections.sort(list);</span><br><span class="line">		<span class="keyword">for</span>(Edge&lt;String&gt; e:list) </span><br><span class="line">			System.out.println(e.print(data));</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[data.length];</span><br><span class="line">		<span class="keyword">for</span>(Edge&lt;String&gt; e:list) &#123;</span><br><span class="line">			<span class="keyword">if</span>(result.size() == data.length-<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//克鲁斯卡尔算法精髓, Disjoint Set</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> GetEnd(ends, e.x);</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> GetEnd(ends, e.y);</span><br><span class="line">			<span class="comment">//判断终点是否是一样的，即是否形成回路</span></span><br><span class="line">			<span class="keyword">if</span>(m !=n) &#123;</span><br><span class="line">				ends[m]=n;</span><br><span class="line">				result.add(e);</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(Edge&lt;String&gt; e:result) </span><br><span class="line">			System.out.println(e.print(data));</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取对应下标的终点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> ends</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">GetEnd</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(ends[i] !=<span class="number">0</span>)</span><br><span class="line">			i = ends[i];</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&lt;String&gt;&gt;&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> x;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> y;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">		Edge(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> w)&#123;</span><br><span class="line">			x = a;</span><br><span class="line">			y = b;</span><br><span class="line">			weight = w;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(E[] data)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> data[x]+<span class="string">&quot; &quot;</span>+data[y]+<span class="string">&quot; : &quot;</span>+weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge&lt;String&gt; e)</span> &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			<span class="keyword">return</span> weight -e.weight;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-Dijkstra算法"><a href="#8-Dijkstra算法" class="headerlink" title="8. Dijkstra算法"></a>8. Dijkstra算法</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>Dijkstra算法是解决某个顶点到其他顶点的最小路径问题，（邮差问题）</p>
<p>有A, B,C,D,E,F,G七个村庄，此时派出6个邮差从某点出发给另外几个村庄送信，怎样才能让每个邮差最快到达指定的村庄？</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193626257.png" alt="image-20210509193626257"></p>
<p>村庄连接问题，需要用图与广度优先的知识进行求解</p>
<p>构建一个Graph类，这个类用于存储，每个顶点的前访问顶点， PreNode[ ]， 这个和Disjoint Set很相似，同时我们还在这个Graph类里面存储每个顶点的访问情况与到指定顶点的最短距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span>[] isVisited; <span class="comment">//存储是否被访问</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] PreNode; <span class="comment">//前结点集合</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] Dis; <span class="comment">//存储到每个顶点的最短距离</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">infinity</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">//常量</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">            <span class="comment">//初始化变量</span></span><br><span class="line">			isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">			PreNode = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">			Dis = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//假设每个顶点的前一个顶点都是他们自己</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">				PreNode[i] = -<span class="number">1</span>;</span><br><span class="line">				Dis[i] = infinity; <span class="comment">//假设开始到每个顶点的最短距离为无穷</span></span><br><span class="line">		</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//展示最短距离</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowDis</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(Arrays.toString(Dis));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//展示前顶点</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowPreNode</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(Arrays.toString(PreNode));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//展示访问的情况</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowVisited</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(Arrays.toString(isVisited));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">//获取某个顶点到目标的最短距离</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetDis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Dis[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//设置某顶点到目标的最短距离</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetDis</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">			Dis[n] =m;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//获取前访问顶点</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetPreNode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PreNode[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//设置前访问顶点</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPreNode</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">			PreNode[n] =m;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//获取顶点的访问状态</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">GetVisited</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> isVisited[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//设置顶点的访问状态</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetVisited</span><span class="params">(<span class="type">int</span> n, <span class="type">boolean</span> rst)</span> &#123;</span><br><span class="line">			isVisited[n] = rst;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<p><strong>Dijkstra 算法精髓</strong></p>
<p>首先我们要从一个顶点开始，获得与这个顶点连接的顶点</p>
<p>（考虑到之后可能会使用广度优先，我们这里用LinkedList来存储顶点数据）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(matrix[<span class="number">0</span>].length); <span class="comment">//初始化一个Graph类</span></span><br><span class="line">graph.SetDis(index, <span class="number">0</span>); <span class="comment">//index是目标顶点，所以该顶点到自身的距离为0</span></span><br><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//存储顶点的队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把第一个顶点压入队列</span></span><br><span class="line">list.push(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂时变量</span></span><br><span class="line"><span class="type">int</span> dis=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束的条件就是队列为空</span></span><br><span class="line"><span class="keyword">while</span>(!list.isEmpty()) &#123;</span><br><span class="line">    temp = list.pop(); <span class="comment">//从队列中pop一个元素</span></span><br><span class="line">    <span class="comment">//寻找与此元素相连的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix[temp].length;i++) &#123;</span><br><span class="line">        <span class="comment">//判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点</span></span><br><span class="line">        <span class="keyword">if</span>(matrix[temp][i]!=<span class="number">0</span> &amp;&amp; graph.GetPreNode(i)!=temp) &#123;</span><br><span class="line">            <span class="comment">//获取此时的路径长度</span></span><br><span class="line">            dis = matrix[temp][i]+graph.GetDis(temp);</span><br><span class="line">            <span class="comment">//如果这个长度小于已有的长度</span></span><br><span class="line">            <span class="keyword">if</span>(dis&lt;graph.GetDis(i)) &#123;</span><br><span class="line">                <span class="comment">//对原顶点的长度进行替换</span></span><br><span class="line">                graph.SetPreNode(i, temp);</span><br><span class="line">                <span class="comment">//修改preNode</span></span><br><span class="line">                graph.SetDis(i, dis);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//能够被压入队列的条件：没被访问过且不在队列中</span></span><br><span class="line">                <span class="keyword">if</span>(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123;</span><br><span class="line">                    list.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个顶点完成遍历后，将其设置为已访问</span></span><br><span class="line">    graph.SetVisited(temp, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraAlgorithm2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String[] data = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">				&#123;<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">				&#123;<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">				&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		Dijkstra(matrix, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*结束条件：队列为空</span></span><br><span class="line"><span class="comment">	 * 判断条件：not preNode</span></span><br><span class="line"><span class="comment">	 * 	改变Dis与Pre条件</span></span><br><span class="line"><span class="comment">	 * 		小于已有距离</span></span><br><span class="line"><span class="comment">	 * 	压入条件</span></span><br><span class="line"><span class="comment">	 * 		not visited 且 不在队列中</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 遍历完一个点后，将此点改为isvisited</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(matrix[<span class="number">0</span>].length);</span><br><span class="line">		graph.SetDis(index, <span class="number">0</span>);</span><br><span class="line">		LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		list.push(index);</span><br><span class="line">		graph.SetVisited(index, <span class="literal">true</span>);</span><br><span class="line">		<span class="type">int</span> dis=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!list.isEmpty()) &#123;</span><br><span class="line">			temp = list.pop();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix[temp].length;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(matrix[temp][i]!=<span class="number">0</span> &amp;&amp; graph.GetPreNode(i)!=temp) &#123;</span><br><span class="line">					dis = matrix[temp][i]+graph.GetDis(temp);</span><br><span class="line">					<span class="keyword">if</span>(dis&lt;graph.GetDis(i)) &#123;</span><br><span class="line">						graph.SetPreNode(i, temp);</span><br><span class="line">						graph.SetDis(i, dis);</span><br><span class="line">						<span class="keyword">if</span>(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123;</span><br><span class="line">							list.push(i);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            graph.SetVisited(temp, <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;Final Distence&quot;</span>);</span><br><span class="line">		graph.ShowDis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;\nFinal Pre-Node&quot;</span>);</span><br><span class="line">		graph.ShowPreNode();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;\nAdjacent Matrix&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] i:matrix) &#123;</span><br><span class="line">			System.out.println(Arrays.toString(i));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] PreNode;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] Dis;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">infinity</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">	</span><br><span class="line">			isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">			PreNode = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">			Dis = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">				PreNode[i] = -<span class="number">1</span>;</span><br><span class="line">				Dis[i] = infinity;</span><br><span class="line">		</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowDis</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(Arrays.toString(Dis));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ShowPreNode</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(Arrays.toString(PreNode));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetDis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Dis[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetDis</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">			Dis[n] =m;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetPreNode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PreNode[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetPreNode</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">			PreNode[n] =m;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">GetVisited</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> isVisited[n];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetVisited</span><span class="params">(<span class="type">int</span> n, <span class="type">boolean</span> rst)</span> &#123;</span><br><span class="line">			isVisited[n] = rst;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193843994.png" alt="image-20210509193843994"></p>
<h2 id="9-Floyd算法"><a href="#9-Floyd算法" class="headerlink" title="9. Floyd算法"></a>9. Floyd算法</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>Floyd算法解决的问题和上面Dijkstra算法解决的问题一样；Floyd算法更容易理解，但是它的运行效率没有Dijkstra算法高</p>
<p>Floyd算法使用3个for循环进行嵌套</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193707615.png" alt="image-20210509193707615"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloydAlgorithm</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> N=<span class="number">255</span>; <span class="comment">//N表示两个顶点间不相连</span></span><br><span class="line">		String[] data = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;G&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">				&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;,</span><br><span class="line">				&#123;<span class="number">5</span>,<span class="number">0</span>,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;,</span><br><span class="line">				&#123;<span class="number">7</span>,N,<span class="number">0</span>,N,<span class="number">8</span>,N,N&#125;,</span><br><span class="line">				&#123;N,<span class="number">9</span>,N,<span class="number">0</span>,N,<span class="number">4</span>,N&#125;,</span><br><span class="line">				&#123;N,N,<span class="number">8</span>,N,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">				&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">				&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Floyd(data, matrix);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">Floyd</span><span class="params">(E[] d, <span class="type">int</span>[][] m )</span> &#123;</span><br><span class="line">		Graph&lt;E&gt; graph = <span class="keyword">new</span> <span class="title class_">Graph</span>&lt;&gt;(d, m);</span><br><span class="line"><span class="comment">//		graph.showGraph();</span></span><br><span class="line">		graph.start();</span><br><span class="line">		graph.showGraph();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&lt;E&gt;&#123;</span><br><span class="line">		<span class="keyword">private</span> E[] data;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[][] matrix;</span><br><span class="line">		Graph(E[] d, <span class="type">int</span>[][] m)&#123;</span><br><span class="line">			</span><br><span class="line">			data = d;</span><br><span class="line">			matrix  = <span class="keyword">new</span> <span class="title class_">int</span>[data.length][data.length];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;data.length;i++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;data.length;j++) &#123;</span><br><span class="line">					matrix[i][j] = m[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>[] m:matrix)</span><br><span class="line">				System.out.println(Arrays.toString(m));</span><br><span class="line">			System.out.println();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>[] m:rst)</span><br><span class="line">				System.out.println(Arrays.toString(m));</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">//对中间顶点遍历，k是中间顶点的下标</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;data.length;k++) &#123;</span><br><span class="line">				<span class="comment">//从i顶点出发</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;data.length;i++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;data.length;j++) &#123;</span><br><span class="line">						len = matrix[i][k] + matrix[k][j]; <span class="comment">//从i出发，经过k，到达j的距离</span></span><br><span class="line">						<span class="keyword">if</span>(len &lt; matrix[i][j]) &#123;</span><br><span class="line">							matrix[i][j] = len; </span><br><span class="line">						&#125;</span><br><span class="line">							</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210420170808831.png" alt="image-20210420170808831"></p>
<h2 id="10-马踏棋盘算法"><a href="#10-马踏棋盘算法" class="headerlink" title="10. 马踏棋盘算法"></a>10. 马踏棋盘算法</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>马踏棋盘问题，也称骑士周游问题，在国际象棋中，马只能走日，从某点出发，怎样才能走完棋盘上每个点，要求不重复？</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F202004%2F20200426140756952117.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621422824&t=3d94056536f8433f25ea731348608de9" alt="点击查看源网页"></p>
<p>马踏棋盘是典型的回溯问题，和迷宫问题属于同一类别</p>
<p>我们要考虑马的移动条件，找出下个能走的点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title function_">GetNext</span><span class="params">(Point curPoint)</span> &#123;</span><br><span class="line">		ArrayList&lt;Point&gt; ps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">X</span> <span class="operator">=</span> curPoint.x; <span class="comment">//表示列</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">Y</span> <span class="operator">=</span> curPoint.y; <span class="comment">//表示行</span></span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; Y-<span class="number">1</span> &gt;= <span class="number">0</span>) </span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">2</span>, Y-<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; Y-<span class="number">2</span> &gt;=<span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">1</span>, Y-<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">1</span> &lt; coloumn &amp;&amp; Y-<span class="number">2</span> &gt;=<span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">1</span>, Y-<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">2</span> &lt; coloumn &amp;&amp; Y-<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">2</span>, Y-<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; Y+<span class="number">1</span> &lt; row) </span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">2</span>, Y+<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; Y+<span class="number">2</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">1</span>, Y+<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">1</span> &lt;coloumn &amp;&amp; Y+<span class="number">2</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">1</span>, Y+<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">2</span> &lt; coloumn &amp;&amp; Y+<span class="number">1</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">2</span>, Y+<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<p>马在棋盘上走，遇到不能走的点要回溯，回溯需要递归的知识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">	ChessBoard[y][x] = step; <span class="comment">//给棋盘相应的位置标step(步数)</span></span><br><span class="line">	isVisited[y][x] = <span class="literal">true</span>;</span><br><span class="line">	ArrayList&lt;Point&gt; ps = GetNext(<span class="keyword">new</span> <span class="title class_">Point</span>(x, y));</span><br><span class="line">	sort(ps);</span><br><span class="line">	<span class="keyword">while</span>(!ps.isEmpty())&#123;</span><br><span class="line">		<span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> ps.remove(<span class="number">0</span>); <span class="comment">// 取出第一个point,下一步可以去走的点</span></span><br><span class="line">		<span class="keyword">if</span>(!isVisited[p.y][p.x])	</span><br><span class="line">			Run(p.x, p.y, step+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//发现走不了，而且还没走完棋盘上每个点，将此点标为未访问，回溯</span></span><br><span class="line">	<span class="keyword">if</span>(step &lt; row*coloumn &amp;&amp; ! finish) &#123;</span><br><span class="line">		</span><br><span class="line">		ChessBoard[y][x] = <span class="number">0</span>;</span><br><span class="line">		isVisited[y][x] = <span class="literal">false</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//走完，标为结束</span></span><br><span class="line">		finish = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> *1. 创建一个二维数组，作为棋盘<br> *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中<br> *3. 遍历ArrayList中的所有位置，看看哪个可以走通<br> *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 马踏棋盘算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 23881</span></span><br><span class="line"><span class="comment"> *1. 创建一个二维数组，作为棋盘</span></span><br><span class="line"><span class="comment"> *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中</span></span><br><span class="line"><span class="comment"> *3. 遍历ArrayList中的所有位置，看看哪个可以走通</span></span><br><span class="line"><span class="comment"> *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessHorseAlgorithm</span> &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> coloumn;<span class="comment">//列</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> row; <span class="comment">//行</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] ChessBoard;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span>[][] isVisited;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">finish</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Start(<span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> c 棋盘的列数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> r 棋盘的行数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> x 马位于第x列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> y 马位于第y行</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> step 步数</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Start</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		coloumn = c;</span><br><span class="line">		row = r;</span><br><span class="line">		ChessBoard = <span class="keyword">new</span> <span class="title class_">int</span>[row][coloumn];</span><br><span class="line">		isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[row][coloumn];</span><br><span class="line">		Run(x, y, <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>[] cb: ChessBoard)</span><br><span class="line">			System.out.println(Arrays.toString(cb));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span> &#123;</span><br><span class="line">		ChessBoard[y][x] = step; <span class="comment">//给棋盘相应的位置标step(步数)</span></span><br><span class="line">		isVisited[y][x] = <span class="literal">true</span>;</span><br><span class="line">		ArrayList&lt;Point&gt; ps = GetNext(<span class="keyword">new</span> <span class="title class_">Point</span>(x, y));</span><br><span class="line">		sort(ps);</span><br><span class="line">		<span class="keyword">while</span>(!ps.isEmpty())&#123;</span><br><span class="line">			<span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> ps.remove(<span class="number">0</span>); <span class="comment">// 取出第一个point,下一步可以去走的点</span></span><br><span class="line">			<span class="keyword">if</span>(!isVisited[p.y][p.x])	</span><br><span class="line">				Run(p.x, p.y, step+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(step &lt; row*coloumn &amp;&amp; ! finish) &#123;</span><br><span class="line">			</span><br><span class="line">			ChessBoard[y][x] = <span class="number">0</span>;</span><br><span class="line">			isVisited[y][x] = <span class="literal">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			finish = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> &#123;</span><br><span class="line">		ps.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Point arg0, Point arg1)</span> &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">return</span> GetNext(arg0).size() - GetNext(arg1).size();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title function_">GetNext</span><span class="params">(Point curPoint)</span> &#123;</span><br><span class="line">		ArrayList&lt;Point&gt; ps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="type">int</span> <span class="variable">X</span> <span class="operator">=</span> curPoint.x; <span class="comment">//表示列</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">Y</span> <span class="operator">=</span> curPoint.y; <span class="comment">//表示行</span></span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; Y-<span class="number">1</span> &gt;= <span class="number">0</span>) </span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">2</span>, Y-<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; Y-<span class="number">2</span> &gt;=<span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">1</span>, Y-<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">1</span> &lt; coloumn &amp;&amp; Y-<span class="number">2</span> &gt;=<span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">1</span>, Y-<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">2</span> &lt; coloumn &amp;&amp; Y-<span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">2</span>, Y-<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">2</span>&gt;=<span class="number">0</span> &amp;&amp; Y+<span class="number">1</span> &lt; row) </span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">2</span>, Y+<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X-<span class="number">1</span> &gt;=<span class="number">0</span> &amp;&amp; Y+<span class="number">2</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X-<span class="number">1</span>, Y+<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">1</span> &lt;coloumn &amp;&amp; Y+<span class="number">2</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">1</span>, Y+<span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(X+<span class="number">2</span> &lt; coloumn &amp;&amp; Y+<span class="number">1</span> &lt; row)</span><br><span class="line">			ps.add(<span class="keyword">new</span> <span class="title class_">Point</span>(X+<span class="number">2</span>, Y+<span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>
    
    
    
</div>
                        <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2024 Yao Xiong
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yao Xiong
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        


    </body>
</html>