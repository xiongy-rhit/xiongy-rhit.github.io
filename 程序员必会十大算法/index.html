
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>程序员必会十大算法 | Yao Xiong</title>
        <meta name="author" content="Yao Xiong">
        <meta name="description" content="莫听穿林打叶声， 何妨吟啸且徐行">
        <meta name="keywords" content="Yao Xiong Projects">
        <link rel="icon" href="/img/favicon.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:2147483647;justify-content:space-between;background:#fff;transition:all 0.3s ease-out;-webkit-user-select:none;-moz-user-select:none;user-select:none"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="showpage" style="display: -not-none">
                    <div id="menushow">
                        <nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yao Xiong</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;projects</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yao Xiong</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">projects</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div class="article">
    <div>
        <h1>程序员必会十大算法 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2021/5/16
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/java/" style="color: #ffa2c4">
                    java
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="color: #00a596">
                    数据结构与算法
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h2 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1. 二分查找算法"></a>1. 二分查找算法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419111722840.png" alt="image-20210419111722840"></p>
<p>这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N)</p>
<span id="more"></span>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>二分查找有2种实现方法：递归版和非递归版</p>
<p><strong>非递归版</strong></p>
<pre><code class="java">//非递归版本
public static int search(int[] array, int num) &#123;
    int left =0; //left表示左侧下标
    int right = array.length-1; //right表示右侧下标
    while(left &lt;= right) &#123; //结束的条件是左边大于右边
        int mid = (left+right)/2; //我们假设中间的数是目标
        if(array[mid] == num) &#123; // 判断，是
            return mid; //返回下标
        &#125;
        else if(array[mid] &gt; num) &#123; //判断发现中间的数比目标数大
            right = mid -1; //把中间的数的下标设置为右边， 减1是因为mid已经判断过了，比num大
        &#125;
        else &#123; //若小，则设置为左边
            left = mid+1;//加1的原因和上面类似
        &#125;
    &#125;
    return -1; //找完后发现没有找到，返回-1
&#125;
</code></pre>
<p><strong>递归版本</strong></p>
<p>具体步骤和上面非递归版本类似，推荐非递归版本</p>
<pre><code class="java">//递归版本
public static boolean search(int[] array, int num, int left, int right) &#123;
    int index = (left+right)/2;
    if(left&gt;right) &#123;
        return -1;
    &#125;
    print(array, left, right);
    if(array[index] &gt; num) &#123;
        return search(array, num, left, index-1);
    &#125;
    else if(array[index] &lt; num) &#123;
        return search(array, num, index+1, right);
    &#125;
    else
    &#123;
        return index;
    &#125;


&#125;
</code></pre>
<h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2. 分治算法"></a>2. 分治算法</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>分治算法，蕴含分而治之的思想，Divide and Conquer. 我们把难的问题逐个逐个拆分，拆分为小的问题，然后对于这个小的问题我们要给出解决办法，最后一步一步返回过去，将难的问题给解决，使用分治算法时，我们还利用了递归的思想，从拆分到组合</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们举汉诺塔的例子来讲分治算法</p>
<p>故事大家也都知道</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
</blockquote>
<p>64个盘看似很多，我们把这64个简化为3个</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419123047227.png" alt="image-20210419123047227"></p>
<p>3个盘，我们先把上面两个盘想办法<strong>从第1个柱子移到第2个柱子</strong></p>
<p>为了按照大小的顺序移动，先把第1个盘从第1个柱子移到第3个柱子，第2个盘从第1个柱子移到第2个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124339062.png" alt="image-20210419124339062"></p>
<p>接着把盘从第3个柱子移到第2个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124415703.png" alt="image-20210419124415703"></p>
<p>然后，把仅存在第1个柱子的盘移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124444560.png" alt="image-20210419124444560"></p>
<p>最后想办法把<strong>第2个柱子上的盘移到第3个柱子</strong></p>
<p>先把第2个柱子上的移到第1个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124656537.png" alt="image-20210419124656537"></p>
<p>再把最后一个移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124729238.png" alt="image-20210419124729238"></p>
<p><strong>最后一步</strong></p>
<p>把盘从第1个柱子移到第3个柱子</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419124828794.png" alt="image-20210419124828794"></p>
<p>假设有n个盘，3个柱A, B, C</p>
<ol>
<li>把n-1个盘从A到B</li>
<li>最后1个从A到C</li>
<li>再把n-1个盘从B移到C</li>
</ol>
<p>落实到代码</p>
<pre><code class="java">package algorithm;

public class HanoiTower &#123;
    static int count=0;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        move(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);
        System.out.println(count);
    &#125;
    
    public static void move(int num, char a, char b, char c) &#123;
        if(num==1) &#123;
            //只有1个盘，从A移动到C
            System.out.println(a+&quot;-&gt;&quot;+c);
            count++;
        &#125;
        else &#123;
            //把n-1个盘，从A移动到B
            move(num-1, a, c, b);//由于实参和形参的不同，我们可以改变实参以达到变换的目的
            System.out.println(a+&quot;-&gt;&quot;+c);
            count++;
            //再把剩下的从B移动到C
            move(num-1,b,a,c);
            
            
        &#125;
    &#125;

&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419140825279.png" alt="image-20210419140825279"></p>
<h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>和上面的分治算法有点类似，都是把复杂或大的问题拆解为小的问题，然后求解</p>
<p>不同在于，动态规划算法每一步和上一步之间有联系，所以动态规划算法适用于重叠的子问题求解</p>
<p>常见的利用动态规划算法求解的莫过于背包问题（01背包问题）</p>
<p>去商店买东西，背包有固定的容量，我们每个物品有且只能装入1次，最后我们要挑选出价值最高的物品组合。</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419132120492.png" alt="image-20210419132120492"></p>
<p>为了获取每个子问题的最优解，我们用二维数组来解决背包问题</p>
<p>列表示背包容量</p>
<p>行表示对应的商品</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419132323341.png" alt="image-20210419132323341"></p>
<p>第1列我们也设置为0</p>
<p>用双重for循环，从左往右，从上往下</p>
<p>当然，由于我们第1行和第1列都设置为0，我们从第2列和第2行开始bag[1][1]</p>
<p>从左往右，判断背包容量是否可以装入吉他，不行读取上面1格的值，然后向后，发现2kg可以装入吉他，把吉他装入，设置为$200，</p>
<p>走到电脑这一行，1kg无法放下，读取上面1格的值，向后，还是不行，继续向后，直到能装下，4kg，和上一个做对比，看哪个最后的值大，把大的放入</p>
<p>最后一行是书， 与上文一样，直到bag容量为3kg时，我们先装入1本书，还剩余2kg，我们选取没加这本书的时候的最佳值，也就是书所在上一行，剩余容量所在的位置的值， 就是$200 + $100, 然后我们比较和上一行的大小</p>
<table>
<thead>
<tr>
<th></th>
<th>0 kg</th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
</tr>
<tr>
<td>吉他</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$200</td>
</tr>
<tr>
<td>电脑</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$300</td>
</tr>
<tr>
<td>书</td>
<td>$0</td>
<td>$100</td>
<td>$200</td>
<td>$200+$100</td>
<td>$300</td>
</tr>
</tbody></table>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们除了要知道背包能存入的最大值，还应该知道存入的是哪些物品，所以我们还需要一个二维数组用来表示存了哪些物品</p>
<pre><code class="java">int[][] path=new int[n+1][m+1];
</code></pre>
<p>存入path所在的位置为1， 没有就是默认的0</p>
<p>打印</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>吉他</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>电脑</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>书</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>打印从右下角开始向上读，如果此时的标记为1，打印这个下标对应商品的下标，横坐标减去这个商品对应的容量</p>
<pre><code class="java">//为了显示装入的物品有哪些
        
int i=path.length-1;
int j=path[0].length-1;
while(i&gt;0 &amp;&amp; j&gt;0) &#123;
    if(path[i][j]==1) &#123;
        System.out.printf(&quot;把%s放入背包\n&quot;,obj[i-1]);
        j -= w[i-1];
    &#125;
    i--;
&#125;
</code></pre>
<p><strong>最后</strong></p>
<pre><code class="java">package algorithm;

public class Dynamic_Programming_Bag2 &#123;
    public static void main(String[] args) &#123;
        String[] obj = &#123;&quot;Guitar&quot;,&quot;Computer&quot;,&quot;Book&quot;&#125;;
        int[] v= &#123;200,300,100&#125;;
        int[] w= &#123;2,4,1&#125;;
        int m =4;//背包的容量
        int n = w.length;//物品的个数
        
        //背包
        int[][] bag =new int[n+1][m+1];
        
        
        //存储数组
        int[][] path=new int[n+1][m+1];
        
        for(int i=0;i&lt;bag.length;i++)
            bag[i][0]=0;//第一列设置为0
        for(int i=0;i&lt;bag[0].length;i++)
            bag[0][i]=0;//第一行设置为0
        
        for(int i=1;i&lt;bag.length;i++) &#123;
            for(int j=1;j&lt;bag[0].length;j++) &#123;
                if(w[i-1]&gt;j) &#123;
                    //容量不满足，直接继承上面一个
                    bag[i][j] = bag[i-1][j];
                &#125;else &#123;
                    //容量满足，和上面一个对比，选取最佳的value
                    //装入i-1个商品，到剩余空间j-w[i]的最大值
//                    bag[i][j] = Math.max(bag[i-1][j], v[i-1]+bag[i-1][j-w[i-1]]);
                    if(bag[i-1][j]&lt;v[i-1]+bag[i-1][j-w[i-1]]) &#123;
                        bag[i][j] = v[i-1]+bag[i-1][j-w[i-1]];
                        //把当前情况记录到path
                        path[i][j]=1;
                    &#125;else &#123;
                        bag[i][j] = bag[i-1][j];
                    &#125;
                    
                &#125;
            &#125;
        &#125;
        
        
      
//打印背包的Table
        
        //i表示行
        //j表示列
        for(int i=0;i&lt;bag.length;i++) &#123;
            for(int j=0;j&lt;bag[0].length;j++) &#123;
                System.out.printf(bag[i][j]+&quot;\t&quot;);
            &#125;
            System.out.println();
        &#125;
        
        
//为了显示装入的物品有哪些
        
        int i=path.length-1;
        int j=path[0].length-1;
        while(i&gt;0 &amp;&amp; j&gt;0) &#123;
            if(path[i][j]==1) &#123;
                System.out.printf(&quot;把%s放入背包\n&quot;,obj[i-1]);
                j -= w[i-1];
            &#125;
            i--;
        &#125;
        
    &#125;
&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419140711349.png" alt="image-20210419140711349"></p>
<h2 id="4-贪婪算法"><a href="#4-贪婪算法" class="headerlink" title="4. 贪婪算法"></a>4. 贪婪算法</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>贪婪算法，又称贪心算法，Greedy Algorithm。 在解决问题时，每次都选择最好的情况，用这种方法得出最后的解，注意：虽然贪婪算法每次都选最好的，但是最后的结果并不一定是最佳的</p>
<p>广播集合覆盖问题（贪心算法的应用）</p>
<p>我们要构建广播站，每个广播站覆盖的地区不一样，有些有交叉的地方，我们要用哪些广播站去覆盖全部地区。 </p>
<p>如图</p>
<table>
<thead>
<tr>
<th>地区： <strong>北京、上海、天津、广州、深圳、成都、杭州、大连</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>电台</td>
<td>覆盖数</td>
<td>地区</td>
</tr>
<tr>
<td>K1</td>
<td>3</td>
<td>北京、上海、天津</td>
</tr>
<tr>
<td>K2</td>
<td>3</td>
<td>广州、北京、深圳</td>
</tr>
<tr>
<td>K3</td>
<td>3</td>
<td>成都、上海、杭州</td>
</tr>
<tr>
<td>K4</td>
<td>2</td>
<td>上海、天津</td>
</tr>
<tr>
<td>K5</td>
<td>2</td>
<td>杭州、大连</td>
</tr>
</tbody></table>
<p>从电台里面选，哪些电台组合在一起就覆盖了全部地区？</p>
<p>首先，我们将每个电台与其覆盖的地区放入HashMap中， Key是电台名称， Value是储存此电台覆盖地区的HashSet。然后我们还要创建一个HashSet用来储存所有地区名称， 一个ArrayList储存最后的结果</p>
<p>我们构建一个循环，每次从循环找出地区数覆盖最多的电台，将这个电台加入到ArrayList中，然后从所有地区中清除这些地区，接着循环，当地区集合大小为0时停止。</p>
<p>这个看代码比较好理解</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        HashMap&lt;String, HashSet&lt;String&gt;&gt; radios = new HashMap&lt;&gt;();
        HashSet&lt;String&gt; k1 = new HashSet&lt;&gt;();
        k1.add(&quot;北京&quot;);
        k1.add(&quot;上海&quot;);
        k1.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; k2 = new HashSet&lt;&gt;();
        k2.add(&quot;广州&quot;);
        k2.add(&quot;北京&quot;);
        k2.add(&quot;深圳&quot;);
        
        HashSet&lt;String&gt; k3 = new HashSet&lt;&gt;();
        k3.add(&quot;成都&quot;);
        k3.add(&quot;上海&quot;);
        k3.add(&quot;杭州&quot;);
        
        HashSet&lt;String&gt; k4 = new HashSet&lt;&gt;();
        k4.add(&quot;上海&quot;);
        k4.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; k5 = new HashSet&lt;&gt;();
        k5.add(&quot;杭州&quot;);
        k5.add(&quot;大连&quot;);
        
        radios.put(&quot;k1&quot;, k1);
        radios.put(&quot;k2&quot;, k2);
        radios.put(&quot;k3&quot;, k3);
        radios.put(&quot;k4&quot;, k4);
        radios.put(&quot;k5&quot;, k5);
        
        HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;();
        allAreas.addAll(k1);
        allAreas.addAll(k2);
        allAreas.addAll(k3);
        allAreas.addAll(k4);
        allAreas.addAll(k5);
        
        ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();
        
        String MaxKey = null;
        while(!allAreas.isEmpty()) &#123;
            for(String key:radios.keySet()) &#123;
                HashSet&lt;String&gt; temp = radios.get(key);
                temp.retainAll(allAreas); //选取交集
                
                //必须交集大于0 或者 交集的大小大于最大的大小
                if( temp.size() &gt;0 &amp;&amp; (MaxKey == null || temp.size() &gt; radios.get(MaxKey).size())) &#123;
                    MaxKey = key; //才能赋值
                &#125;
            &#125;
            
            //当最大赋值不为NULL时，把答案添加进去，移除对应的地区
            if(MaxKey != null) &#123;
                result.add(MaxKey);
                allAreas.removeAll(radios.get(MaxKey));
            &#125;
            
        &#125;
        
        System.out.println(result);

    &#125;

&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419143839349.png" alt="image-20210419143839349"></p>
<h2 id="5-KMP算法"><a href="#5-KMP算法" class="headerlink" title="5. KMP算法"></a>5. KMP算法</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>KMP算法是常见的匹配字符串的算法，起初由名字里含有K, M, P的3个人所创建。讨论KMP算法之前我们要先了解暴力匹配字符串算法</p>
<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><p>为什么叫暴力匹配算法？这个方法虽然也是算法，也能帮我们解决问题，但是它的运行效率是比较低的。</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150304534.png" alt="image-20210419150304534"></p>
<p>找出‘FFD’所匹配的字符串的下标</p>
<p>第一行字符串假设为s1</p>
<p>第二行是s2</p>
<p>在While循环中，用s2的下标向s1的下标进行匹配，若所指下标不匹配，s2向后挪动1格</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150609480.png" alt="image-20210419150609480"></p>
<p>如此一直到s1上的FFD与s2上的FFD相互匹配，此时返回下标，当然这个下标应该要减去s2的长度</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419150742638.png" alt="image-20210419150742638"></p>
<h4 id="暴力匹配代码实现"><a href="#暴力匹配代码实现" class="headerlink" title="暴力匹配代码实现"></a>暴力匹配代码实现</h4><pre><code class="java">package algorithm;

public class ViolentMatching &#123;

    public static void main(String[] args) &#123;
        //暴力匹配算法 
        System.out.println(matching(&quot;ABCDBCEFFDHFCD&quot;,&quot;FFD&quot;));
        
    &#125;
    
    public static int matching(String str1, String str2) &#123;
        int i=0;
        int j=0;
        char[] s1 =str1.toCharArray();
        char[] s2 =str2.toCharArray();
        while(i&lt;s1.length &amp;&amp; j&lt;s2.length) &#123;
            if(s1[i] == s2[j]) &#123; //相匹配，两下标各向后移动1
                i++;
                j++;
            &#125;
            else &#123; //发现不匹配，s2的下标从头开始， s1的下标应该减去刚才匹配的长度然后+1
                
                i= i-j+1;
                j=0;
                
            &#125;
        &#125;
        
        //最后找到返回下标
        if(j==s2.length)
            return i-j;
        else &#123;
            return -1;
        &#125;
        
    &#125;

&#125;
</code></pre>
<p>在暴力匹配当中，s2每次只往后移动1格，有些之前匹配过的还要再匹配，一旦字符串较长时，匹配所需要的时间就会增加很多，所以我们需要用KMP算法来进行优化</p>
<pre><code class="java">String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;;
String str2 =&quot;ABCDABD&quot;;
</code></pre>
<p>KMP在实现匹配之前要根据s2的前后缀最大公共元素的长度来建立一个匹配池</p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>D</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>字串</strong></th>
<th><strong>前缀</strong></th>
<th><strong>后缀</strong></th>
<th><strong>最大公共长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>空</td>
<td>空</td>
<td>0</td>
</tr>
<tr>
<td>AB</td>
<td>A</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>ABC</td>
<td>A, AB</td>
<td>BC, C</td>
<td>0</td>
</tr>
<tr>
<td>ABCD</td>
<td>A,AB,ABC</td>
<td>BCD, CD, D</td>
<td>0</td>
</tr>
<tr>
<td>ABCDA</td>
<td>A,AB,ABC,ABCD</td>
<td>BCDA, CDA, DA, A</td>
<td>1</td>
</tr>
<tr>
<td>ABCDAB</td>
<td>A, AB, ABC, ABCD, ABCDA</td>
<td>BCDAB, CDAB, DAB, AB, B</td>
<td>2</td>
</tr>
<tr>
<td>ABCDABD</td>
<td>A, AB, ABC, ABCD, ABCDA, ABCDAB</td>
<td>BCDABD, CDABD, DABD, ABD, BD, D</td>
<td>0</td>
</tr>
</tbody></table>
<p>有了匹配表后，我们要对之前暴力匹配的算法进行更新</p>
<pre><code class="java">//若字符匹配不相等
//KMP算法核心
while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;
    j = map[j-1];
&#125;
//失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值
</code></pre>
<h3 id="KMP代码实现"><a href="#KMP代码实现" class="headerlink" title="KMP代码实现"></a>KMP代码实现</h3><pre><code class="java">package algorithm;


public class KMPAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;;
        String str2 =&quot;ABCDABD&quot;;
        System.out.println(KMP(str1, str2, MatchMap(str2)));
    &#125;
    
    /**
     * 构建字符匹配表
     * @param dest 传入字符串 
     * @return 返回匹配后的数组
     */
    public static int[] MatchMap(String dest) &#123;
        int[] map = new int[dest.length()];
        map[0]=0;
        for(int i=1, j=0; i&lt;dest.length();i++) &#123;
            
            //KMP算法核心
            while(j &gt;0 &amp;&amp; dest.charAt(i)!=dest.charAt(j)) &#123;
                j = map[j-1];
            &#125;
            //部分匹配值+1
            if(dest.charAt(i)==dest.charAt(j)) &#123;
                j++;
            &#125;
            map[i] =j;
        &#125;
        return map;
    &#125;
    
    /**
     * 
     * @param st1 被匹配的长字符串
     * @param st2 拿来匹配的字符串
     * @param map 字符匹配表
     * @return 返回-1 或对应匹配的位置
     */
    public static int KMP(String st1, String st2, int[] map) &#123;
        for(int i=0, j=0;i&lt;st1.length();i++) &#123;
            //若字符匹配不相等
            //KMP算法核心
            while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;
                j = map[j-1];
            &#125;
            
            //字符匹配相等
            if(st1.charAt(i)==st2.charAt(j)) &#123;
                j++;
            &#125;
            
            if(j &gt;= st2.length())
                return i-j+1;
        &#125;
        return -1;
    &#125;

&#125;
</code></pre>
<h2 id="6-Prim算法"><a href="#6-Prim算法" class="headerlink" title="6. Prim算法"></a>6. Prim算法</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>Prim算法用于解决修路最短路径问题，有7个村庄，要用路把它们连接，问怎么修路使总路程最短，且路可以到达每个村庄</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419184711756.png" alt="image-20210419184711756"></p>
<p>最小生成树问题</p>
<ol>
<li>这个问题要利用图的知识来求解</li>
<li>需要构建二维数组（邻接矩阵）来表示顶点间的关系</li>
<li>既然每个顶点只能访问一次，需要一个boolean 数组，来储存该顶点是否被访问过</li>
<li>最终边（路）的条数应该为顶点数-1</li>
<li>为了知道是哪2个顶点之间相互连接，我们要将顶点的数据（顶点是哪2个，边的权值是多少）存起来</li>
</ol>
<ol>
<li>图</li>
</ol>
<pre><code class="java">//使用静态内部类的形式来构建
private static class Graph&#123;
    public int vertex;
    public char[] data;
    int[][] weight;
    Graph(char[] d, int[][] w)&#123;
        vertex = d.length;
        data = d;
        weight = w;
    &#125;


&#125;
</code></pre>
<ol start="2">
<li>二维数组</li>
</ol>
<pre><code class="java">int [][] weight= &#123;
    &#123;0,5,7,0,0,0,2&#125;,
    &#123;5,0,0,9,0,0,3&#125;,
    &#123;7,0,0,0,8,0,0&#125;,
    &#123;0,9,0,0,0,4,0&#125;,
    &#123;0,0,8,0,0,5,4&#125;,
    &#123;0,0,0,4,5,0,6&#125;,
    &#123;2,3,0,0,4,6,0&#125;
&#125;;
</code></pre>
<ol start="3">
<li>boolean数组</li>
</ol>
<pre><code class="java">boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
</code></pre>
<ol start="4">
<li>Prim算法的核心</li>
</ol>
<pre><code class="java">//编写Prim算法，得到最小生成树
/**
* 
* @param v 从图的第几个顶点开始找
*/
public void Prim(int v) &#123;
    boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
    isVisited[v] = true; //默认设置从第v个顶点开始
    /**用 h1和h2 记录2个顶点的下标*/
    int h1=-1;
    int h2=-1;
    int max=getMax(); // getMax是一个函数，用于获取此矩阵中的最大值，方便后面做比较
    int count=0; //用于统计总路径长度
    HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;();  //储存最后的结果

    for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个
        int minWeight = max;

        //双重循环
        for(int i=0;i&lt;graph.vertex;i++) &#123;
            for(int j=0;j&lt;graph.vertex;j++) &#123;
                //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有
                if(isVisited[i]==true 
                   &amp;&amp; isVisited[j]==false 
                   &amp;&amp; graph.weight[i][j] &lt; minWeight //比目前最大的数要小
                   &amp;&amp; graph.weight[i][j] != 0) &#123; //且不为0
                    minWeight = graph.weight[i][j]; //将最小的换为此时的权重
                    h1=i; 
                    h2=j; //标记这2个点
                &#125;
            &#125;
        &#125;

        isVisited[h2] = true; //第二个点设为已访问，之后会从这一行开始访问
        result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]);
        count += graph.weight[h1][h2];
    &#125;

    System.out.println();
    for(Entry&lt;String, Integer&gt; rst:result.entrySet())
        System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue());
    System.out.println(&quot;Min Path: &quot;+count);

&#125;
</code></pre>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map.Entry;

public class PrimAlgorithm &#123;
    public static void main(String[] args) &#123;
        char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;
        //邻接矩阵的关系用二维数组来表示
        int [][] weight= &#123;
                &#123;0,5,7,0,0,0,2&#125;,
                &#123;5,0,0,9,0,0,3&#125;,
                &#123;7,0,0,0,8,0,0&#125;,
                &#123;0,9,0,0,0,4,0&#125;,
                &#123;0,0,8,0,0,5,4&#125;,
                &#123;0,0,0,4,5,0,6&#125;,
                &#123;2,3,0,0,4,6,0&#125;
        &#125;;
        MinTree tree = new MinTree();
        tree.createGraph(new Graph(data, weight));
        tree.showGraph();
        
        tree.Prim(0);
        
    
    &#125;
    
    
    private static class MinTree&#123;
        private Graph graph;
        //创建图的邻接矩阵
        public void createGraph(Graph g) &#123;
            graph = g;
        &#125;
        
        //打印图
        public void showGraph() &#123;
            for(int[] w:graph.weight)
                System.out.println(Arrays.toString(w));
        &#125;
        
        //编写Prim算法，得到最小生成树
        /**
         * 
         * @param v 从图的第几个顶点开始找
         */
        public void Prim(int v) &#123;
            boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
            isVisited[v] = true; //默认设置从第v个顶点开始
            /**用 h1和h2 记录2个顶点的下标*/
            int h1=-1;
            int h2=-1;
            int max=getMax();
            int count=0;
            HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); 
    
            for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个
                int minWeight = max;
                
                //双重循环
                for(int i=0;i&lt;graph.vertex;i++) &#123;
                    for(int j=0;j&lt;graph.vertex;j++) &#123;
                        //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有
                        if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight &amp;&amp; graph.weight[i][j] != 0) &#123;
                            minWeight = graph.weight[i][j];
                            h1=i;
                            h2=j;
                        &#125;
                    &#125;
                &#125;
                
                isVisited[h2] = true; //设置成访问，之后会从这一行开始访问
                result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]);
                count += graph.weight[h1][h2];
            &#125;
            
            System.out.println();
            for(Entry&lt;String, Integer&gt; rst:result.entrySet())
                System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue());
            System.out.println(&quot;Min Path: &quot;+count);
            
        &#125;
        
        private int getMax() &#123;
            int max=graph.weight[0][0];
            for(int i=0;i&lt;graph.vertex;i++) &#123;
                for(int j=0;j&lt;graph.vertex;j++) &#123;
                    if(graph.weight[i][j]&gt;max)
                        max = graph.weight[i][j];
                &#125;
            &#125;
            return max;
                
        &#125;
        
        
    &#125;
    
    private static class Graph&#123;
        public int vertex;
        public char[] data;
        int[][] weight;
        Graph(char[] d, int[][] w)&#123;
            vertex = d.length;
            data = d;
            weight = w;
        &#125;
        
        
    &#125;
&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210419194332111.png" alt="image-20210419194332111"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的代码是自学写的，时间复杂度很高，（n^3）， 一般的Prim算法时间复杂度仅（n^2），下面贴出更改后的代码</p>
<pre><code class="java">package algorithm;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;

public class PrimAlgorithm2 &#123;

    private static int INF=Integer.MAX_VALUE;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;
        
        //不相邻的顶点，用INF表示
        int [][] map= &#123;
                &#123;0,5,7,INF,INF,INF,2&#125;,
                &#123;5,0,INF,9,INF,INF,3&#125;,
                &#123;7,INF,0,INF,8,INF,INF&#125;,
                &#123;INF,9,INF,0,INF,4,INF&#125;,
                &#123;INF,INF,8,INF,0,5,4&#125;,
                &#123;INF,INF,INF,4,5,0,6&#125;,
                &#123;2,3,INF,INF,4,6,0&#125;
        &#125;;
        System.out.println(&quot;Start&quot;);
        Prim(1, map, data);
    &#125;
    
    //输入起始顶点，邻接矩阵，顶点信息
    public static void Prim(int start, int[][] map, char[] data) &#123;
        //用于存储最终的各种信息
        HashMap&lt;String, Integer&gt; paths = new HashMap&lt;&gt;();
        //存储整个data长度
        int num = data.length;
        
        //存放前顶点
        int[] pre =new int[num];
        //权重 
        int[] weights = new int[num]; 
        //初始化
        for(int i=0;i&lt;weights.length;i++) &#123;
            weights[i] = map[start][i]; //默认权重以start为基准
            //与start顶点相连
            if(weights[i] !=INF)
                pre[i] =start; //把前节点设为start
        &#125;
        //start自身权重为0 
        weights[start] =0; 
        //start前结点为-1，即不存在
        pre[start] =-1;
        
        //主体程序
        for(int i=0;i&lt; num;i++) &#123;
            //start顶点前面已经初始化过了
            if(i == start)
                continue;
            
            //设置2 个下标，用来记录最短边的顶点
            int j=0;
            int k=0;
            
            //最小长度
            int min = INF;
            
            
            //从左往右对weights遍历， 找出最小边
            while(j &lt; num) &#123;
                //权重最小且不为0
                if(weights[j]!=0 &amp;&amp;weights[j] &lt; min) &#123;
                    min = weights[j];
                    k = j; //赋值
                &#125;
                j++;
            &#125;
            
            //把最小边相连的一个顶点设为0
            weights[k] =0;
            
            //重置权重（比较重要）
            for(int n=0;n&lt;num;n++) &#123;
                //权重不为0， 且新的两顶点之间权重小于目前的
                if(weights[n]!=0 &amp;&amp; map[k][n] &lt; weights[n]) &#123;
                    //更新权重和前节点
                    pre[n] = k; 
                    weights[n] = map[k][n];
                &#125;
            &#125;
            
            
        &#125;
        
        //最小生成树信息
        for(int i=0;i&lt;num;i++) &#123;
            if(pre[i] !=-1) &#123;
                paths.put(data[pre[i]]+&quot;-&quot;+data[i], map[pre[i]][i]);
            &#125;
        &#125;
        
        //打印信息
        int count =0;
        for(Entry&lt;String, Integer&gt; p:paths.entrySet()) &#123;
            count += p.getValue();
            System.out.println(p.getKey()+&quot; : &quot;+p.getValue());
        &#125;
        
        //打印最终长度
        System.out.println(&quot;Least : &quot;+count);
        
    &#125;
&#125;
    
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210528231519025.png" alt="image-20210528231519025"></p>
<h2 id="7-Kruskal算法"><a href="#7-Kruskal算法" class="headerlink" title="7. Kruskal算法"></a>7. Kruskal算法</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>克鲁斯卡尔算法和上面的Prim算法功能都一样，是找出最短总路径；但是Kruskal算法用另外一种方式来解决这个问题</p>
<ul>
<li><ol>
<li>创建每条边的List</li>
</ol>
</li>
<li><ol start="2">
<li>把边添加进List</li>
</ol>
</li>
<li><ol start="3">
<li>对List排序</li>
</ol>
</li>
<li><ol start="4">
<li>从头到尾读取List， 判断边的两个顶点是否形成回路</li>
</ol>
</li>
</ul>
<p>为了将顶点间的边进行排序，我们需要创建一个Edge类且实现comparable接口</p>
<pre><code class="java">//Edge也是一个静态内部类
private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123;
    public int x;
    public int y;
    public int weight;
    Edge(int a, int b, int w)&#123;
        x = a;
        y = b;
        weight = w;
    &#125;

    public String print(E[] data) &#123;
        return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight;
    &#125;

    @Override
    public int compareTo(Edge&lt;String&gt; e) &#123;
        // TODO Auto-generated method stub
        return weight -e.weight;
    &#125;

&#125;
</code></pre>
<p>把所有可能加入list并排序</p>
<pre><code class="java">boolean[][] isVisited = new boolean[data.length][data.length];
LinkedList&lt;Edge&lt;String&gt;&gt; list =  new LinkedList&lt;&gt;();
for(int i=0;i&lt;weight.length;i++) &#123;
    for(int j=0;j&lt;weight.length;j++) &#123;
        if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123;
            list.add(new Edge&lt;String&gt;(i, j, weight[i][j]));
            isVisited[i][j] = true;
            isVisited[j][i] = true;
        &#125;
    &#125;
&#125;

Collections.sort(list);
</code></pre>
<p>克鲁斯卡尔算法的精髓</p>
<pre><code class="java">int[] ends = new int[data.length];
for(Edge&lt;String&gt; e:list) &#123;
    if(result.size() == data.length-1)
        break;


    //克鲁斯卡尔算法精髓
    int m = GetEnd(ends, e.x);
    int n = GetEnd(ends, e.y);
    //判断终点是否是一样的，即是否形成回路
    if(m !=n) &#123;
        ends[m]=n;
        result.add(e);
    &#125;

&#125;

/**
     * 获取对应下标的终点
     * @param ends
     * @param i
     * @return
     */
private static int GetEnd(int[] ends, int i) &#123;
    while(ends[i] !=0)
        i = ends[i];
    return i;
&#125;
    
</code></pre>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Collections;
import java.util.LinkedList;

/**
 * Kruskar算法
 * 1. 创建每条边的List
 * 2. 把边添加进List
 * 3. 对List排序
 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路
 * @author 23881
 *
 */
public class KruskalAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        
//        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;;
//        int[][] weight= &#123;
//                &#123;0,3,3,7&#125;,
//                &#123;3,0,2,4&#125;,
//                &#123;3,2,0,6&#125;,
//                &#123;7,4,6,0&#125;
//        &#125;;
        
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] weight= &#123;
                &#123;0,12,0,0,0,16,14&#125;,
                &#123;12,0,10,0,0,7,0&#125;,
                &#123;0,10,0,3,5,6,0&#125;,
                &#123;0,0,3,0,4,0,0&#125;,
                &#123;0,0,5,4,0,2,8&#125;,
                &#123;16,7,6,0,2,0,9&#125;,
                &#123;14,0,0,0,8,9,0&#125;
        &#125;;
        
        Kruskar(data, weight);
        

    &#125;
    
    public static void Kruskar(String[] data, int[][] weight) &#123;
        boolean[][] isVisited = new boolean[data.length][data.length];
        LinkedList&lt;Edge&lt;String&gt;&gt; list =  new LinkedList&lt;&gt;();
        LinkedList&lt;Edge&lt;String&gt;&gt; result =  new LinkedList&lt;&gt;();
        for(int i=0;i&lt;weight.length;i++) &#123;
            for(int j=0;j&lt;weight.length;j++) &#123;
                if(isVisited[i][j] == false&amp;&amp; isVisited[j][i] == false &amp;&amp; weight[i][j] != 0) &#123;
                    list.add(new Edge&lt;String&gt;(i, j, weight[i][j]));
                    isVisited[i][j] = true;
                    isVisited[j][i] = true;
                &#125;
            &#125;
        &#125;
        
        Collections.sort(list);
        for(Edge&lt;String&gt; e:list) 
            System.out.println(e.print(data));
        System.out.println();
        
        int[] ends = new int[data.length];
        for(Edge&lt;String&gt; e:list) &#123;
            if(result.size() == data.length-1)
                break;
            
            
            //克鲁斯卡尔算法精髓, Disjoint Set
            int m = GetEnd(ends, e.x);
            int n = GetEnd(ends, e.y);
            //判断终点是否是一样的，即是否形成回路
            if(m !=n) &#123;
                ends[m]=n;
                result.add(e);
            &#125;
                
            
            
            
        &#125;
        
        for(Edge&lt;String&gt; e:result) 
            System.out.println(e.print(data));
    

        
        
    &#125;
    
    /**
     * 获取对应下标的终点
     * @param ends
     * @param i
     * @return
     */
    private static int GetEnd(int[] ends, int i) &#123;
        while(ends[i] !=0)
            i = ends[i];
        return i;
    &#125;
    
    private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123;
        public int x;
        public int y;
        public int weight;
        Edge(int a, int b, int w)&#123;
            x = a;
            y = b;
            weight = w;
        &#125;
        
        public String print(E[] data) &#123;
            return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight;
        &#125;

        @Override
        public int compareTo(Edge&lt;String&gt; e) &#123;
            // TODO Auto-generated method stub
            return weight -e.weight;
        &#125;
        
    &#125;

&#125;
</code></pre>
<h2 id="8-Dijkstra算法"><a href="#8-Dijkstra算法" class="headerlink" title="8. Dijkstra算法"></a>8. Dijkstra算法</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>Dijkstra算法是解决某个顶点到其他顶点的最小路径问题，（邮差问题）</p>
<p>有A, B,C,D,E,F,G七个村庄，此时派出6个邮差从某点出发给另外几个村庄送信，怎样才能让每个邮差最快到达指定的村庄？</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193626257.png" alt="image-20210509193626257"></p>
<p>村庄连接问题，需要用图与广度优先的知识进行求解</p>
<p>构建一个Graph类，这个类用于存储，每个顶点的前访问顶点， PreNode[ ]， 这个和Disjoint Set很相似，同时我们还在这个Graph类里面存储每个顶点的访问情况与到指定顶点的最短距离</p>
<pre><code class="java">private static class Graph&#123;
        private boolean[] isVisited; //存储是否被访问
        private int[] PreNode; //前结点集合
        private int[] Dis; //存储到每个顶点的最短距离
        private final static int infinity = Integer.MAX_VALUE; //常量
        
        public Graph(int len)&#123;
            //初始化变量
            isVisited = new boolean[len];
            PreNode = new int[len];
            Dis = new int[len];

            //假设每个顶点的前一个顶点都是他们自己
            for(int i=0;i&lt;len;i++) &#123;
                PreNode[i] = -1;
                Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷
        
            &#125;
            
        &#125;

        //展示最短距离
        public void ShowDis() &#123;
            System.out.println(Arrays.toString(Dis));
        &#125;
        
        //展示前顶点
        public void ShowPreNode() &#123;
            System.out.println(Arrays.toString(PreNode));
        &#125;
        
        //展示访问的情况
        public void ShowVisited() &#123;
            System.out.println(Arrays.toString(isVisited));
        &#125;
        
        //获取某个顶点到目标的最短距离
        public int GetDis(int n) &#123;
            return Dis[n];
        &#125;
        
        //设置某顶点到目标的最短距离
        public void SetDis(int n, int m) &#123;
            Dis[n] =m;
        &#125;
        
        //获取前访问顶点
        public int GetPreNode(int n) &#123;
            return PreNode[n];
        &#125;
        
        //设置前访问顶点
        public void SetPreNode(int n, int m) &#123;
            PreNode[n] =m;
        &#125;
        
        //获取顶点的访问状态
        public boolean GetVisited(int n) &#123;
            return isVisited[n];
        &#125;
        
        //设置顶点的访问状态
        public void SetVisited(int n, boolean rst) &#123;
            isVisited[n] = rst;
        &#125;    
    &#125;
</code></pre>
<p><strong>Dijkstra 算法精髓</strong></p>
<p>首先我们要从一个顶点开始，获得与这个顶点连接的顶点</p>
<p>（考虑到之后可能会使用广度优先，我们这里用LinkedList来存储顶点数据）</p>
<pre><code class="java">Graph graph = new Graph(matrix[0].length); //初始化一个Graph类
graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0
LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列

//把第一个顶点压入队列
list.push(index);

//暂时变量
int dis=0;
int temp =0;

//结束的条件就是队列为空
while(!list.isEmpty()) &#123;
    temp = list.pop(); //从队列中pop一个元素
    //寻找与此元素相连的顶点
    for(int i=0;i&lt;matrix[temp].length;i++) &#123;
        //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点
        if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123;
            //获取此时的路径长度
            dis = matrix[temp][i]+graph.GetDis(temp);
            //如果这个长度小于已有的长度
            if(dis&lt;graph.GetDis(i)) &#123;
                //对原顶点的长度进行替换
                graph.SetPreNode(i, temp);
                //修改preNode
                graph.SetDis(i, dis);
                
                //能够被压入队列的条件：没被访问过且不在队列中
                if(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123;
                    list.push(i);
                &#125;
            &#125;
        &#125;
    &#125;
    //一个顶点完成遍历后，将其设置为已访问
    graph.SetVisited(temp, true);
&#125;
</code></pre>
<p>最终</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.LinkedList;

public class DijkstraAlgorithm2 &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] matrix = &#123;
                &#123;0,5,7,0,0,0,2&#125;,
                &#123;5,0,0,9,0,0,3&#125;,
                &#123;7,0,0,0,8,0,0&#125;,
                &#123;0,9,0,0,0,4,0&#125;,
                &#123;0,0,8,0,0,5,4&#125;,
                &#123;0,0,0,4,5,0,6&#125;,
                &#123;2,3,0,0,4,6,0&#125;
        &#125;;
        
        Dijkstra(matrix, 0);
    &#125;
    
    /*结束条件：队列为空
     * 判断条件：not preNode
     *     改变Dis与Pre条件
     *         小于已有距离
     *     压入条件
     *         not visited 且 不在队列中
     * 
     * 遍历完一个点后，将此点改为isvisited
     * */
    public static void Dijkstra(int[][] matrix, int index) &#123;
        Graph graph = new Graph(matrix[0].length);
        graph.SetDis(index, 0);
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        
        
        list.push(index);
        graph.SetVisited(index, true);
        int dis=0;
        int temp =0;
        
        while(!list.isEmpty()) &#123;
            temp = list.pop();
            for(int i=0;i&lt;matrix[temp].length;i++) &#123;
                if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123;
                    dis = matrix[temp][i]+graph.GetDis(temp);
                    if(dis&lt;graph.GetDis(i)) &#123;
                        graph.SetPreNode(i, temp);
                        graph.SetDis(i, dis);
                        if(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123;
                            list.push(i);
                        &#125;
                    &#125;
                &#125;
            &#125;
            graph.SetVisited(temp, true);
        &#125;

        
        System.out.println(&quot;Final Distence&quot;);
        graph.ShowDis();
        
        System.out.println(&quot;\nFinal Pre-Node&quot;);
        graph.ShowPreNode();
        
        System.out.println(&quot;\nAdjacent Matrix&quot;);
        for(int[] i:matrix) &#123;
            System.out.println(Arrays.toString(i));
        &#125;
        
    &#125;
    
    
    
    
    private static class Graph&#123;
        private boolean[] isVisited;
        private int[] PreNode;
        private int[] Dis;
        private final static int infinity = Integer.MAX_VALUE;
        
        public Graph(int len)&#123;
    
            isVisited = new boolean[len];
            PreNode = new int[len];
            Dis = new int[len];

            
            for(int i=0;i&lt;len;i++) &#123;
                PreNode[i] = -1;
                Dis[i] = infinity;
        
            &#125;
            
        &#125;

        
        public void ShowDis() &#123;
            System.out.println(Arrays.toString(Dis));
        &#125;
        
        public void ShowPreNode() &#123;
            System.out.println(Arrays.toString(PreNode));
        &#125;
        
        public int GetDis(int n) &#123;
            return Dis[n];
        &#125;
        
        public void SetDis(int n, int m) &#123;
            Dis[n] =m;
        &#125;
        
        public int GetPreNode(int n) &#123;
            return PreNode[n];
        &#125;
        
        public void SetPreNode(int n, int m) &#123;
            PreNode[n] =m;
        &#125;
        
        public boolean GetVisited(int n) &#123;
            return isVisited[n];
        &#125;
        
        public void SetVisited(int n, boolean rst) &#123;
            isVisited[n] = rst;
        &#125;
        
        
        
        
    &#125;

&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193843994.png" alt="image-20210509193843994"></p>
<h2 id="9-Floyd算法"><a href="#9-Floyd算法" class="headerlink" title="9. Floyd算法"></a>9. Floyd算法</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>Floyd算法解决的问题和上面Dijkstra算法解决的问题一样；Floyd算法更容易理解，但是它的运行效率没有Dijkstra算法高</p>
<p>Floyd算法使用3个for循环进行嵌套</p>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210509193707615.png" alt="image-20210509193707615"></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;

public class FloydAlgorithm &#123;
    public static void main(String[] args) &#123;
        int N=255; //N表示两个顶点间不相连
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] matrix = &#123;
                &#123;0,5,7,N,N,N,2&#125;,
                &#123;5,0,N,9,N,N,3&#125;,
                &#123;7,N,0,N,8,N,N&#125;,
                &#123;N,9,N,0,N,4,N&#125;,
                &#123;N,N,8,N,0,5,4&#125;,
                &#123;N,N,N,4,5,0,6&#125;,
                &#123;2,3,N,N,4,6,0&#125;
        &#125;;
        Floyd(data, matrix);
        
    &#125;
    
    public static &lt;E&gt; void Floyd(E[] d, int[][] m ) &#123;
        Graph&lt;E&gt; graph = new Graph&lt;&gt;(d, m);
//        graph.showGraph();
        graph.start();
        graph.showGraph();
    &#125;
    
    private static class Graph&lt;E&gt;&#123;
        private E[] data;
        private int[][] matrix;
        Graph(E[] d, int[][] m)&#123;
            
            data = d;
            matrix  = new int[data.length][data.length];
            for(int i=0;i&lt;data.length;i++) &#123;
                for(int j=0;j&lt;data.length;j++) &#123;
                    matrix[i][j] = m[i][j];
                &#125;
            &#125;
        &#125;
        
        public void showGraph() &#123;
            for(int[] m:matrix)
                System.out.println(Arrays.toString(m));
            System.out.println();
            for(int[] m:rst)
                System.out.println(Arrays.toString(m));
            System.out.println();
        &#125;
        
        public void start() &#123;
            int len=0;
            //对中间顶点遍历，k是中间顶点的下标
            for(int k=0;k&lt;data.length;k++) &#123;
                //从i顶点出发
                for(int i=0;i&lt;data.length;i++) &#123;
                    for(int j=0;j&lt;data.length;j++) &#123;
                        len = matrix[i][k] + matrix[k][j]; //从i出发，经过k，到达j的距离
                        if(len &lt; matrix[i][j]) &#123;
                            matrix[i][j] = len; 
                        &#125;
                            
                    &#125;
                &#125;
            &#125;
        &#125;
        
        
    &#125;
&#125;
</code></pre>
<p><img src="/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/image-20210420170808831.png" alt="image-20210420170808831"></p>
<h2 id="10-马踏棋盘算法"><a href="#10-马踏棋盘算法" class="headerlink" title="10. 马踏棋盘算法"></a>10. 马踏棋盘算法</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>马踏棋盘问题，也称骑士周游问题，在国际象棋中，马只能走日，从某点出发，怎样才能走完棋盘上每个点，要求不重复？</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F202004%2F20200426140756952117.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621422824&t=3d94056536f8433f25ea731348608de9" alt="点击查看源网页"></p>
<p>马踏棋盘是典型的回溯问题，和迷宫问题属于同一类别</p>
<p>我们要考虑马的移动条件，找出下个能走的点</p>
<pre><code class="java">public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123;
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;();
        int X = curPoint.x; //表示列
        int Y = curPoint.y; //表示行
        if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) 
            ps.add(new Point(X-2, Y-1));
        
        if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X-1, Y-2));
        
        if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X+1, Y-2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0)
            ps.add(new Point(X+2, Y-1));
        
        
        if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) 
            ps.add(new Point(X-2, Y+1));
        
        if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X-1, Y+2));
        
        if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X+1, Y+2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row)
            ps.add(new Point(X+2, Y+1));
        
        return ps;
    &#125;
</code></pre>
<p>马在棋盘上走，遇到不能走的点要回溯，回溯需要递归的知识</p>
<pre><code class="java">    private static void Run(int x, int y, int step) &#123;
        ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数)
        isVisited[y][x] = true;
        ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y));
        sort(ps);
        while(!ps.isEmpty())&#123;
            Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点
            if(!isVisited[p.y][p.x])    
                Run(p.x, p.y, step+1);
        &#125;

        //发现走不了，而且还没走完棋盘上每个点，将此点标为未访问，回溯
        if(step &lt; row*coloumn &amp;&amp; ! finish) &#123;
            
            ChessBoard[y][x] = 0;
            isVisited[y][x] = false;
        &#125;else &#123;
            //走完，标为结束
            finish = true;
        &#125;
            
            
    &#125;
</code></pre>
<p> *1. 创建一个二维数组，作为棋盘<br> *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中<br> *3. 遍历ArrayList中的所有位置，看看哪个可以走通<br> *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

/**
 * 马踏棋盘算法
 * @author 23881
 *1. 创建一个二维数组，作为棋盘
 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中
 *3. 遍历ArrayList中的所有位置，看看哪个可以走通
 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0
 */
public class ChessHorseAlgorithm &#123;
    
    
    private static int coloumn;//列
    private static int row; //行
    private static int[][] ChessBoard;
    private static boolean[][] isVisited;
    private static boolean finish = false;
    
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Start(8, 8, 2, 1);
    &#125;
    
    /**
     * 
     * @param c 棋盘的列数
     * @param r 棋盘的行数
     * @param x 马位于第x列
     * @param y 马位于第y行
     * @param step 步数
     * 
     */
    public static void Start(int c, int r, int x, int y) &#123;
        coloumn = c;
        row = r;
        ChessBoard = new int[row][coloumn];
        isVisited = new boolean[row][coloumn];
        Run(x, y, 1);
        
        for(int[] cb: ChessBoard)
            System.out.println(Arrays.toString(cb));
    &#125;
    
    private static void Run(int x, int y, int step) &#123;
        ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数)
        isVisited[y][x] = true;
        ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y));
        sort(ps);
        while(!ps.isEmpty())&#123;
            Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点
            if(!isVisited[p.y][p.x])    
                Run(p.x, p.y, step+1);
        &#125;

        if(step &lt; row*coloumn &amp;&amp; ! finish) &#123;
            
            ChessBoard[y][x] = 0;
            isVisited[y][x] = false;
        &#125;else &#123;
            finish = true;
        &#125;
            
            
    &#125;
    
    public static void sort(ArrayList&lt;Point&gt; ps) &#123;
        ps.sort(new Comparator&lt;Point&gt;() &#123;

            @Override
            public int compare(Point arg0, Point arg1) &#123;
                // TODO Auto-generated method stub
                return GetNext(arg0).size() - GetNext(arg1).size();
            &#125;
            
        &#125;);
    &#125;
    
    public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123;
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;();
        int X = curPoint.x; //表示列
        int Y = curPoint.y; //表示行
        if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) 
            ps.add(new Point(X-2, Y-1));
        
        if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X-1, Y-2));
        
        if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X+1, Y-2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0)
            ps.add(new Point(X+2, Y-1));
        
        
        if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) 
            ps.add(new Point(X-2, Y+1));
        
        if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X-1, Y+2));
        
        if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X+1, Y+2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row)
            ps.add(new Point(X+2, Y+1));
        
        return ps;
    &#125;

&#125;
</code></pre>

    </div>
    
    
    
</div>
                        <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2024 Yao Xiong
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yao Xiong
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        


    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>