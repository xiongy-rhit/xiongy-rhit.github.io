
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>JAVA局域网聊天小程序 | Yao Xiong</title>
        <meta name="author" content="Yao Xiong">
        <meta name="description" content="莫听穿林打叶声， 何妨吟啸且徐行">
        <meta name="keywords" content="Yao Xiong Projects">
        <link rel="icon" href="/img/favicon.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:2147483647;justify-content:space-between;background:#fff;transition:all 0.3s ease-out;-webkit-user-select:none;-moz-user-select:none;user-select:none"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="showpage" style="display: -not-none">
                    <div id="menushow">
                        <nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yao Xiong</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;projects</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yao Xiong</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">projects</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div class="article">
    <div>
        <h1>JAVA局域网聊天小程序 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2021/8/23
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/JAVA/" style="color: #00bcd4">
                    JAVA
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/TCP-IP%E5%8D%8F%E8%AE%AE/" style="color: #00bcd4">
                    TCP/IP协议
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h1 id="（局域网聊天）TCP-IP协议的局域网Socket通信"><a href="#（局域网聊天）TCP-IP协议的局域网Socket通信" class="headerlink" title="（局域网聊天）TCP/IP协议的局域网Socket通信"></a>（局域网聊天）TCP/IP协议的局域网Socket通信</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>马上开学了，闲着没事做，决定重新温习JAVA功课，于是想起了曾经见过的一个项目：基于JAVA语言的局域网通信，可以参考QQ，如下</p>
<span id="more"></span>

<p><strong>一级菜单</strong></p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823171022391.png" alt="image-20210823171022391"></p>
<p><strong>二级菜单</strong></p>
<img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823170806043.png" alt="image-20210823170806043" style="zoom: 80%;">



<p>由于本身水平以及开发工具的限制，只能以简单的控制台来模拟程序，但是<strong>麻雀虽小五脏俱全</strong>。</p>
<p>和上面表现的一样，控制台的程序同样拥有一级菜单（登录之后的选项）和二级菜单（聊天界面）</p>
<p>考虑到开发的时间，本程序登录不需要用户名与密码，开启程序后即可连接服务器；用户聊天时根据IP与电脑名来查找聊天对象。</p>
<p><strong>完成此项目需要对多线程有所了解，Socket的网络知识，对象流的IO，序列化知识的初步了解，JAVA基础知识</strong></p>
<h2 id="步骤讲解"><a href="#步骤讲解" class="headerlink" title="步骤讲解"></a>步骤讲解</h2><p>写程序前要先构思画图确认方案之后再进行编码，所以我先把后期的画面使用画图软件确认下来。</p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p><strong>一级菜单</strong>如下：</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823172114325.png" alt="image-20210823172114325"></p>
<p><strong>二级菜单</strong>：</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823172204669.png" alt="image-20210823172204669"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>局域网通信是典型的Client - Server情形, 我们可以有多个客户端连接同一个服务器，所以服务器端始终保持着多个Socket线程， 而Client也能够拥有多个线程：一个用于聊天，一个用于传输文件(由于最近时间有限，尚未增添此功能，不过和上面服务器操作有异曲同工之妙，之后讲解可能有讲到，但程序中并未添加此功能)。</p>
<p>我们的客户端接收信息是一个<strong>动态</strong>的过程，我们可以在聊天面板打开时接收信息，也可以在刚登陆时接收信息，因此这也需要线程的知识；</p>
<p><strong>说了这么多，还是直接画张图明白</strong>：</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/20210823_215520815_iOS-1629765663285.png" alt="20210823_215520815_iOS"></p>
<p>T代表线程，Socket代表传输信息的通道，当我们想要把一段数据发给其他人时，我们其实是先把数据发给服务器，以服务器为中转再将内容发给接收者（看上面的信息数据传输箭头）</p>
<h3 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h3><p>看着上面的图我们可以想到之后可能要创建的class类对象</p>
<p><strong>客户端</strong></p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823212629703.png" alt="image-20210823212629703"></p>
<p><strong>服务端</strong></p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823214129039.png" alt="image-20210823214129039"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>确定完之前的一些东西之后，要开始编码</p>
<p>我将程序分为<strong>客户端</strong>与<strong>服务端</strong>两部分</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="User"><a href="#User" class="headerlink" title="User"></a>User</h4><p>当用户打开程序时，程序会自动创建一个User类，此类储存了用户的IP地址和用户电脑的Local Host Name, 这样会方便之后使用。</p>
<pre><code class="java">package com.peter.Modle;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;

public class User &#123;
    private String UID = &quot;127.0.0.1&quot;;
    private String Uname=null;
    
    public User()&#123;
/*
 * 考虑到我的电脑安装了虚拟机，需要检查具体的IP，所以下面的程序用于扫描本机所有网络端口，根据需要选择相应的ip
 * */
        try &#123;
            Uname = InetAddress.getLocalHost().getHostName(); //获取主机名
        &#125; catch (UnknownHostException e1) &#123;
            // TODO Auto-generated catch block
            e1.printStackTrace();
        &#125;
        Enumeration&lt;NetworkInterface&gt; i =null;
        try &#123;
            i = NetworkInterface.getNetworkInterfaces();
        &#125; catch (SocketException e) &#123;
            e.printStackTrace();
        &#125;
          ArrayList&lt;String&gt; IPlist = new ArrayList&lt;&gt;();  
          while(i.hasMoreElements())
            &#123;
                NetworkInterface n = i.nextElement();
                Enumeration&lt;InetAddress&gt; ea = n.getInetAddresses();
                
                while(ea.hasMoreElements())
                &#123;    
                    InetAddress a = ea.nextElement();
                    if(a.getHostAddress().toCharArray()[3] ==&#39;.&#39;) &#123;
                        IPlist.add(a.getHostAddress());
                    &#125;
                &#125;
            &#125;
//选取对应的IP(根据自己的要求)
          for(String ip:IPlist) &#123;
              if(ip.indexOf(&quot;137.&quot;)!=-1) &#123;
                  UID = ip;
                  break;
              &#125;
              if(ip.indexOf(&quot;192.&quot;)!=-1) &#123;
                  UID = ip;
              &#125;
          &#125;
    &#125;
    
    //获取ID
    public String getUID() &#123;
        return UID;
    &#125;
    
    //获取主机名
    public String getUname() &#123;
        return Uname;
    &#125;
&#125;
</code></pre>
<h4 id="MessageType"><a href="#MessageType" class="headerlink" title="MessageType"></a>MessageType</h4><p>这是一个接口，接口中的变量都是public static final, 所以可以用来储存一些数据，比如每个数字都有自己的含义。</p>
<pre><code class="java">package com.peter.Modle;
//方便判断
public interface MessageType &#123;
    int allUsers = 0;
    int chat = 1;
    int sendFile = 2;
    int getFile = 3;
    int connect = 4;
    int exit = 9;
&#125;
</code></pre>
<h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>Message是用于客户端向服务器传递信息的载体，里面包括了获取在线用户的容器[ArrayList], 告诉计算机我们要做什么的MessageType(MT), 有Sender和Receiver，还有最重要的Words，这些信息都承载在一个Message对象中，最后要通过Socket的outputStream写给服务器；为保证Message类能够在服务器中正常被读取，我们采用序列化操作，继承Serializable接口，储存了SerialVersionUID.</p>
<pre><code class="java">package com.peter.Modle;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;

public class Message implements Serializable&#123;
    private static final long serialVersionUID = 1L;
    
    private String words=null;
    private int MT = 9;
    private String sender=null;
    private String receiver=null;
    private ArrayList&lt;String&gt; users =null;
    
    
    public ArrayList&lt;String&gt; getUsers() &#123;
        return users;
    &#125;
    public void setUsers(ArrayList&lt;String&gt; users) &#123;
        this.users = users;
    &#125;
    public String getSender() &#123;
        return sender;
    &#125;
    public void setSender(String sender) &#123;
        this.sender = sender;
    &#125;
    public String getReceiver() &#123;
        return receiver;
    &#125;
    public void setReceiver(String receiver) &#123;
        this.receiver = receiver;
    &#125;
    public String getWords() &#123;
        return words;
    &#125;
    public void setWords(String words) &#123;
        this.words = words;
    &#125;
    public int getMT() &#123;
        return MT;
    &#125;
    public void setMT(int mT) &#123;
        MT = mT;
    &#125;
    
&#125;
</code></pre>
<h4 id="UserThread"><a href="#UserThread" class="headerlink" title="UserThread"></a>UserThread</h4><p>用户的线程，每个客户端的开启可以看作是一个进程，main函数是主进程，我们为了让用户开启程序就能接收到消息，任何时候都能接收到消息😉，于是启用多线程服务，UserThread就是一个线程</p>
<pre><code class="java">package com.peter.Modle;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Map;
import java.util.Set;


//用户线程类，用于接收服务器发送过来的信息
public class UserThread extends Thread&#123;//此线程继承Thread类
    private Socket UserSocket=null;
    private static ArrayList&lt;String&gt; allUsers=null;
    private static ArrayList&lt;String&gt; ChatContent=new ArrayList&lt;&gt;();
//allUsers 和 ChatContent都使用静态变量的原因是：一旦程序开启，他们就可以一直全局访问    
    public UserThread(Socket us) &#123;
        UserSocket = us;
    &#125;
    
    public Socket getUserSocket() &#123;
        return UserSocket;
    &#125;

    public ArrayList&lt;String&gt; getAllUsers() &#123;
        return allUsers;
    &#125;
    
    public ArrayList&lt;String&gt; getContent()&#123;
        return ChatContent;
    &#125;

//重写Run方法
    @Override
    public void run() &#123;
        //使用循环表示一直在运行，不然这个线程执行一遍后就不执行了
        while(true) &#123;
            ObjectInputStream ois;
            try &#123;
                ois = new ObjectInputStream(UserSocket.getInputStream());
                Message mms = (Message)ois.readObject(); //如果服务器没有发送数据，通道会一直阻塞
                //服务器向用户发送的message是allUser
                if(mms.getMT() == MessageType.allUsers) &#123;
                    UserThread.allUsers = mms.getUsers();
                //发送但是信息                    
                &#125;else if(mms.getMT() == MessageType.chat) &#123;
                    ChatContent.add(mms.getSender()+&quot; 对 &quot;+mms.getReceiver()+&quot; 说:\n &quot;+mms.getWords());
                    System.out.println(&quot;过往信息：&quot;);
                    //显示过往消息信息
                    for(String chatContent:ChatContent)
                        System.out.println(chatContent);
                &#125;
                
            &#125; catch (IOException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125; catch (ClassNotFoundException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125;
        
            
            
        &#125;
    &#125;
    
&#125;
</code></pre>
<h4 id="UserConnectService"><a href="#UserConnectService" class="headerlink" title="UserConnectService"></a>UserConnectService</h4><p>开始用户需要将电脑连接到服务器，以此来构建Socket通信,并开启线程</p>
<pre><code class="java">    public static void ConnectToServer() &#123;
        try &#123;
            //137.112.237.25是服务器所在IP，10086是监听端口
            UserSocket = new Socket(&quot;137.112.237.25&quot;, 10086);
            //创建Message对象，在这个载体中写入我们的信息
            Message message = new Message();
            message.setMT(MessageType.connect);
            message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
            
            //输出流将message对象写给服务器端
            ObjectOutputStream output = new ObjectOutputStream(UserSocket.getOutputStream());
            output.writeObject(message);
            
            //我们把这个建立连接的Socket放入到线程，持续监听服务器发送的信息
            userThread = new UserThread(UserSocket);
            userThread.start();//别忘了开启线程
            
            
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;
</code></pre>
<p>获取在线用户的IP和名称</p>
<pre><code class="java">//获取在线用户IP
    public static ArrayList&lt;String&gt; GetAllIP() &#123;

        //建立Message对象
        Message message = new Message();
        message.setMT(MessageType.allUsers);
        //这个是为了方便服务器判断IP，这样就不会发送本机的IP了
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        try &#123;
            //发送
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            //等待接收IP，网络有延迟
            if(userThread.getAllUsers() == null) &#123;
                Thread.sleep(5000);
            &#125;
            //等一会之后还没有就返回空
            if(userThread.getAllUsers() == null)
                return null;
            return userThread.getAllUsers();
            
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return null;
    &#125;
</code></pre>
<p>向指定用户传输信息</p>
<p>这里我们要输入对应的IP地址和信息，由于是Service，我做成了一个静态方法，方便之后在Menus（View）中调用。</p>
<pre><code class="java">  //向指定用户传输信息
    public static String SendChatContent(String receiver, String words)&#123;
        //同上
        Message message =  new Message();
        message.setMT(MessageType.chat);
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        message.setReceiver(receiver);
        //我们要加入发送的时间
        Date date = new Date();
        message.setWords(words+&quot;\t&quot;+date.toString());
        
        try &#123;
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            
            String words1 = message.getSender()+&quot; 对 &quot;+message.getReceiver()+&quot; 说:\n &quot;+message.getWords();
            
            //userThread.getContent().add(words1);
            //返回发送的内容，到时候在View控制台中打印出来
            return words1;

        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        return &quot;连接超时，信息未发送&quot;;
    &#125; 
</code></pre>
<p>退出服务</p>
<p>退出之前我们要告诉服务器我们要退出了，让服务器在服务器中删除我们的线程，关闭我们的Socket通道，我们然后直接退出。</p>
<pre><code class="java">    //退出服务
    public static void Exit() &#123;
        //向服务器发送退出指令
        Message message = new Message();
        message.setMT(MessageType.exit);
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        
        try &#123;
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            System.exit(0);//系统退出
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        
    &#125;
</code></pre>
<p>UserConnectService 全部代码，都是public static method</p>
<pre><code class="java">package com.peter.Service;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Set;

import com.peter.Modle.Message;
import com.peter.Modle.MessageType;
import com.peter.Modle.User;
import com.peter.Modle.UserThread;

public class UserConnectService &#123;
    private static Socket UserSocket = null;
    private static User user= new User();
    private static UserThread userThread;
    public static void ConnectToServer() &#123;
        try &#123;
            UserSocket = new Socket(&quot;137.112.237.25&quot;, 10086);
            Message message = new Message();
            message.setMT(MessageType.connect);
            message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
            
            
            ObjectOutputStream output = new ObjectOutputStream(UserSocket.getOutputStream());
            output.writeObject(message);
            
            userThread = new UserThread(UserSocket);
            userThread.start();
            
            
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;
    
    //获取在线用户IP
    public static ArrayList&lt;String&gt; GetAllIP() &#123;

        
        Message message = new Message();
        message.setMT(MessageType.allUsers);
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        try &#123;
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            //等待发送IP
            if(userThread.getAllUsers() == null) &#123;
                Thread.sleep(5000);
            &#125;
            if(userThread.getAllUsers() == null)
                return null;
            return userThread.getAllUsers();
            
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (InterruptedException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return null;
    &#125;
    
    //向指定用户传输信息
    public static String SendChatContent(String receiver, String words)&#123;
        Message message =  new Message();
        message.setMT(MessageType.chat);
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        message.setReceiver(receiver);
        Date date = new Date();
        message.setWords(words+&quot;\t&quot;+date.toString());
        
        try &#123;
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            String words1 = message.getSender()+&quot; 对 &quot;+message.getReceiver()+&quot; 说:\n &quot;+message.getWords();
            userThread.getContent().add(words1);
            return words1;

        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        return &quot;连接超时，信息未发送&quot;;
    &#125; 
    
    //退出服务
    public static void Exit() &#123;
        //向服务器发送退出指令
        Message message = new Message();
        message.setMT(MessageType.exit);
        message.setSender(user.getUname()+&quot;:&quot;+user.getUID());
        
        try &#123;
            ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream());
            output.writeObject(message);
            System.exit(0);//系统退出
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        
        
    &#125;
    
&#125;
</code></pre>
<h4 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h4><p>menus是菜单，一级菜单，二级菜单的显示都在这里，可以说是显示层</p>
<pre><code class="java">package com.peter.View;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import com.peter.Service.UserConnectService;

import java.util.Scanner;
import java.util.Set;

public class Menus &#123;
    //到时候测试类调用Start方法就好
    public static void Start() &#123;
        FirstMenu();
    &#125;
    //显示一级菜单
    private static void FirstMenu() &#123;
        boolean open =true;
        Scanner input =null;
        UserConnectService.ConnectToServer();
        //一级菜单使用循环，若退出则循环终止
        while(open) &#123;
            System.out.println(&quot;\n\n====聊天一级菜单====&quot;);
            System.out.println(&quot;\t1. 聊天面版&quot;);
            System.out.println(&quot;\t4.退出&quot;);
            System.out.print(&quot;   选择：&quot;);
            input = new Scanner(System.in);
            switch (input.next()) &#123;
            case &quot;1&quot;:
                Chatting(input);
                break;
                
            case &quot;4&quot;:
                UserConnectService.Exit();
                open = false;
                break;
            default:
                break;
            &#125;
        &#125;
        
        input.close();
    

        
        
    &#125;
    
    //二级菜单
    private static void Chatting(Scanner input) &#123;
        boolean open = true;
        //同样使用循环控制，方便持续交流
        while(open) &#123;
            
            System.out.println(&quot;\n\n====聊天二级菜单(聊天面板)====&quot;);
            System.out.println(&quot;在线联系人如下：&quot;);
            //内容的获取都是根据之前的UserConnectService工具类来获得
            ArrayList&lt;String&gt; tmpSet = UserConnectService.GetAllIP();
            
            //若无在线用户，直接不让用户进行交流
            if(tmpSet == null) &#123;
                System.out.println(&quot;暂时无上线用户&quot;);
                open = false;
            &#125;else &#123;
                //有则进行下一步，打印在线用户
                for(String tmp: tmpSet) &#123;
                    System.out.println(tmp);
                &#125;
                
                System.out.println(&quot;\n\t1.选择人聊天&quot;);
                System.out.println(&quot;\t2.退出&quot;);
                System.out.print(&quot;你的选择：&quot;);
                String choice = input.next();
                input.reset();//为避免scanner的问题，使用reset重启方法
                
                switch (choice) &#123;
                case &quot;1&quot;:
                    
                    System.out.print(&quot;聊天对象的IP：&quot;);
                    String receiver = input.next();
                    input.reset();
                    System.out.print(&quot;想说的话：&quot;);
                    input.nextLine();//吃掉一个\n
                    String words = input.nextLine();
                    input.reset();
                    //打印刚才发送的信息
                    System.out.println(UserConnectService.SendChatContent(receiver, words));
                    break;
                    
                case &quot;2&quot;:
                    open = false;
                    break;
                default:
                    break;
                &#125;
            &#125;
        &#125;
        
    &#125;
&#125;
</code></pre>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h4><p>服务器终端类，用于控制服务器的开启，需要开启服务器端先实例化一个Terminal对象，传入服务器监听端口</p>
<p>服务器端是一直进行while循环，用于持续监听是否有新的连接</p>
<pre><code class="java">package com.peter.Modle;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;
/*
 * 服务器类
 * 
 * */
public class Terminal &#123;
    private ServerSocket listener; //用于监听端口
    public Terminal(int port)&#123;
        try &#123;
            System.out.println(&quot;服务器Start&quot;);
            listener = new ServerSocket(port); //确认端口
            Socket accept; //连接的Socket通道
            while(true) &#123;
                accept = listener.accept(); //建立通道连接
                //获取连接后将此socket通道放入线程和线程池中进行管理
                ObjectInputStream input = new ObjectInputStream(accept.getInputStream());
                Message message = (Message)input.readObject();//开始时判断是否是在登录
                if(message.getMT() == MessageType.connect) &#123;
                    ServerThread thread = new ServerThread(accept, message.getSender());
                    System.out.println(message.getSender()+&quot;上线了&quot;);
                    thread.start();//开启线程
                    ManageClientThreads.addThread(message.getSender(), thread);//加入到线程池中
                &#125;
                
                
            &#125;
             
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
    &#125;
    
&#125;
</code></pre>
<h4 id="ServerThread"><a href="#ServerThread" class="headerlink" title="ServerThread"></a>ServerThread</h4><p>服务器的线程类，和客户端的线程类一样，</p>
<pre><code class="java">package com.peter.Modle;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

import com.peter.Service.ShowOnline;

public class ServerThread extends Thread&#123;
    private Socket socket;
    private String UID;
    //在服务器端管理的线程，每个线程有对应的UID
    public ServerThread(Socket s, String id) &#123;
        socket = s;
        UID =id;
    &#125;
    
    public String getUID() &#123;
        return UID;
    &#125;
    
    public Socket getSocket() &#123;
        return socket;
    &#125;


    @Override
    public void run() &#123;
        //使用循环，使此socket线程一直保持监听状态，若没有内容发过来，则阻塞在此
        while(true) &#123;
            Message message;
            try &#123;
                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());
                message = (Message)input.readObject();
                
                //判断发送过来的内容
                if(message.getMT()==MessageType.allUsers) &#123; //请求所有在线用户
                    System.out.println(UID+&quot;向服务器请求在线用户&quot;);
                    message.setUsers(ShowOnline.getAllIP(UID));
                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
                    output.writeObject(message);
                    
                &#125;
                
                else if(message.getMT() == MessageType.chat) &#123;//A用户请求与B用户通信
                    String receiver = message.getReceiver();
                    ServerThread receiverThread = ManageClientThreads.getThread(receiver);//我们先根据B用户的名称找到B用户的线程
                    System.out.println(message.getSender()+&quot;向&quot;+receiver+&quot;发送:\n&quot;+message.getWords());
                    //判断一下此用户是否存在
                    if(receiverThread!=null) &#123;
                        
                        ObjectOutputStream output = new ObjectOutputStream(receiverThread.getSocket().getOutputStream());
                        output.writeObject(message);
                    &#125;else &#123;
                        //若不存在，这个怎么处理还没写
                    &#125;
                    
                &#125;
                else if(message.getMT()==MessageType.exit) &#123; //请求退出
                    //退出时从线程池中删除，将socket通道关闭
                    ManageClientThreads.delThread(UID);
                    socket.close();
                    System.out.println(message.getSender()+&quot;退出&quot;);
                    break; //终止循环
                &#125;
                
            &#125; catch (IOException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125; catch (ClassNotFoundException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125;
            
        &#125;
    &#125;

&#125;
</code></pre>
<h4 id="ManageClientThreads"><a href="#ManageClientThreads" class="headerlink" title="ManageClientThreads"></a>ManageClientThreads</h4><p>线程池，管理线程，对线程进行增删查</p>
<p>每个线程被储存在HashMap中，以用户ID为key, Thread为value，方便查询</p>
<pre><code class="java">package com.peter.Modle;

import java.util.HashMap;
//管理线程的类，线程池
public class ManageClientThreads &#123;
    public static HashMap&lt;String, ServerThread&gt; threads = new HashMap&lt;&gt;();
    //UID为线程Key，socket为value
    public static void addThread(String UID, ServerThread s ) &#123;
        threads.put(UID, s);
        
    &#125;
    //删除线程
    public static void delThread(String UID) &#123;
        threads.remove(UID);
    &#125;
    //获取对应线程
    public static ServerThread getThread(String UID) &#123;
        for(String id:threads.keySet()) &#123;
            if(KMP(id,UID,MatchMap(UID))!=-1) &#123;
                return threads.get(id);
            &#125;
                
        &#125;
        return null;
    &#125;
    
    //由于用户存储的是用户名+IP，而当用户要与另外一个用户通信时输入的是IP地址，所以我们这里需要做字符串匹配以找到符合的字符串
    //使用KMP算法做字符串匹配
    private static int[] MatchMap(String dest) &#123;
        int[] map = new int[dest.length()];
        map[0]=0;
        for(int i=0,j=0;i&lt;dest.length();i++) &#123;
            while(j&gt;0&amp;&amp;dest.charAt(i)!=dest.charAt(j))
                j = map[j-1];
            if(dest.charAt(i)==dest.charAt(j))
                j++;
            map[i] = j;
            
        &#125;
        return map;
    &#125;
    
    private static int KMP(String st1, String st2, int[] map) &#123;
        for(int i=0, j=0;i&lt;st1.length();i++) &#123;
            while(j&gt;0&amp;&amp;st1.charAt(i)!=st2.charAt(j))
                j = map[j-1];
            if(st1.charAt(i)==st2.charAt(j))
                j++;
            if(j&gt;=st2.length())
                return i-j+1;
        &#125;
        return -1;
    &#125;
    
&#125;
</code></pre>
<h4 id="ShowOnline"><a href="#ShowOnline" class="headerlink" title="ShowOnline"></a>ShowOnline</h4><p>显示所有在线用户，其实就是遍历线程池，将每个Key（除查询本机的用户以外）返回给此查询用户</p>
<pre><code class="java">package com.peter.Service;

import java.util.ArrayList;
import java.util.Set;

import com.peter.Modle.ManageClientThreads;

public class ShowOnline &#123;
    //根据线程池中的所有线程，获取所有UID，即在线的用户
    public static ArrayList&lt;String&gt; getAllIP(String UID)&#123;
        ArrayList&lt;String&gt; ips = new ArrayList&lt;&gt;(ManageClientThreads.threads.keySet());
        ips.remove(UID); //在线用户查看时，排除用户自己
        return ips;
    &#125;
&#125;
</code></pre>
<h4 id="MessageType和Message"><a href="#MessageType和Message" class="headerlink" title="MessageType和Message"></a>MessageType和Message</h4><p>MessageType和Message与客户端是一样的，MessageType就好像是一个密码本，使客户端与服务器了解彼此要做的事。Message必须要进行序列化操作，同时保证客户端与服务器的Message对象一样，这样在从客户端传输Message对象到服务器端时就不会报错，（Class Not Found Exception）</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>本程序有许多可拓展的地方，如让用户之间可以传输文件，当用户输入错的IP时，服务器会提示用户输入的信息有错误等等。时间有限，部分功能尚未完成，请谅解。</p>
<h2 id="展示效果"><a href="#展示效果" class="headerlink" title="展示效果"></a>展示效果</h2><p>最后只需要将Menus和Terminal分别放到2个测试类当中就好，这样就能开始进行服务器，2台客户端间的通信了。下面是成果展示：</p>
<p><strong>服务器端</strong></p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823221202447.png" alt="image-20210823221202447"></p>
<p><strong>客户端</strong></p>
<p>一级菜单</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823221307532.png" alt="image-20210823221307532"></p>
<p>二级菜单</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823221327569.png" alt="image-20210823221327569"></p>
<p>二级菜单收到另一个用户发来的信息(由于是控制台表示信息收发与选项选择，信息显示会有所冲突)</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823221648652.png" alt="image-20210823221648652"></p>
<p>安全退出</p>
<p><img src="/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/image-20210823221706176.png" alt="image-20210823221706176"></p>
<h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><p>这个程序说实话做的有点草率，很多地方其实有Bug，许多边际情况确实没有考虑，但这依然不失是一个好的练习题，用来练习多线程管理，Socket通信等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>HSP老师的视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1j54y1b7qv?p=30">https://www.bilibili.com/video/BV1j54y1b7qv?p=30</a></p>

    </div>
    
    
    
</div>
                        <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2024 Yao Xiong
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yao Xiong
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        


    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>