
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>LeetCode练习 | Yao Xiong</title>
        <meta name="author" content="Yao Xiong">
        <meta name="description" content="莫听穿林打叶声， 何妨吟啸且徐行">
        <meta name="keywords" content="Yao Xiong Projects">
        <link rel="icon" href="/img/favicon.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:2147483647;justify-content:space-between;background:#fff;transition:all 0.3s ease-out;-webkit-user-select:none;-moz-user-select:none;user-select:none"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="showpage" style="display: -not-none">
                    <div id="menushow">
                        <nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yao Xiong</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;projects</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yao Xiong</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">projects</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div class="article">
    <div>
        <h1>LeetCode练习 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2021/10/18
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="color: #ffa2c4">
                    数据结构与算法
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <h1 id="123-股票问题"><a href="#123-股票问题" class="headerlink" title="123 股票问题"></a>123 股票问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给一个数组，它的第i个元素是一支给定的股票在第i天的价格。</p>
<p>设计一个算法来计算可获得的最大利润，你最多可以完成<strong>两笔</strong>交易 （可以只完成1笔）</p>
<p><strong>Attention</strong>: 你不能同时参与多笔交易</p>
<p><strong>例子</strong>：</p>
<p>输入  [3，3，0，0，5，3，1，4]； </p>
<p>结果  8; </p>
<p>解释  第4天买入，第6天卖出， 第7天买入，第8天卖出， 总计利润 6</p>
<p>输入  [1，2，3，4，5]； </p>
<p>结果  4； </p>
<p>解释  第1天买入，第5天卖出， 总利润 4</p>
<span id="more"></span>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到可以进行2笔交易，最后的数组应该是一个二维数组（用于记录每个点的最大收益），这需要用到动态规划算法;</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210602123645356.png" alt="image-20210602123645356"></p>
<p>二维数组每次比较得出此时的max profit然后存入数组中， </p>
<p>max profit有2种选择</p>
<blockquote>
<ol>
<li>profits[i][j-1]   //前一个的点的max profit</li>
<li>price[j] - price[n] + profits[i-1][n]  // n = 0..j-1   </li>
</ol>
<p>在选项2中我们要遍历price数组从而得出max profit， 这个过程可以进行优化</p>
</blockquote>
<p>（针对选项2）优化如下</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210602124548017.png" alt="image-20210602124548017"></p>
<p>我们发现从前一种情况到后一种情况求出max profit时有重复的地方</p>
<p>其实我们可以用一个变量来表示重复部分，然后每次更新时比较一下，若利润更大，则更新</p>
<pre><code class="java">int tempProfit = -price[0]+profits[i-1][0];
for(int j=1;j&lt;profits[0].length;j++) &#123;
    if(profits[i-1][j-1]-price[j-1] &gt; tempProfit) &#123;
        tempProfit = profits[i-1][j-1]-price[j-1];
    &#125;
    profits[i][j] = Math.max(profits[i][j-1], price[j]+tempProfit);
&#125;
</code></pre>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">
public class StockProfitMax &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[] price = &#123;3,3,0,5,3,1,4&#125;;
        System.out.println(MaxProfit(price,2));
    &#125;
    
    public static int MaxProfit(int[] price, int times) &#123;
        int[][] profits = new int[times+1][price.length];
        
        for(int i=1;i&lt;profits.length;i++) &#123;
            int tempProfit = -price[0]+profits[i-1][0];
            for(int j=1;j&lt;profits[0].length;j++) &#123;
                if(profits[i-1][j-1]-price[j-1] &gt; tempProfit) &#123;
                    tempProfit = profits[i-1][j-1]-price[j-1];
                &#125;
                profits[i][j] = Math.max(profits[i][j-1], price[j]+tempProfit);
            &#125;
        &#125;
        
        return profits[profits.length-1][profits[0].length-1];
    &#125;

&#125;
</code></pre>
<h1 id="剑指offer-3-1-数组中重复的数-（改变数组结构）"><a href="#剑指offer-3-1-数组中重复的数-（改变数组结构）" class="headerlink" title="剑指offer 3.1 数组中重复的数 （改变数组结构）"></a>剑指offer 3.1 数组中重复的数 （改变数组结构）</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为n的数组里所有数字都在0~n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复，也不知道重复几次。找出数组中任意一个重复的数字。</p>
<p>输入：[2,3,1,0,2,5,3]</p>
<p>结果：2或3</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>由于所有成员数字都在0~n-1之间，我们可以根据数字找到对应的下标，让每个数字于其下标一致，若在移位过程中发现位置被占，则代表此数字重复。</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210710105407600.png" alt="image-20210710105407600"></p>
<p>这种解法时间复杂度为O(n)，空间复杂度为O(1)</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int SortArrMethod(int[] arr) &#123;
        for(int i=0;i&lt;arr.length;i++) &#123;
            int tmp =i;
            int tmp2;
            while(arr[tmp]!=tmp) &#123;
                tmp2 = arr[arr[tmp]];
                if(tmp2 == arr[tmp])
                    return tmp2;
                arr[arr[tmp]] = arr[tmp];
                tmp = tmp2;
            &#125;
        &#125;
        return -1;
    &#125;
</code></pre>
<p>虽然里面还有一个for循环，但是每个数字最多2次找到自己位置，所以时间复杂度还是O(n);</p>
<h1 id="剑指offer-3-2-数组中重复的数-（数组结构不变）"><a href="#剑指offer-3-2-数组中重复的数-（数组结构不变）" class="headerlink" title="剑指offer 3.2 数组中重复的数 （数组结构不变）"></a>剑指offer 3.2 数组中重复的数 （数组结构不变）</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>不修改数组找出重复数字</p>
<p>输入：[2,3,5,4,3,2,6,7]</p>
<p>结果：2或3</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>不改变原数组结构，需要重新再建一个数组，以哈希表的形式修改存储，由于数组中数字在0~n-1范围内，每增添一个，临时数组下标对应的值就+1；最后判断哪个下标的值&gt;=2，返回此数字；</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210710103157501.png" alt="image-20210710103157501"></p>
<p>这种方法的时间复杂度为O(n),空间复杂度为O(n)</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int hashMethod(int arr[]) &#123;
        int[] tempArr = new int[arr.length];
        for(int i=0;i&lt;arr.length;i++) &#123;
            tempArr[arr[i]] +=1;
        &#125;
        for(int j=0;j&lt;tempArr.length;j++) &#123;
            if(tempArr[j] &gt;= 2)
                return j;
        &#125;
        return -1;
    &#125;
</code></pre>
<h1 id="剑指offer-4-在二维数组中查找"><a href="#剑指offer-4-在二维数组中查找" class="headerlink" title="剑指offer 4 在二维数组中查找"></a>剑指offer 4 在二维数组中查找</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>在二维数组中，每一行都按照从左到右递增，每一列都按照从上到下递增，输入一个二维数组和一个值，找出数组是否含有这个值</p>
<p>输入： 7</p>
<p>[1    2    8    9]</p>
<p>[2    4    9    12]</p>
<p>[4    7    10    13]</p>
<p>[6    8    11    15]</p>
<p>结果：true</p>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>可以根据右上角数字的大小来压缩搜索范围，比如说第一行从右往左读取，8和9大于7，column-2, 2小于7，row+1, 根据第2行第2列，4小于7，再向下找，得出7，返回true</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210710121030915.png" alt="image-20210710121030915"></p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>要注意考虑边界，左上角代表最小，右下角代表最大</p>
<pre><code class="java">    public static boolean FindNum(int[][] arr, int num) &#123;
        int row=arr.length;
        int column = arr[0].length;
        if(arr[row-1][column-1] &lt;num)
            return false;
        else if(arr[row-1][column-1] ==num)
            return true;
        if(arr[0][0] &gt;num)
            return false;
        else if(arr[0][0] ==num)
            return true;
        
        
        for(int i=0;i&lt;row;i++) &#123;
            for(int j=column-1;j&gt;=0;j--) &#123;
                if(arr[i][j]&lt;num)
                    row++;
                if(arr[i][j]&gt;num)
                    column--;
                if(arr[i][j]==num)
                    return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<h1 id="剑指offer-5-替换空格"><a href="#剑指offer-5-替换空格" class="headerlink" title="剑指offer 5 替换空格"></a>剑指offer 5 替换空格</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>实现一个函数将空格替换成%20</p>
<p>输入：”We are happy”</p>
<p>结果：“We%20are%20happy”</p>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>这道题适合使用C++来解，先读取原来字符串长度，再用while循环统计空格的个数，newlength = originLength +  BlankNum*2; 使用2个指针，一个P1指向原字符串末尾，还有一个P2指向新的长度的末尾，P1每读取一个字符，P2将此字符串存起来，若遇到空格，则在P2前3个位置存放”%20“，结束条件是P1指向头</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210711225317496.png" alt="image-20210711225317496"></p>
<p>时间复杂度为O(n)</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><p>代码就不写了，java用数组可以实现</p>
<h1 id="剑指offer-6-从尾到头打印链表"><a href="#剑指offer-6-从尾到头打印链表" class="headerlink" title="剑指offer 6 从尾到头打印链表"></a>剑指offer 6 从尾到头打印链表</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，要求从尾到头打印此链表中的值</p>
<p>输入：ListA[a,b,c,d,e,f]</p>
<p>输出：f,e,d,c,b,a</p>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>（在不改变原链表的情况下）用递归可以基本实现实现，递归的本质就是栈。</p>
<p>退出递归的条件就是当读取的指针为空指针时，return</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">package PointOffer;

public class PrintNodeReverse &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        MyLinkedList list = new MyLinkedList();
        list.add(123);
        list.add(456);
        list.add(789);
        list.add(666);
        printNodesReverse(list);
    &#125;
    
    public static void printNodesReverse(MyLinkedList list) &#123;
        if(list == null || list.head == null)
            return;
        else &#123;
            printNodesReverse(list.head);
        &#125;
    &#125;
    
    private static void printNodesReverse(Node head) &#123;
        if(head == null)
            return;
        printNodesReverse(head.next);
        System.out.println(head.num);
    &#125;
    
    public static class MyLinkedList&#123;
        public Node head=null;
        public void add(int num) &#123;
            if(head == null)
                head = new Node(num, null);
            else &#123;
                Node cur = head;
                while(cur.next!=null)
                    cur = cur.next;
                cur.next = new Node(num, null);
            &#125;
        &#125;
    &#125;
    
    private static class Node&#123;
        public int num;
        public Node next;
        Node(int num, Node next)&#123;
            this.num = num;
            this.next = next;
        &#125;
    &#125;

&#125;
</code></pre>
<h1 id="剑指offer-9-用2栈实现队列"><a href="#剑指offer-9-用2栈实现队列" class="headerlink" title="剑指offer 9 用2栈实现队列"></a>剑指offer 9 用2栈实现队列</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>用2个栈实现1个队列，队列需要有2个函数：appendTail和deleteHead（在队列尾部插入，在队列头部删除）</p>
<p>输入队列：[a,b,c,d]</p>
<p>删除队列头：[b,c,d]</p>
<p>插入队列尾：[b,c,d,e]</p>
<h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>2个栈（A和B），</p>
<p>从尾部插入：直接将所有数据压入A栈</p>
<p>从队列中删除头部数据：先检查B是否为空，为空则从A中把A中的数据压入到B中，B再pop出一个数据，不为空则直接在B中pop；</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210712213613345.png" alt="image-20210712213613345"></p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">package PointOffer;

import java.util.Stack;

public class StackAchieveQueue &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        MyQueue&lt;Character&gt; q = new MyQueue&lt;&gt;();
        q.appendTail(&#39;a&#39;);
        q.appendTail(&#39;b&#39;);
        q.appendTail(&#39;c&#39;);
        System.out.println(q.deleteHead());
        System.out.println(q.deleteHead());
        System.out.println(q.deleteHead());
    &#125;
    
    private static class MyQueue&lt;E&gt;&#123;
        private Stack&lt;E&gt; A;
        private Stack&lt;E&gt; B;
        public MyQueue() &#123;
            // TODO Auto-generated constructor stub
            this.A = new Stack&lt;&gt;();
            this.B = new Stack&lt;&gt;();
        &#125;
        
        public void appendTail(E element) &#123;
            A.push(element);
        &#125;
        
        public E deleteHead() &#123;
            if(B.isEmpty()) &#123;
                if(A.isEmpty())
                    return null;
                while(!A.empty()) &#123;
                    B.push(A.pop());
                &#125;
            &#125;
            return B.pop();
        &#125;
        
    &#125;

&#125;
</code></pre>
<h1 id="剑指offer-10-1-斐波那契数列"><a href="#剑指offer-10-1-斐波那契数列" class="headerlink" title="剑指offer 10.1 斐波那契数列"></a>剑指offer 10.1 斐波那契数列</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，输入n，求斐波那契数列的第n项。</p>
<h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>一般情况下大家都会使用递归来解决此问题</p>
<pre><code class="java">    public static int Fibonacci(int n) &#123;
        if(n&lt;=0)
            return 0;
        else if(n==1)
            return 1;
        else &#123;
            return Fibonacci(n-1) + Fibonacci(n-2); 
        &#125;
    &#125;
</code></pre>
<p>递归的实现方法是栈而当栈过多时，栈会溢出，此时程序崩溃；同时，使用递归求解问题有时会重复；</p>
<p>为了避免程序运行慢或者崩溃，求第n个斐波那契数列可以使用循环来完成</p>
<blockquote>
<p>a = 0;</p>
<p>b=1;</p>
<p>for(i=2;i&lt;=n;i++){</p>
<p>​    rst = a+b;</p>
<p>​    a =b;</p>
<p>​    b = rst; //向后移</p>
<p>}</p>
</blockquote>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int Fibonacci2(int n) &#123;
        if(n&lt;=0)
            return 0;
        else if(n==1)
            return 1;
        else &#123;
            int a=0;
            int b=1;
            int rst=2;
            for(int i=2;i&lt;=n;i++) &#123;
                rst = a+b;
                a = b;
                b = rst;
            &#125;
            return rst;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-10-2-青蛙跳台阶问题"><a href="#剑指offer-10-2-青蛙跳台阶问题" class="headerlink" title="剑指offer 10.2 青蛙跳台阶问题"></a>剑指offer 10.2 青蛙跳台阶问题</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙可以跳1个台阶，也可以跳2个台阶，求该青蛙跳n个台阶一共有多少种跳法？</p>
<p>输入：0</p>
<p>输出：0</p>
<p>输入：1</p>
<p>输出：1</p>
<h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>这道题可以看作是斐波那契数列的应用，当有0个台阶时，青蛙有0种跳法；有2个台阶时，青蛙可以选择连续跳1个台阶，也可以选择一下跳2个台阶；</p>
<p>假设青蛙跳n个台阶，结果是f(n)；当n&gt;2时，假设青蛙第一次跳1级台阶，青蛙有f(n-1)种跳法，假设第一次跳2级台阶，青蛙有f(n-2)种跳法，n级台阶有f(n) = f(n-1) + f(n-2)种跳法</p>
<p>这是斐波那契数列</p>
<p>0, 1, 2,  3, 5, 8 </p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int frog(int n) &#123;
        if(n&lt;=0)
            return 0;
        else if(n==1)
            return 1;
        else if(n==2)
            return 2;
        else &#123;
            int a=1;
            int b=2;
            int rst=3;
            for(int i=3;i&lt;=n;i++) &#123;
                rst = a+b;
                a = b;
                b = rst;
            &#125;
            return rst;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-10-3-矩形覆盖问题"><a href="#剑指offer-10-3-矩形覆盖问题" class="headerlink" title="剑指offer 10.3 矩形覆盖问题"></a>剑指offer 10.3 矩形覆盖问题</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>有2*N大小的矩形需要用2*1的矩形覆盖，请问有多少种方法</p>
<h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>这个也是斐波那契数列的应用，当n=8时，覆盖8列有f(8)种方法，图如下：</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210717225016283.png" alt="image-20210717225016283"></p>
<p> 起初为了覆盖整个图，矩形从左覆盖时有2种选择：横着或竖着；若横着则还有f(6)种，若竖着则还有f(7)种，总共方法f(8) = f(7) + f(6)， 这是斐波那契数列</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int rect(int n) &#123;
        if(n&lt;=0)
            return 0;
        else if(n==1)
            return 1;
        else if(n==2)
            return 2;
        else &#123;
            int a=1;
            int b=2;
            int rst=3;
            for(int i=3;i&lt;=n;i++) &#123;
                rst = a+b;
                a = b;
                b = rst;
            &#125;
            return rst;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-11-旋转数组的最小数字"><a href="#剑指offer-11-旋转数组的最小数字" class="headerlink" title="剑指offer 11 旋转数组的最小数字"></a>剑指offer 11 旋转数组的最小数字</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干元素搬到数组的末尾，这个称之为数组的旋转。</p>
<p>输入一个增序数组的旋转，输出旋转数组的最小元素；</p>
<p>输入：[5,1,2,3,4]</p>
<p>输出：1</p>
<h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>一般会想到从头到尾遍历，但时间复杂度为O(n)，效率很低；一维平面（顺序表）可以选择二分查找，log(n)</p>
<p>通过观察我们发现，最小元素的左侧元素大于最小元素，最小元素右侧元素大于最小元素或者没有</p>
<p>步骤：</p>
<ol>
<li>读取数组最右侧和第一个下标</li>
<li>如果最右侧元素小于倒数第二个元素，直接输出</li>
<li>选取中间的元素</li>
<li>若中间的元素小于等于左侧元素同时大于等于右侧元素，输出</li>
<li>没有，则缩小范围</li>
</ol>
<p>考虑特殊情况，数组中有数字重复，如 {1,0,1,1,1}</p>
<p>输入：[5,5,1,1,2,3,3,4]</p>
<p>输出：1</p>
<p>当数组中有重复数字时，我们无法判断pivot属于前递增子数组，还是后递增子数组，因此我们只能从前往后遍历</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><h3 id="输入数组中没有重复的数字"><a href="#输入数组中没有重复的数字" class="headerlink" title="输入数组中没有重复的数字"></a>输入数组中没有重复的数字</h3><pre><code class="java">    public static int getMin(int[] arr) &#123;
        int left=0;
        int right = arr.length-1;    
        if(arr[right] &lt; arr[right-1])
            return arr[right];
        
        while(left &lt; right-1) &#123;
            int pivot = (left +right)/2;
            System.out.println(arr[left]+&quot; &quot;+arr[pivot]+&quot; &quot;+arr[right]);
            if(arr[pivot] &lt; arr[pivot-1] &amp;&amp; arr[pivot] &lt; arr[pivot+1])
                return arr[pivot];
            if(arr[pivot]&lt;arr[pivot+1])
                right = pivot;
            if(arr[pivot]&gt;arr[pivot+1])
                left = pivot;        
        &#125;
        
        return arr[left];
    &#125;
</code></pre>
<h3 id="考虑数组中有重复的数字"><a href="#考虑数组中有重复的数字" class="headerlink" title="考虑数组中有重复的数字"></a>考虑数组中有重复的数字</h3><pre><code class="java">    public static int getMin2(int[] arr) &#123;
        int left=0;
        int right = arr.length-1;    
        if(arr[right] &lt; arr[right-1])
            return arr[right];
        
        while(left &lt; right-1) &#123;
            int pivot = (left +right)/2;
            if(arr[left]==arr[pivot] &amp;&amp; arr[pivot] == arr[right])
                return MinOrder(arr);
            if(arr[pivot] &lt; arr[pivot-1] &amp;&amp; arr[pivot] &lt; arr[pivot+1])
                return arr[pivot];
            if(arr[pivot]&lt;arr[pivot+1])
                right = pivot;
            if(arr[pivot]&gt;arr[pivot+1])
                left = pivot;        
        &#125;
        
        return arr[left];
    &#125;
    
//从前往后遍历
    public static int MinOrder(int[] arr) &#123;
        int small=0;
        for(int i=1;i&lt;arr.length;i++) &#123;
            if(arr[i]&lt;arr[small])
                small =i;
        &#125;
        return arr[small];
    &#125;
</code></pre>
<h1 id="剑指offer-12-矩阵中的路径"><a href="#剑指offer-12-矩阵中的路径" class="headerlink" title="剑指offer 12 矩阵中的路径"></a>剑指offer 12 矩阵中的路径</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>输入一条字符串，判断矩阵是否包含这条字符串路径，路径可以从任意1格开始，可以 (上,下,左,右) 移动，但不能走重复的路。</p>
<p>矩阵：    </p>
<p>​            [a  b  t  g]</p>
<p>​            [c  f  c  s]</p>
<p>​            [j  d  e  h]</p>
<p>输入：bfce</p>
<p>输出：true</p>
<p>输入：bfbd</p>
<p>输出：false</p>
<h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>需要使用回溯算法来考虑每一种情况(因为需要寻找上下左右的坐标)</p>
<ol>
<li><p>开始使用for循环，寻找起始坐标</p>
</li>
<li><p>找到坐标后获取下一批节点</p>
</li>
<li><p>读取节点查看是否包含path的下一个节点，</p>
</li>
<li><p>若遍历完还没有，则返回false；若遍历完还有，则获取此点的下一批节点（依次递归，知道结束）</p>
</li>
</ol>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void TestForCanThrough() &#123;
        char[][] matrix= &#123;
                &#123;&#39;a&#39;,&#39;b&#39;,&#39;t&#39;,&#39;g&#39;&#125;,
                &#123;&#39;c&#39;,&#39;f&#39;,&#39;c&#39;,&#39;s&#39;&#125;,
                &#123;&#39;j&#39;,&#39;d&#39;,&#39;e&#39;,&#39;h&#39;&#125;
        &#125;;
        
        String path = &quot;cfbtcs&quot;;
    
        System.out.println(canThrough(matrix,path));
    &#125;
    
//输入字符串与路径矩阵
    public static boolean canThrough(char[][] matrix, String p) &#123;
        char[] path = p.toCharArray();
        boolean include = false;
        boolean[][] isVisited = new boolean[matrix.length][matrix[0].length];
        LinkedList&lt;Node&lt;Character&gt;&gt; nexts = null;
        //找出起点
        for(int i=0;i&lt;matrix.length;i++) &#123;
            for(int j=0;j&lt;matrix[0].length;j++) &#123;
                if(matrix[i][j] == path[index] &amp;&amp; isVisited[i][j] == false) &#123;
                    isVisited[i][j] = true;
                    include = true;
                    nexts = getNext(i, j, matrix, isVisited);
                    index++;
                    break;
                &#125;
            &#125;
        &#125;
        if(include) &#123;
            return checkPath(nexts,path, index, matrix, isVisited);
        &#125;
            
        else &#123;
            return false;
        &#125;
    &#125;
    
//递归检查输入的路径能否走通
    public static boolean checkPath(LinkedList&lt;Node&lt;Character&gt;&gt; nexts,  char[] path, int index, char[][] matrix,boolean[][] isVisited) &#123;
        if(index == path.length)
            return true;
        for(Node&lt;Character&gt; tmp:nexts) &#123;
            if(tmp.value == path[index]) &#123;
                return checkPath(getNext(tmp.r, tmp.c, matrix, isVisited), path, ++index, matrix, isVisited);
            &#125;    
        &#125;
        return false;
    &#125;
    
//获取上下左右能走的点
    public static LinkedList&lt;Node&lt;Character&gt;&gt; getNext(int row, int column, char[][] matrix, boolean[][] isVisited)&#123;
        LinkedList&lt;Node&lt;Character&gt;&gt; nexts = new LinkedList&lt;&gt;();
        if(row +1 &lt; matrix.length &amp;&amp; !isVisited[row+1][column])
            nexts.add(new Node&lt;&gt;(row+1,column, matrix[row+1][column]));
        if(row -1 &gt;= 0 &amp;&amp; !isVisited[row-1][column])
            nexts.add(new Node&lt;&gt;(row-1,column, matrix[row-1][column]));
        if(column +1 &lt; matrix[0].length &amp;&amp; !isVisited[row][column+1])
            nexts.add(new Node&lt;&gt;(row,column+1, matrix[row][column+1]));
        if(column -1 &gt;= 0 &amp;&amp; !isVisited[row][column-1])
            nexts.add(new Node&lt;&gt;(row,column-1, matrix[row][column-1]));
        
        return nexts;
    &#125;
    
//创建节点
    private static class Node&lt;E&gt;&#123;
        int r;
        int c;
        E value;
        Node(int row, int column, E v)&#123;
            r = row;
            c = column;
            value = v;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-14-剪绳子"><a href="#剑指offer-14-剪绳子" class="headerlink" title="剑指offer 14 剪绳子"></a>剑指offer 14 剪绳子</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>有长度为n的绳子，把绳子剪为m段（n和m都是整数，n&gt;1,m&gt;1）,每段长度记为k[0], k[1], k[2]…k[m], （均为整数）,要求输出最大的每段长的乘积：max( k[0] * k[1] * … * k[m] )</p>
<p>输入：n=8</p>
<p>输出：18</p>
<h2 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h2><p>解法1：动态规划算法</p>
<p>（假设输入n=8）</p>
<p>动态规划算法从上往下分析问题，从下往上解决问题。</p>
<p>先将问题拆解，我们可以先考虑长度为2的绳子，剪成n段，最大长度乘积为多少；</p>
<p>再考虑长度为3的绳子，剪成n段，最大乘积为多少；我们把最大长度乘积存入到数组products中</p>
<p>当绳子长度大于3后，products[i] 可以是 前面任意长度的最大乘积的组合：比如在寻找max products[4]时，我们比较products[1]*products[3] 和 products[2]*products[2]，最后products[4]为最后比较的结果</p>
<pre><code class="java">            max=0;
            for(int j=1;j&lt;=i/2;j++) &#123;
                int tmp = products[j]*products[i-j];
                if(tmp &gt; max)
                    max =tmp;
                products[i] = max;
                
                
            &#125;
</code></pre>
<p>解法2：贪婪算法</p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static int CutMethod1(int n) &#123;
        if(n&lt;2)
            return 0;
        else if(n==2)
            return 1;
        else if(n==3)
            return 2;
        int max;
        int[] products = new int[n+1];
        products[0]=0;
        products[1]=1;
        products[2]=2;
        products[3]=3; //最大乘积可以分为2,2,3段
        for(int i=4;i&lt;=n;i++) &#123; //从4开始到长度为n结束
            max=0;
            for(int j=1;j&lt;=i/2;j++) &#123;//除以二是为了避免重复
                int tmp = products[j]*products[i-j];//核心算法
                if(tmp &gt; max)
                    max =tmp;
                products[i] = max;
                
                
            &#125;
        
        &#125;
        
        return products[n];
    &#125;
</code></pre>
<h1 id="剑指offer-15-二进制中1的个数"><a href="#剑指offer-15-二进制中1的个数" class="headerlink" title="剑指offer 15 二进制中1的个数"></a>剑指offer 15 二进制中1的个数</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数，输出这个整数二进制中1的个数</p>
<p>输入：9 (1001)</p>
<p>输出：2</p>
<h2 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h2><p>一般会想到将二进制数右移进行与运算，若true则cnt++;但是考虑到负数进行右移运算可能会导致死循环，我们不得不采取左移求解。左移是将比较的变量左移，例如：我们假设flag = 1, flag和1001进行与运算，最开始为true, cnt++; 接着我们将flag左移（空位补零），接着按位与，while循环，直到flag全为0; 这种效率略微低下，要进行32次循环。</p>
<img src="/LeetCode%E7%BB%83%E4%B9%A0/LeetCode练习\image-20210722152120451.png" alt="image-20210722152120451" style="zoom: 50%;">





<p>效率更高的一种方法：</p>
<p>当一个二进制数（原数）减1时，其第一个1前面的位都不变，1变为0，1后面的0变为1，此时我们可以对这个二进制的数和原数进行与运算</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210722154057422.png" alt="image-20210722154057422"></p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><p>方法1（C++版本）：</p>
<p>java无法进行按位与</p>
<pre><code class="c++">int numOf1(int n)&#123;
    int cnt=0;
    unsigned int flag=1;
    while(flag)&#123;
        if(n &amp; flag)
            cnt++;
        flag = flag &lt;&lt; 1;
    &#125;
    return cnt;
&#125;
</code></pre>
<p>方法2：</p>
<pre><code class="C++">int numOf1(int n)&#123;
    int cnt=0;
    while(n)&#123;
        cnt++;
        n = (n-1)&amp;n;
    &#125;
    return cnt;
&#125;
</code></pre>
<h1 id="剑指offer-16-数值的整数次方"><a href="#剑指offer-16-数值的整数次方" class="headerlink" title="剑指offer 16 数值的整数次方"></a>剑指offer 16 数值的整数次方</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>实现函数 double power(double base, int exponent), 求base 的exponent次方， exponent为整数</p>
<p>输入：base= 6, exponent=2</p>
<p>输出：36</p>
<h2 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h2><p>exponent指数需要考虑负数的情况，一个数的负数次方为这个数次方的倒数，即1/n</p>
<p>当exponent为0时，所有数为1（0除外）</p>
<p>当exponent为1时，所有数是其本身</p>
<p>计算次方数1：使用循环</p>
<p>计算次方数2：使用公式（时间效率更高为log(N)）</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210722164209057.png" alt="image-20210722164209057"></p>
<h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><p>方法1</p>
<pre><code class="java">    public static double power(double power, int exponent) &#123;
        if(new BigDecimal(power).compareTo(new BigDecimal(0.0))==0 &amp;&amp; exponent ==0) &#123;
            return 0.0;
        &#125;
        if(exponent == 0)
            return 1.0;
        else if(exponent==1)
            return power;
        
        double rst=1;
        for(int i=0;i&lt;Math.abs(exponent);i++)
            rst *= power;
        if(exponent &lt;0)
            return 1.0/rst;
        
        return rst;
    &#125;
</code></pre>
<p>方法2</p>
<pre><code class="java">    public static double power2(double base, int exponent) &#123;
        if(new BigDecimal(base).compareTo(new BigDecimal(0.0))==0 &amp;&amp; exponent ==0) 
            return 0.0;
        
        
        double rst=cal(base, Math.abs(exponent));
        if(exponent&lt;0)
            return 1.0/rst;
        return rst;
    &#125;
    
    public static double cal(double base, int exponent) &#123;
        if(exponent == 0)
            return 1.0;
        else if(exponent==1)
            return base;
        
        double rst= cal(base, exponent&gt;&gt;1); //右移表示除2
        rst *= rst;
        if((exponent &amp; 0x1) ==1) //按位与判断奇偶
            rst *=  base;
        
            
        return rst;
    &#125;
</code></pre>
<h1 id="剑指offer-18-2-删除链表中重复的节点"><a href="#剑指offer-18-2-删除链表中重复的节点" class="headerlink" title="剑指offer 18.2 删除链表中重复的节点"></a>剑指offer 18.2 删除链表中重复的节点</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>在一个排序的链表中剔除重复的节点</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210722175115378.png" alt="image-20210722175115378"></p>
<h2 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h2><p>需要2个指针，preNode还有curPoint;</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210722180428356.png" alt="image-20210722180428356"></p>
<p>本代码仅限删除偶数倍重复的数字</p>
<p>考虑头部重复情况</p>
<p>考虑中间重复情况</p>
<p>考虑尾部重复情况</p>
<h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void delSameNodes(MyLinkedList list) &#123;
        if(list == null || list.head == null)
            return;
        else &#123;
            Node pre = list.head;
            Node cur = pre;
            
            while(cur != null) &#123;
                
                if(cur.num == cur.next.num) &#123;
                    if(cur == list.head) &#123;
                        list.head = cur.next.next;
                        pre = list.head;
                        cur = pre;
                        continue;
                    &#125;
                    pre.next = cur.next.next;
                    
                    cur = pre.next;
                &#125;
                else &#123;
                    cur = cur.next;
                    if(cur.next==null)
                        break;
                &#125;
                    
                
            &#125;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-20-表示数值的字符串"><a href="#剑指offer-20-表示数值的字符串" class="headerlink" title="剑指offer 20 表示数值的字符串"></a>剑指offer 20 表示数值的字符串</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）</p>
<p>输入：+100</p>
<p>输出: true</p>
<p>输入：5e2</p>
<p>输出：true</p>
<p>输入：12e</p>
<p>输出：false</p>
<h2 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h2><p>先要了解整数和小数的表达方式，整数包括正整数和负整数；小数也有正数和负数；小数中10可以有科学计数法（E或e)，科学计数法的指数可为正数与负数</p>
<p>正确的例子：+100, -123, 5e2, 3.14159,  -1E-16, </p>
<p>先找出错误的情况：一般结尾以非数字结尾（直接排除）</p>
<p>我们把整个数分为3段（整数部分，小数部分，E部分），其中E部分后面不能包含小数</p>
<p>将小数部分细分，可分为小数点与整数，E部分同理</p>
<p>最终：有符号整数 . 整数 E 有符号整数</p>
<p>整数有时需要跳过符号，我们可以设计两个函数，前面一个函数用于有符号整数（跳过一个符号），后面一个用于无符号整数。有符号函数仅仅用于跳过一个符号，所以返回时还要利用无符号函数</p>
<h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">package PointOffer;

public class isNumeric &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String s=&quot;+6.66E-6&quot;;
        System.out.println(isNumber(s));
    &#125;
    
    public static boolean isNumber(String number) &#123;
        //判空
        if(number == null)
            return false;
        
        char[] s=number.toCharArray();
        
        //直接判断最后一个是否为常规数字
        if(s[s.length-1]&lt;=48 || s[s.length-1]&gt;=57)
            return false;
        
        //第一轮扫描，判断有符号整数，以小数点结束
        int num = ScanInteger(0,s);
        
        //若返回的恰巧超出范围则读取结束
        if(num&gt;=s.length-1) 
            return true;
        
        //第二轮扫描，扫描小数后，判断是否为无符号整数，以非整数停止
        if(s[num]==&#39;.&#39;) 
            num = ScanUnsighInteger(++num, s);
            
        
        //若返回的恰巧超出范围则读取结束
        if(num&gt;=s.length-1) 
            return true;
        
        //第三轮扫描，扫描E后面的数是否为有符号整数
        if(s[num]==&#39;E&#39; || s[num]==&#39;e&#39;) 
            num = ScanInteger(++num,s);
        
        
        //若扫描完发现还有剩余的没扫完，则表示E后面是小数，false
        if(num&lt;number.length()-1)
            return false;
        else &#123;
            return true;
        &#125;
    &#125;
    
    //判断整数
    public static int ScanInteger(int i, char[] s) &#123;
        if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39;)
            i++;
        return ScanUnsighInteger(i, s);
    &#125;
    
    //无符号整数
    public static int ScanUnsighInteger(int i, char[] s) &#123;
        while(i&lt;s.length &amp;&amp; s[i]&gt;=48 &amp;&amp; s[i]&lt;=57) 
            i++;
        
        return i;
    &#125;
    

&#125;
</code></pre>
<h1 id="剑指offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer 21 调整数组顺序使奇数位于偶数前面"></a>剑指offer 21 调整数组顺序使奇数位于偶数前面</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>输入一批整数数组，调整数组中数字的顺序，使所有奇数位于数组的前半部分，使所有偶数位于数组的后半部分。</p>
<p>输入：【1,4,7,18,14,16,55】</p>
<p>输出：【1,7,55,4,18,14,16】</p>
<h2 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h2><p>解法类似于快速排序</p>
<p>使用两个指针分别指向开头与结尾，左边的指针指向奇数时向右移动，右边指针指向偶数时向左移动，（指针移动条件必须是左指针在右指针左侧），然后两个指针指向的数字交换位置，继续</p>
<p>这里用到一个小知识点：与运算 num&amp;0x1!=0</p>
<p>偶数在二进制中以0结尾，奇数以1结尾，我们可以和0x1做与运算，若结果为1则为奇数，结果为0则为偶数</p>
<p>0 &amp; 1 = 0；1 &amp; 1 = 1</p>
<h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">package PointOffer;

import java.util.Arrays;

public class SwitchOddAndEven &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[] arr= &#123;1,2,3,4,5&#125;;
        SwitchNum(arr);
        System.out.println(Arrays.toString(arr));
    &#125;
    
    public static void SwitchNum(int[] arr) &#123;
        int left=0;
        int right = arr.length-1;
        int tmp=0;
        while(left&lt;right) &#123;
            while((left&lt;right)&amp;&amp;(arr[left]&amp;0x1)!=0)
                left++;
            while((left&lt;right)&amp;&amp;(arr[right]&amp;0x1)==0)
                right--;
            
            if(left&lt;right) &#123;
                tmp = arr[left];
                arr[left] = arr[right];
                arr[right] = tmp;
            &#125;

            
        &#125;
    &#125;

&#125;
</code></pre>
<h1 id="剑指offer-22-链表中倒数第k个节点"><a href="#剑指offer-22-链表中倒数第k个节点" class="headerlink" title="剑指offer 22 链表中倒数第k个节点"></a>剑指offer 22 链表中倒数第k个节点</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个节点，从1开始计数</p>
<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5 , 2</p>
<p>输出：4</p>
<h2 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h2><p>当第一眼看到这道题时，也许会想到递归，就像反向输出链表一样；但是递归不能告诉你倒数第几个，所以还是要用指针。</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807211511487.png" alt="image-20210807211511487"></p>
<p>我们可以选取2个指针：一个在前，一个在后，两个相差k；</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807211559988.png" alt="image-20210807211559988"></p>
<p>使用while循环将指针向后移动</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807211624237.png" alt="image-20210807211624237"></p>
<p>当前面的指针到尾部null时，后面的指针刚好在倒数第k个位置，输出此时的节点的值。</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807211651751.png" alt="image-20210807211651751"></p>
<p>我们其实还要考虑特殊情况，例如：</p>
<ol>
<li>k大于实际链表的长度</li>
<li>链表为空</li>
</ol>
<h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void PrintLastKth(MyLinkedList list, int k) &#123;
        //空链表
        if(list == null)
            return;
        //设置指针
        Node pre = list.head;
        Node aft = pre;
        //设置偏差
        for(int i=0;i&lt;k;i++) &#123;
            pre = pre.next;
            //k大于list长度
            if(pre==null &amp;&amp; i!=k-1)
                return;
        &#125;
        //循环向后移
        while(pre!=null) &#123;
            pre = pre.next;
            aft = aft.next;
        &#125;
        //打印最终结果
        System.out.println(aft.num);
         
    &#125;
</code></pre>
<h1 id="剑指offer-25-合并两个排序链表"><a href="#剑指offer-25-合并两个排序链表" class="headerlink" title="剑指offer 25 合并两个排序链表"></a>剑指offer 25 合并两个排序链表</h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>输入两个链表（两个增序链表），合并两个链表形成第三个（依然是一个增序链表）</p>
<p>输入：1-&gt;3-&gt;5-&gt;10,   2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12</p>
<p>输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10-&gt;11-&gt;12</p>
<h2 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h2><p>和归并排序很相似，我们需要比较两个链表中的数，然后再分配给第三个链表</p>
<p>1-&gt;3-&gt;5-&gt;10</p>
<p>2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12</p>
<p>当2个链表中的一个读取玩，直接把另一个剩余部分接入第三个链表</p>
<p>我们使用递归的方法解决这道题</p>
<p>第一步：1, 比较3-&gt;5-&gt;10 和 2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12</p>
<p>第二步：1-&gt;2, 比较3-&gt;5-&gt;10 和 4-&gt;8-&gt;9-&gt;11-&gt;12</p>
<p>第三步：1-&gt;2-&gt;3 , 比较5-&gt;10 和 4-&gt;8-&gt;9-&gt;11-&gt;12</p>
<p>……</p>
<p>倒数第一步: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10, 比较null 与 11-&gt;12</p>
<p>最后：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10-&gt;11-&gt;12</p>
<h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void MergeList(MyLinkedList list1, MyLinkedList list2) &#123;
        printList(MergeList(list1.head, list2.head));
    &#125;
    
    private static Node MergeList(Node n1, Node n2) &#123;
        if(n1==null)
            return n2;
        if(n2==null)
            return n1;
        Node NewHead = null;
        if(n1.num &lt; n2.num) &#123;
            NewHead = n1; //设置小的
            NewHead.next = MergeList(n1.next, n2);
        &#125;else &#123;
            NewHead = n2;
            NewHead.next = MergeList(n1, n2.next);
        &#125;
        
        return NewHead; //返回头节点，这个头节点是上一个节点的下一个节点
    &#125;
</code></pre>
<h1 id="剑指offer-26-判断树的子结构"><a href="#剑指offer-26-判断树的子结构" class="headerlink" title="剑指offer 26 判断树的子结构"></a>剑指offer 26 判断树的子结构</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构</p>
<p>例子：<img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807233414408.png" alt="image-20210807233414408" style="zoom:80%;"></p>
<h2 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h2><p>这仅仅是一个二叉树，二叉树问题一般使用递归来解决。</p>
<p>要判断A和B的结构，需要使用2个指针，一个给A，另一个给B。</p>
<p>若两指针指向的value相同，开始对比左右节点；反之，A的指针向左移，继续对比（类似于前序遍历）</p>
<p>设置2个函数，第一个用于判断镜像（返回boolean值），另一个用于判断每个节点的值是否相等（考虑到double类型数据）</p>
<p><strong>Attention</strong>：要注意二叉树判断有许多null，空指针的情况</p>
<h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        System.out.println(CheckInclude());
    &#125;
    
    public static boolean CheckInclude() &#123;
        BinaryNode[] heads=CreateBinaryTree();
        
        PrintTree(heads[0]);
        System.out.println();
        PrintTree(heads[1]);
        System.out.println();
        
        return HasSubTree(heads[0], heads[1]);
    &#125;
    
//正式判断A和B树
    private static boolean HasSubTree(BinaryNode head1, BinaryNode head2) &#123;
        boolean rst = false;
        //进行递归的条件，左侧和右侧都不为null
        if(head1!=null &amp;&amp; head2!=null) &#123;
            //若开头就相等，进入向后递归函数
            if(Equal(head1.value, head2.value)) &#123;
                rst = CheckTree(head1, head2);
            &#125;
            
            //若不相等，左递归
            if(!rst)
                rst = HasSubTree(head1.left, head2);
            
            //左边判断完还是不相等，进行右递归
            if(!rst)
                rst = HasSubTree(head1.right, head2);
            
        &#125;

        
        return rst;
    &#125;
    
   //上面判断相等之后进行下一步的判断
    private static boolean CheckTree(BinaryNode head1, BinaryNode head2) &#123;
        //发现B到头，说明这一个部分已经找完
        if(head2 == null)
            return true;
        
        //发现A到头，说明没找到，返回false
        if(head1==null)
            return false;
        
        //判断发现不相等，返回false
        if(!Equal(head1.value, head2.value))
            return false;
        //一般情况下进行左递归和右递归，两者相同才返回true
        return CheckTree(head1.left, head2.left) &amp;&amp; CheckTree(head1.right, head2.right);
    &#125;
    
    //判断double数相等
    private static boolean Equal(double num1, double num2) &#123;
        if(num1-num2 &lt;0.0000001 &amp;&amp; num1-num2 &gt;-0.0000001)
            return true;
        else &#123;
            return false;
        &#125;
    &#125;
</code></pre>
<h1 id="剑指offer-27-二叉树的镜像"><a href="#剑指offer-27-二叉树的镜像" class="headerlink" title="剑指offer 27 二叉树的镜像"></a>剑指offer 27 二叉树的镜像</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树，输出它的镜像，即左右按照中间对调，例子如下 </p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210807234729591.png" alt="image-20210807234729591"></p>
<h2 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h2><p>根据例子可以看出：每次镜像都是根据非叶子节点将其左子节点与右子节点进行对调；</p>
<p>递归操作，递归结束的条件是遍历到叶子节点（left == null &amp;&amp; right == null）</p>
<h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static void MirrorTree() &#123;
        BinaryNode head = CreateBinaryTree2();
        PrintTree(head);
        MirrorTree(head);
        System.out.println();
        PrintTree(head);
    &#125;
    
//镜像翻转
    private static void MirrorTree(BinaryNode head) &#123;
        //开始时此节点为空
        if(head == null)
            return;
        
        //此节点为叶子节点
        if(head.left ==null &amp;&amp; head.right==null)
            return;
        
        //非叶子节点交换其左子节点与右子节点
        BinaryNode tmp = head.left;
        head.left = head.right;
        head.right = tmp;
        
        //交换完后，向左遍历
        if(head.left !=null)
            MirrorTree(head.left);
        
        //对左边进行翻转后再对右侧进行翻转
        if(head.right != null)
            MirrorTree(head.right);
    &#125;
    
    //创造二叉树（简单的二叉树）
    private static BinaryNode CreateBinaryTree2() &#123;
        BinaryNode head = new BinaryNode(8);
        head.left = new BinaryNode(6, new BinaryNode(5), new BinaryNode(7));
        head.right = new BinaryNode(10, new BinaryNode(9), new BinaryNode(11));
        
        return head;
    &#125;
</code></pre>
<h1 id="剑指offer-28-判断对称二叉树"><a href="#剑指offer-28-判断对称二叉树" class="headerlink" title="剑指offer 28 判断对称二叉树"></a>剑指offer 28 判断对称二叉树</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>判断二叉树是否是对称二叉树，例子如下</p>
<img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210808000919737.png" alt="image-20210808000919737">

<h2 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h2><p>可以通过二叉树的前序遍历与对称二叉树的前序遍历来判断是否完全对称</p>
<p>以上面图为例：左侧的二叉树的前序遍历：657；右侧二叉树再进行前序遍历657(当左侧进入左子节点，右侧进入右子节点)</p>
<p>这道题考察对二叉树遍历的理解，了解判false的条件很重要</p>
<p><strong>Attention</strong>判断条件：</p>
<p>若left和right同时为null， 返回true；</p>
<p>若head == null, 返回false； </p>
<p>若head.left == null || head.right == null, 返回false；</p>
<p>若left与right的value不相等，返回false;</p>
<p>若都相等，接着递归</p>
<h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><pre><code class="java">    public static boolean IsSymetric() &#123;
        BinaryNode head = CreateBinaryTree3();
        if(head == null)
            return false;
        return IsSymetric(head.left, head.right);
    &#125;
    
    private static boolean IsSymetric(BinaryNode left, BinaryNode right) &#123;
        if(left == null &amp;&amp; right == null)
            return true;
        
        if(left == null || right == null)
            return false;
        if(!Equal(left.value, right.value))
            return false;
        
        //左侧与右侧同时遍历（左侧与右侧都相等）
        return IsSymetric(left.left, right.right)&amp;&amp; IsSymetric(left.right, right.left);
        
    &#125;
    
    
    //判断对称二叉树
    private static BinaryNode CreateBinaryTree3() &#123;
        BinaryNode head = new BinaryNode(8);
        head.left = new BinaryNode(6, new BinaryNode(5), new BinaryNode(7));
        head.right = new BinaryNode(6, new BinaryNode(7), new BinaryNode(5));
        
        return head;
    &#125;
</code></pre>
<h1 id="剑指offer-29-顺时针打印矩阵"><a href="#剑指offer-29-顺时针打印矩阵" class="headerlink" title="剑指offer 29 顺时针打印矩阵"></a>剑指offer 29 顺时针打印矩阵</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>按照矩阵排布顺时针打印矩阵</p>
<p>输入：</p>
<p><img src="/LeetCode%E7%BB%83%E4%B9%A0/image-20210808001032476.png" alt="image-20210808001032476"></p>
<p>输出：1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p>
<h2 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2>
    </div>
    
    
    
</div>
                        <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2024 Yao Xiong
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yao Xiong
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        


    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>