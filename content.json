{"meta":{"title":"Yao Xiong","subtitle":"Here is my personal blog ๐•ᴗ•๐ ","description":"莫听穿林打叶声， 何妨吟啸且徐行","author":"Yao Xiong","url":"http://xiongy-rhit.github.io","root":"/"},"pages":[],"posts":[{"title":"Code Composer Studio \"gmaker\" Problem","slug":"2022-11-28-Code-Composer-Studio-gmaker-Problem","date":"2022-11-28T05:00:00.000Z","updated":"2024-06-30T05:31:49.354Z","comments":true,"path":"2022-11-28-Code-Composer-Studio-gmaker-Problem/","link":"","permalink":"http://xiongy-rhit.github.io/2022-11-28-Code-Composer-Studio-gmaker-Problem/","excerpt":"","text":"Problem DescriptionWhen using Code Composer Studio to build sample program for MSP-EXP432P4111, I meet a problem like the following one. gmake: *** No rule to make target &#39;callbacks.obj&#39;, needed by &#39;all&#39;. gmake: No rule to make target `C:/ti/ ....&#39; gmake: No rule to make target `C:/ti/ ....&#39; gmake: No rule to make target `C:/ti/ ....&#39; gmake: No rule to make target `C:/ti/ ....&#39; Gmake main obj Error 1 gmake: Target &#39;all&#39; not remade because of errors My SolutionCheck Your Directory Path &amp; Your System Language Check the directory path does not contain space or other characters (such as Chinese) Check windows cmd coding format is default format","categories":[],"tags":[],"author":"Yao Xiong"},{"title":"Personal Network Drive","slug":"2022-11-24-Personal-Network-Drive","date":"2022-11-24T05:00:00.000Z","updated":"2022-11-25T05:48:43.594Z","comments":true,"path":"2022-11-24-Personal-Network-Drive/","link":"","permalink":"http://xiongy-rhit.github.io/2022-11-24-Personal-Network-Drive/","excerpt":"Build Personal Network Drive Through NextcloudOneDrive and Google Drive only provide about 15 G free space. If I want to use more space, I have to subscribe their services. To save the money, I decide to set up a network drive at home. Through the internet, I notice the combination: Ubuntu + Nextcloud. Here is what the final result looks like.","text":"Build Personal Network Drive Through NextcloudOneDrive and Google Drive only provide about 15 G free space. If I want to use more space, I have to subscribe their services. To save the money, I decide to set up a network drive at home. Through the internet, I notice the combination: Ubuntu + Nextcloud. Here is what the final result looks like. Step 1. Install Ubuntu SystemYou need to install a Ubuntu System on your Virtual Machine or Raspberry Pi Virtual Machine Go to Ubuntu’s Official Website: https://ubuntu.com/#download Download Ubuntu Desktop Mirror File Open your Virtual Machine Software in Windows and load the Mirror File. Here is a reference video for installing ubuntu in virtual machine: https://www.youtube.com/watch?v=x5MhydijWmc&amp;ab_channel=ProgrammingKnowledge Raspberry Pi First two steps for Raspberry Pi are similar to virtual machine: go to official website and download mirror file Use Raspberry Pi Imager to set up ubuntu system into your SD card. Here is the link for this software: https://www.raspberrypi.com/software/ Put the micro-SD card into Raspberry Pi and start Step 2. Install Related SoftwareAfter installing Ubuntu System, you need to install Apache, MariaDB, and Nextcloud. ApacheType the following two commends in ubuntu shell sudo apt update sudo apt install apache2 libapache2-mod-php7.4 7.4 is the version of PHP. After running the second commend, we need to check our php and apache version. php -v apache2 -v if our installed php version is not 7.4, such as 8.1, replace the following php7.4 with php8.1 sudo apt install php7.4-gd php7.4-mysql php7.4-curl php7.4-mbstring php7.4-intl sudo apt install php7.4-gmp php7.4-bcmath php-imagick php7.4-xml php7.4-zip MySQL &amp; MariaDBsudo apt install mariadb-server After installing mariadb, we need to configure our database. Press enter key when promoted for a password sudo mysql start sudo mysql -uroot -p After typing enter Typing the following commends after MariaDB [(none)] &gt; one by one (Do not miss ‘;’ in the end of each commend) set username as what you want set password as what you want CREATE USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;; CREATE DATABASE IF NOT EXISTS nextcloud CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; GRANT ALL PRIVILEGES ON nextcloud.* TO &#39;username&#39;@&#39;localhost&#39;; FLUSH PRIVILEGES; Here is my example CREATE USER &#39;peter&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;; CREATE DATABASE IF NOT EXISTS nextcloud CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; GRANT ALL PRIVILEGES ON nextcloud.* TO &#39;username&#39;@&#39;peter&#39;; FLUSH PRIVILEGES; Try to Quit MariaDB quit; NextcloudGo to official website to download the file. Here is the link Download Since we plan to run the server on our laptop or virtual machine or raspberry pi, please choose “DOWNLOAD SERVER” In community projects, choose Get ZIP file After downloading the file, unzip it in ubuntu // unzip tar tar -xjvf filename // unzip zip unzip filename Now, all the files will be in folder nextcloud Move the folder into apache’s (webserver) directory cp -r nextcloud /var/www Step 3. Set Software Parameters Set up authority for apache2. Otherwise, we cannot write any data to our server. It is important chown -R www-data:www-data nextcloud Config apache server we will use vim to add file “nextcloud.conf” cd /etc/apache2/sites-available sudo vim nextcloud.conf Type the following in nextcloud.conf Alias /nextcloud &quot;/var/www/nextcloud/&quot; LoadModule ssl_module modules/mod_ssl.so &lt;Directory /var/www/nextcloud/&gt; Require all granted AllowOverride All Options FollowSymLinks MultiViews &lt;IfModule mod_dav.c&gt; Dav off &lt;/IfModule&gt; &lt;/Directory&gt; Check apache status and Done sudo systemctl status apache2 Now, you can input your IP address on your browser 192.168../nextcloud/ Optional (Encrypt SSL)How to get SSL for free ? Here is the Link: Free Encrypt SSL Free Dynamic Domain: Free Dynamic Domain In the link, the author is using Nginx, but we use Apache, so we need to add the config in our apache server folder. Replace ‘Your IP’ &amp; ‘Your Domain’ in the following text Alias /nextcloud &quot;/var/www/nextcloud/&quot; LoadModule ssl_module modules/mod_ssl.so &lt;Directory /var/www/nextcloud/&gt; Require all granted AllowOverride All Options FollowSymLinks MultiViews &lt;IfModule mod_dav.c&gt; Dav off &lt;/IfModule&gt; &lt;/Directory&gt; &lt;VirtualHost &#39;Your IP&#39;:443&gt; DocumentRoot /var/www/nextcloud ServerName &#39;Your Domain&#39; SSLEngine on SSLCertificateFile /etc/letsencrypt/live/&#39;Your Domain&#39;/cert.pem SSLCertificateKeyFile /etc/letsencrypt/live/&#39;Your Domain&#39;/privkey.pem SSLCertificateChainFile /etc/letsencrypt/live/&#39;Your Domain&#39;/chain.pem &lt;/VirtualHost&gt; Copy these texts and replace ‘nextcloud.conf’ cd /etc/apache2/sites-available sudo vim nextcloud.conf Issues Network Error: 99 Problem 1 My solution: Increase php memory &amp; file upload size increase mysql sort_buf_size I am not sure it is true, but it works for me.","categories":[],"tags":[{"name":"DIY","slug":"DIY","permalink":"http://xiongy-rhit.github.io/tags/DIY/"}]},{"title":"JAVA Memo Project (Introduction)","slug":"2022-4-28-JAVA-Memo-Project-(Introduction)","date":"2022-04-28T04:00:00.000Z","updated":"2022-04-29T01:53:47.000Z","comments":true,"path":"2022-4-28-JAVA-Memo-Project-(Introduction)/","link":"","permalink":"http://xiongy-rhit.github.io/2022-4-28-JAVA-Memo-Project-(Introduction)/","excerpt":"","text":"Java Memo I like to write memos on my computer. However, I did not find any memo software that can be locked. By happened, these days, I have received a project related to java. One idea comes to my mind: why don’t I use java classes to create my memo software? If I cannot find software satisfied my demand, why don’t I create it by myself. Thus, my finial java project is JAVA Memo. Preview to know more: https://github.com/peter-bear/JAVA_Memo/blob/main/JAVA_Memo.emmx Structure have a look at it: https://github.com/peter-bear/JAVA_Memo/blob/main/uml.png Technique Internet IO File IO Java Class Hash Encoding ConclusionThere are few bugs in this software. I am still little confusing about multi-threads. I hope I can learn more about it in the future.","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://xiongy-rhit.github.io/tags/JAVA/"},{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"}]},{"title":"Intro to Computer System","slug":"2022-3-8-Intro-to-Computer-System","date":"2022-03-08T05:00:00.000Z","updated":"2022-08-25T23:55:09.177Z","comments":true,"path":"2022-3-8-Intro-to-Computer-System/","link":"","permalink":"http://xiongy-rhit.github.io/2022-3-8-Intro-to-Computer-System/","excerpt":"计算机系统入门了解计算机系统：二进制编码，内存分配，计算机寻址，C语言基础，C转汇编， CPU进程调度，C语言网络IO","text":"计算机系统入门了解计算机系统：二进制编码，内存分配，计算机寻址，C语言基础，C转汇编， CPU进程调度，C语言网络IO 进制表示计算机中进制是二进制，以0和1为主，这里不多做介绍（网上有许多教程） Unsigned Binary (无符号二进制) 4-bit Signed Binary(有符号二进制) 4-bit Hexadecimal(16进制) Decimal(10进制) 0000 0000 0 0 0001 0001 1 1 0010 0010 2 2 0011 0011 3 3 0100 0100 4 4 0101 0101 5 5 0110 0110 6 6 0111 0111 7 7 1000 8 8 1001 9 9 1010 A 10 1011 B 11 1100 C 12 1101 D 13 1110 E 14 1111 F 15 Signed Binary (4-bit 有符号型数据) Decimal 1000 -8 1001 -7 1010 -6 1011 -5 1100 -4 1101 -3 1110 -2 1111 -1 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 (Unsigned Binary) 当二进制数据长度为 n 时： min: 0 max: 2^n -1 (Signed Binary) 当二进制数据长度为 n 时： min: -2^(n-1) max：-2^(n-1) -1 计算机地址与内存计算机内部元器件抽象图： 计算机需要读取数据和存储数据，所以本章将介绍在Main Memory内存中，计算机是如何寻找数据以及存储数据的 Address内存中的数据以二进制的方式存储，每8个二进制数据对应1个地址，我们将这1个地址的大小称为1 byte （1字节） 1 byte = 8 bits (1字节 = 8 比特) indices = addresses (location) 内存地址，每个地址间相差1字节数据，图如下 8-bit CPU 可寻地址大小为 2^8 Byte 32-bit CPU 可寻地址大小为 2^32 Byte 需要寻址大小为 N bytes of memory, 至少需要 CEIL[ log_2(N) ] bit 长度 Locating Data内存中数据存储分2种，小端存储与大端存储，两种存储方式在计算机内部都行得通，只是顺序不同 把内存想象成很长的一串数组，每个空位对应一段内存地址，在这段内存地址中存有1 byte （8-bit）的二进制数据 Little Endian 小端 低数据位对应低地址，小端机器 Big Endian 大端 高数据位对应低地址，大端机器 举例说明 数据： 0x deadbeef MSB (Most Significant Byte) LSB (Least Significant Byte) Big Endian de ad be ef LSB (Least Significant Byte) MSB (Most Significant Byte) Little Endian ef be ad de 地址 0x10 (低地址) 0x11 0x12 0x13 （高地址） ARM汇编基础Program Path要将C代码转化成可执行文件需要3步 编译器Compiler将C文件 (.c 文件) 编译转成 .s 的汇编文件 汇编器Assembler将汇编文件 (.s 文件) 转成机器码 ( .o 文件 obj文件) 链接器Linker将多个Obj文件连接在一起，转成可**执行文件 ** 有时C文件之间需要相互调用，当其转化成各自的object 文件后， 连接器需要将这些文件整合，转为可执行文件 所以一个程序的全部工序如下 Task -&gt; C code -&gt; Assembly -&gt; object code -&gt; executable code 基础汇编指令 指令 例子 含义 add add r0, r1, r2 add r1 and r2 and assign the result to r0 (ro = r1+r2) str str A, [x] ; str r1, [x, #4] store data from register A to address x ; store ldr ldr A, [x] ; ldr r0, [x] load data from address x to register A ; load data from address x to register r0 sub sub r0, r1, #1 subtract r1 and #1 and assign the result to r0 (r0 = r1-1) b b .LOOP 类似于go to ble ble.LOOP less than or equal to; blt bgt bx cmp cmp r1, r2 if(r1 &gt; r2) mov mov r0, #3 assign number 3 to r0 (r0 = 3) ldr 指令Conditional Branching (if / else) cmp r0, #3 ble .LOOP //r0 &lt;= 3 ble : less or equal to blt : less than bgt : greater than bge: greater or equal to 内存层级RAM random access memory Static RAM made: with flip-flop (6 transistors) volatile: need power to sustain the data size: relatively big cost: $ 5000 /GB where: CPU registers, L1 cache Cache 缓存 check faster memory, if find the data, done, if not go to dynamic RAM or SSD (flush) Hit rate: % of finding the data in the cache Average speed: P(hit) * t_cache_hit + (1-P(hit)) * t_miss ​ = P(hit) * t_cache_hit + P(cache_miss) * t_miss Dynamic RAM made: transistors and capacitors periodically refresh and recharge volatile size: smaller than SRAM where: Main Memory, GPU speed: not as fast as static RAM SSD made: NAND flash volatile: non-volatile size: smaller than DRAME speed: lower type: SATA, PCIE, NVME limit: unites per page Hard Disk Magnetic Disk Not random not volatile size: larger than SSD speed: 200 MB/S cost: $ 0.01 / GB C语言基础struct_variable.x = 1; //struct结构体 （stack上的） (*struct_variable).x = 1; struct_pointer-&gt;y = ‘d’; // struct pointe是结构体指针 指针pointers enable us to access memory addresses in C Syntax: Declaring a pointer variable: &lt;type&gt;* (type is the stored data / object stored at this address) int* xp // xp is a pointer of an in object Get the address of a variable / object: &amp; int x = 5; xp = &x; Access the data with an address : *&lt;pointer&gt; //similar to assembly[ ] int y; y = *xp; // 把xp指向的地址的data赋值给y *xp = 3 //write / update the data xp points to as 3, 更新指向地址的数据 在32位机器上，指针大小为4字节 指针加1，按照指向地址向上移动对应的字节大小 shot 类型的指针地址 +1, 向上移动2字节 increase N size of the pointer 总结出来， *p 代表指针指向地址的值，而 p 本身是指向位置的地址 int a = 8; int b = 5; int* p = &amp;a; //指针p 指向 a的地址 printf(&quot;%d\\n&quot;, p); //打印地址 p = &amp;b; //把指针指向 b的地址 printf(&quot;%d\\n&quot;, p); //打印地址 *p = a; //把a的值赋值给指针指向的那个地址 printf(&quot;%d %d&quot;, *p, b); //打印指针指向的值的变化 数组与指针 使用指针比较结构体中2个字符串的大小，并将长的输出 方法1，使用指针遍历，（不使用数组下标） void print_longer(struct two_things* input)&#123; int firstLength = 0, secondLength = 0; while (*input-&gt;thing_one != &#39;\\0&#39;) &#123; input-&gt;thing_one++; firstLength++; &#125; input-&gt;thing_one -= firstLength; while ( *input-&gt;thing_two != &#39;\\0&#39;) &#123; input-&gt;thing_two++; secondLength++; &#125; input-&gt;thing_two -= secondLength; if (firstLength &gt; secondLength) printf(&quot;%s&quot;, input-&gt;thing_one); else printf(&quot;%s&quot;, input-&gt;thing_two); &#125; 方法2，使用数组下标遍历 void print_longer(struct two_things* input)&#123; int firstLength = 0; while(input-&gt;thing_one[firstLength] != &#39;\\0&#39;)&#123; firstLength ++; &#125; int secondLength = 0; while(input-&gt;thing_two[secondLength] != &#39;\\0&#39;)&#123; secondLength ++; &#125; if(firstLength &gt; secondLength) printf(&quot;%s&quot;, input-&gt;thing_one); else printf(&quot;%s&quot;, input-&gt;thing_two); &#125; 内存管理堆与栈 Stack and Heapstack ​ store local variables, return addresses ​ static ​ not persistent (memory space won’t be available after function return) scanf ​ keyboard input to the program heap ​ dynamic ​ persistent (available in the memory after function return) malloc ​ pointer = malloc (# of bytes) free ​ free(pointer) sizeof ​ sizeof(malloc出来的地址，大小就是指针大小) ​ be sure not to use it to measure the length since it only gives us the size of data type (char, int, sturct结构体) ​ #inlcude&lt;stdlib.h&gt; #include&lt;stdio.h&gt; void main()&#123; char* array1 = malloc(256); char array2[128]; printf(&quot;%d %d&quot;, array1, array2); //32位机器使用4B 作为指针 &#125; /* OUTPUT 4, 128 数组在stack中， array1在heap中 */ Memory leakage ​ be sure to free your malloc # include &lt; stdlib .h &gt; # include &lt; stdio .h &gt; # include &lt; string .h &gt; char * printOnce () &#123; char * c = malloc (10) ; strncpy (c , &quot; Amadeus !&quot;, 10) ; printf (&quot;%s\\n&quot;, c ) ; free ( c ); return c ; &#125; int main ( int argc , char ** argv ) &#123; char * c ; c = printOnce () ; printf (&quot;%s\\n&quot;, c ) ; // print again return 0; &#125;","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://xiongy-rhit.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"Intro to Proof 离散数学","slug":"2022-2-18-Intro-to-Proof-离散数学","date":"2022-02-18T05:00:00.000Z","updated":"2022-03-09T00:19:47.969Z","comments":true,"path":"2022-2-18-Intro-to-Proof-离散数学/","link":"","permalink":"http://xiongy-rhit.github.io/2022-2-18-Intro-to-Proof-%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/","excerpt":"介绍离散数学不好学 (,) 当我第一次接触时就觉得痛疼，认为这种东西一点用也没有；殊不知离散数学乃是计算机算法分析，逻辑证明中最重要的一环。本教程按照笔者在大学时的学习大纲进行编排，希望写的东西能够对读者有些用","text":"介绍离散数学不好学 (,) 当我第一次接触时就觉得痛疼，认为这种东西一点用也没有；殊不知离散数学乃是计算机算法分析，逻辑证明中最重要的一环。本教程按照笔者在大学时的学习大纲进行编排，希望写的东西能够对读者有些用 逻辑与真值表 (Propositional &amp; Predicate Logic)常用符号下面表格中内容是数学证明中常用的表达符号 Iff / → If and only if Q.E.D End of proof s.t Such that | Such that | Divides (2 | 4) (4 is divisible by 2) ∀ For all / for any ∃ For at least one / there exists ∈ In / “is contained in” / 属于 ∵ Because ∴ Therefore WTS Want to show LHS / RHS Left-hand side / Right-hand side R Real numbers (0, 7.332, pi) 实数 （除虚数以外的数） N Natural Numbers 自然数 (0, 1, 2, 3, 4 …) Z Integers 整数 Q Rationals 有理数 (Any integer divided by any non-zero integer, e.g. -7/2) Hint WLOG / WOLOG Without Loss of Generality 不失一般性 (说明该个例能代表普遍情况，而非一种特例) Eg.1 Let m, n be two natural numbers, one even and one odd. WOLOG m is even Mathematical abbreviations (数学缩写) Every natural number is an integer ∀ n∈ N, n ∈ Z ≡ ∀ n (n ∈N → n ∈ Z) There is a real number that is an integer ∃ x∈R | x ∈Z ≡ ∃ x∈R ⋂ Z The square of every integer is a natural number ∀ x∈ Z, x^2 ∈ N ≡ ∀ x (x ∈Z → x^2 ∈ N) 真值表用表格来表示输入与输出的可能性 p q p ⋀ q (and与) p ⋁ q (or或) p ⊻ q (xor异或) 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 Tautology : always be true, 总是T， T。 例如: 1 +1 = 2 Contradiction: always be false, 总是F，F。 例如：p ^ ~p (I love you and I don’t love you) conditional 与 biconditionalConditional (if-then) : p→q 如果p，那么q p q p → q 0 0 1 0 1 1 1 0 0 1 1 1 p 叫做假设（hypothesis） q 叫做结果 （consequence） Consequent: I am wearing black and white Hypothesis: It is Monday If it is Monday, I am wearing black and white When it is Monday, I am wearing black and white I am wearing black and white when it is Monday 学习condition符号可以联想政客 If I am elected, then taxes will be lower in 2022 than in 2021 如果我被选上，那么2022年的税收会小于2021年 P: I am elected Q: taxes will be lower in 2022 than in 2021 政客只有当其有被选上且没有实现诺言时，才能推断出其说了谎 p (I am elected) q (taxes are lower in 2022 than in2021) p → q (tell the truth) 0 0 1 0 1 1 1 0 0 (lie) 1 1 1 Attention When the hypothesis is False, the conditional proposition is True. The only time a conditional statement is False is when hypothesis is Ture and the consequence is False. Negation (取反) What is the correct negations of p -&gt; q ? (p ⋁ q) p -&gt; q = ~p ⋁ q Biconditional (iff: if and only if): 当且仅当 p ↔ q (结果为真，只有当p与q是一样的时候) If both of their truth value match, the biconditional is true. If they don’t, the biconditional is false. p q p ↔ q 0 0 1 0 1 0 1 0 0 1 1 1 Variations of Conditional Proposition (if-then的变化) 名称 符号表示 Converse (Reverse Roles) q -&gt; p Contrapositive (Reverse and Negate Roles) ~q -&gt; ~p Inverse (Negate Roles) ~p -&gt; ~q Example: p: I binge watch The Good Place q: I don’t get enough sleep Contrapositive: If I get enough sleep, I did not binge watch The Good Place. Converse: If I don’t get enough sleep, I binge watch The Good Place. Inverse: If I did not binge watch The Good Place, then I get enough sleep. Boolean Laws Boolean Laws可以用来化简等式 例子： 化简 （p-&gt;q）^ (p ^ ~(p^q)) （p-&gt;q）^ (p ^ ~(p^q)) = (p v q) ^ (p ^ (p v ~q)) = (~p v q) ^ ((p ^ ~q) v (p ^ ~q)) = (~p v q) ^ (p ^ ~q) Rules of Inference我们可以根据逻辑判断 一句话是否有效 (is the following argument valid?) Example 1: if 2+3 = 6, then 2+4 = 6. But 2+3 != 6, therefore 2+ 4 != 6 p: 2+3 = 6 q: 2+4 = 6 p -&gt; q ~p so ~q (not valid) because if p = 0, q = 1 or 0 判断argument是否valid 找出关系 理出表格 公式变形进行推理 Invalid, 举出反例 Example 2: is the following argument valid? If Dr.Riehl didn’t have time to write the test or the copier was broken, then the exam would be postponed and Song would be overjoyed. If the exam were postponed, then it would have to be given on a Thursday. The exam was not given on a Thursday. Therefore Dr.Riehl had time to write the test. T: Dr.Riehl have time to write the test CB: the copier was broken, EP: the exam would be postponed SO: Song would be overjoyed. ET: it would have to be given on a Thursday (~T v CB) -&gt; (EP ^ SO) EP -&gt; ET ~ET so T By 2 and 3, we can conclude ~EP. Since ~EP, we know ~EP v ~SO. By Demorgan’s Law, ~EP v ~SO = ~ (EP ^ SO) Then by 1, (T v CB) By Demorgan’s Law, (T v CB) = T ^ ~CB Thus, T (is valid) Quantifiers 限定词 限定词 关键词 表示意思 ∃ 存在 there is at least one / there is some something / someone ∀ 任意 for all / for every / no matter which everyone / everything 哎，文字游戏~~ Example: how to read it P(x, y): x · y = 1. Then ∀x∃y P(x, y) could be written as ∀x∃y x · y = 1 Read: For any x, there exits a y so that x * y = 1 Or: No matter what x is, there is at least one y so that x * y = 1 Negate On Quantifiers: ！∃ = ∀ ！∀ = ∃ 对 ∀x∃y P(x, y) ，P(x, y): x · y = 1 进行negation：! [∀x∃y P(x, y)] = ∃x∀y ！P(x, y) Example： For the open statement P(x,y) : x+1/y = 3 Decide if the following are true or false and fully justify. ∀x ∃y P(x,y) False. (举反例) Use the negation method. WTS: ∃x∀y x +1/y != 3 is true. Let x=3. Then there does not exist a y in R so that 1/y = 0. ∀y ∃x P(x,y) False. Use negation method. WTS: ∃y∀x x +1/y != 3 is true. Let y=0, it is true. Thus, the original statement is false. ∃y∀x P(x,y) -&gt; P(3, y) True. Let y=0, ∃y∀x P(x,y) is False and ∃y∀x P(3,y) is also False. Thus, according to the definition of (if-then) the result is true. 集合 (Set)介绍可以把集合当作一个存储数据的容器，在这个容器里面没有一个元素是重复的。 一般用{}表示集合中的元素。例如可以用{1, 2, 3}表示集合A中的元素；由于集合中的数据是无序的，所以{1, 2, 3} = {2, 3, 1}. 同样，考虑到集合中的元素是不重复的，所以{1, 2, 3} = {1, 2, 3, 3, 3} 总结一下集合的特点： 元素不重复 内部元素无序 集合的大小叫做cardinality, |{1, 2, 3}| = |A| = 3, 说明集合A的大小是3 集合里面的元素属于集合，所以以集合A为例， 1 ∈ A 表示元素 1属于A 若一个集合包含另一个集合中的所有元素，则另一个集合是此集合的子集，例如{1, 3} ⊆ {1, 3, 4} 当一个集合没有任何元素，则该集合被称作空集。∅ 上面这些高中几乎都学过，就不多展开赘述 LawsUnion (并集)： A ⋃ B = {x | x ∈ A or x ∈ B} Intersection (交集): A ⋂ B = {x | x ∈ A and x ∈ B} Symmetric Difference: A ∆ B = {x | x ∈ A ⋃ B and x ∉ A ⋂ B} Difference: A-B = {x | x∈A and x ∉ B} 集合里面的定理记住几个常用的就好了，下面是总结的集合中的定律 基础证明方法 (Proof Techniques)证明方法总结下来Prove statement一共就3种： Direct Proof 直证 Proof by Contradiction 反证 Proof by Contrapositive 逆反证法 当我们知道条件过后，根据条件中对象的定义对结果进行推理 常用定义： 奇偶数, even and odd number if n is even, then there exits an integer k so that n=2*k if n is odd, then there exits an integer k so that n=2*k+1 整除，除数, a | b, b is divisible by a if a | b, then there exits an integer so that a*k = b 有理数, rational number, if a is a rational number, then there exits two integers p and q so that p / q = a and q != 0 Direct Proofif p, then q. p -&gt; q Assume p, make logical deduction from p until we deduce q. 假设p是对的，从p的定义推出q 例子： Prove: If n is even, then n^2 is even Solution: Assume n is even. Then there exits an integer k so that n = 2k. So n^2 = (2k)^2 = 4k^2 = 2*(2k^2). Since k is an integer, n^2 is even. Proof by Contradictionif p, then q. Assume p and not q, then deduce by contradiction. 假设p 和 非q是正确的， 推导出结果与假设相反或者non-sense 例子： Prove: If n^2 is odd, then n is odd. Solution: Assume n^2 is odd and n is even, then there exits an integer k so that n^2 = 2k+1 and there exits an integer j so that n = 2j. Then n^2 = (2j)^2 = 2(2j^2) so n^2 is even. However, the result contradicts with our assumption. Thus, if n^2 is odd, then n is odd. Proof by Contrapositiveif p, then q. Assume not q, deduce not p. 假设非p为真，推导出非p也是真 例子： Prove: If n^2 is even, then n is even. Solution: Assume n is odd, then there exits an integer k so that n = 2k+1. n^2 = (2k+1)^2 = 4k^2+4k+1 = 2(2k^2+2k)+1. Since k is an integer, n^2 is odd. By contrapositive proof, if n^2 is even, then n is even. Tips通过上面的例子可以发现，证明直接套公式就行，根据已知条件和已知条件的定义（注意不能够用其他未证明的结论，比如if n is even then n^2 is also even）推导出结论 归纳推理 (Induction and Recursion)介绍Induction 递推， 就行多米诺骨牌一样，根据已知推出未知。Induction分为weak induction, strong induction与structure induction Induction 分为2个部分， base case与induction assumption base case就是选取初始常量，一般是开头的几个 induction assumption就是根据已有的条件，假设k的情况下成立，推导出k+1的情况也成立 Weak Induction定义： Let S(n) denote an open mathematical statement that involves one or more occurrences of the variable n, which represents a natural number, often no smaller than 1. ​ a) if S(1) is true, and it is base case ​ b) If whenever S(k) is true (for some particular, but arbitrary, natural number k), then S(k+1) is true, then S(n) is true for all natural number n (Induction Part) 例子： Prove: 1+3+5+…+(2n-1) = n^2 for all n&gt;=1 Solution: Base case: LHS (left hand solution): 1 ​ RHS (right hand solution): 1^2 = 1 ​ LHS = RHS Induction Step: Assume 1+3 +5+…+ (2k-1) = k^2 for some k &gt;= 1 (递推证明2k+1的情况下同时满足上面等式) (我们可以使用上面的假设)Then 1+3+5+…+(2k-1)+(2k+1) = k^2 +2k +1 = (k+1)^2 Thus, 1+3+5+…+(2n-1) = n^2 for all n&gt;= 1 proved by PMI Strong InductionLet S(n) denote an open statement that involves one or more occurrences of the variable n, a natural number. Also, let n_0 and n_1 be natural numbers with n_0 &lt;= n_1 ​ a) If S(n_0), S(n_0+1), S(n_0+2), … S(n_1-1), and S(n_1) are true (base case) ​ b) If whenever S(n_0), S(n_0+1), S(n_0+2), … ,S(k-1), and S(k) are true for some particular but arbitrary natural number k where k &gt;= n_1, then the statement S(k+1) is also true. Then S(n) is true for all n &gt;= n_0 Strong Induction 一般用于递归, 推算斐波那契而数列结果 Strong Induction 例子： Define a sequence an by a_0 = 8, a_1 =10, and a_2 = 11, and a_n = a_n-1 + a_n_2 + a_n-3 Basis case: a_4 = 50 &lt; 3^4 a_5 = 90 &lt; 3^5 a_6 = 169 &lt; 3^6 Induction Step: Assume that a_k &lt; 3^k, a_k+1 &lt; 3^k+1, a_k+3 &lt; 3^k+2 for some k is natural number and k &gt;= 4 Then a_k+3 = a_k+2 + a_k+1 + a_k ​ &lt; 3^k+2 +3^k+1 + 3^k ​ = 3^k *(3^2 + 3^1 +3^0) ​ = 3^k *(13) ​ &lt; 3^k *(27) Thus, a_n &lt; 3^n for all n are natural number and n &gt;=4 例子2： The natural number n can be written as a sum of 3’s and 5’s 通过推导计算，我们发现当n &gt;= 8时， n 可以写作3和5的和 Basis Case: 8 = 3+5 9 = 2*3+5 10 = 5+5 Next assume that S(8), S(9), S(10), … S(k) is true for some natural number k &gt;= 10. Then k+1 can be written as (k-2)+3 and since k &gt;= 10, we know k-2 &gt;= 8, so k-2 can be written as a sum of 3’s and 5’s. Thus so can k+1. Consequently, S(n) is true for all n &gt;= 8 by the strong form of PMI (principle of Mathematical Induction) Structure Induction解structure Induction的题目只需要套公式即可 例子： Define T to be the set so that: 12 ∈ T, and for any x ∈ T, x^2 ∈ T, and 3x+8 ∈ T. Prove that every element of T is divisible by 4. Base Case: 题目中出现的常量 ​ 12 = 4*3 so 4 | 12 Inductive assumption: 先假设Prove的情况成立，再推导出我们的条件也满足prove中的情况 ​ Assume that 4 | k for some k ∈ T. ​ Then there exits an integer m so that 4m = k. k^2 = 4*(4m^2), so 4 | k^2 ​ 3k +8 = 12m+8 = 4(3m+2), so 4 | 3k+8 Thus, 4 | x for all x ∈ T. 关系 (Relation)Cartesian Product笛卡尔积For sets A and B, the Cartesian product A x B is defined to be {(a, b) | a ∈ A and b ∈ B} （组合罢了） 例子 For A ={1, 6, 7} and B ={*, o}, find A x B A x B ={(1, *), (1, o), (6, *), (6, o), (7, *), (7, o)} B x A ={(*, 1), (o, 1), (*, 6), (o, 6), (*, 7), (o, 7)} Cartesian Product是有顺序的 Theorem: A x (B ⋂ C) = (A x B) ⋂ (A x C) WTS: A x (B ⋂ C) ⊆ (A x B) ⋂ (A x C) Let (a, d) ∈ A x (B ⋂ C), so a ∈ A and d ∈ B ⋂ C. Then a ∈ A and d ∈ B and d ∈ C. Then (a, d ) ∈ A x B and (a, d) ∈ A x C Thus, (a, d) ∈ (A x B) ⋂ (A x C) and A x (B ⋂ C) ⊆ (A x B) ⋂ (A x C) WTS: (A x B) ⋂ (A x C) ⊆ A x (B ⋂ C) Let (e, f) ∈ (A x B) ⋂ (A x C), so (e, f) ∈ (A x B) and (e, f) ∈ (A x C). Then, e ∈ A and f ∈ B and C Thus, (e, f) ∈ A x (B ⋂ C). (A x B) ⋂ (A x C) ⊆ A x (B ⋂ C) 关于Relation的其他definitionif a is related to b, we can express it as aRb or (a, b) ∈ R (Reverse Relation) If A and B are sets with R defined on A x B, then R^-1 = {(b, a) | (a, b) ∈ R} If A, B, and C are sets with R_1 defined on A x B and R_2 defined on B x C, then the composite elation R_2 o R_1 is {(x, z) | there exits a y in B with (x, y) ∈ R_1 and (y, z) ∈ R_2} ( R_2 o R_1 能够从R_1 到 R_2 的元素) Relation 特点Reflexive （自交，每个元素都与自己本身有关系） A relation R is reflexive if (a, a) ∈ R for all a in A Symmetric（对称的） A relation is symmetric if for all x and y ∈ X if (x, y) ∈ R, then (y, x) ∈ R Antisymmetric (非对称的) 可以与Symmetric同时满足 A relation is antisymmetric if for all x and y ∈ X, x != y, if (x, y) ∈ R, then (y, x) not ∈ R. Transitive (可递的) A relation is transitive if for all x, y, z ∈ X, if(x, y) ∈ R and (y, z) ∈ R, then (x, z) ∈ R 这些关系，用一张图表示各种情况 序关系 (Order Relation)常见概念Partially Ordered Set (poset) [一个relation是Reflexive， antisymmetric 和 transitive 的] RAT Hasse diagram: 把Relation的关系通过图的方式表现出来，下面例题就是Hasse Diagram A partial order where for every two distinct elements x and y, either (x, y) or (y, x) is called a total order. Maximal Element: 只能从其他点到自己，而无法从自己到其他点 Minimal Element: 可以从自己到达其他点，但无法从其他点到自己 Largest Element (有且只有一个) : 最大的，可以从所有点到达自己 Smallest Element (有且只有一个)：最小的，可以从自己到达所有点 glb (greatest lower bound) of a set A: 某个点可以到达A中的所有点，这个点有且只有一个 lub (least upper bound) of a set A: A中所有点都可到达某个点，这个点有且只有一个 lattice: a poset is called a lattice if for all x, y ∈ A, the elements lub{x,y} and glb{x, y} both exits in A 例题 函数 (Function)介绍Domain 定义域 Range 值域 Codomain 值域所在的一个范围 函数的所有domain必须在codomain中有一个值与之对应 domain中的一个值在range中只有一个值与之对于 Injective 与 Surjectiveone-to-one (Injective) A function f: A-&gt;B is called one-to-one, or injective, if each element of B appears at most once as the image of an element A. An equivalent definition is more useful when trying to prove functions are one-to-one: f: A-&gt;B is one-to-one if for all a_1 and a_2 in A, f(a_1) = f(a_2) -&gt; a_1 = a_2 onto (Surjective) A function f: A-&gt; B is called onto, or surjective, if f(A)-&gt; B; that is, if the range of f is equal to the codomain.","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"GitHub 远程仓库托管(上传)操作","slug":"2021-11-11-GitHub-远程仓库上传与托管","date":"2021-11-11T05:00:00.000Z","updated":"2021-11-12T04:45:02.721Z","comments":true,"path":"2021-11-11-GitHub-远程仓库上传与托管/","link":"","permalink":"http://xiongy-rhit.github.io/2021-11-11-GitHub-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A%E4%BC%A0%E4%B8%8E%E6%89%98%E7%AE%A1/","excerpt":"介绍 最近想着把文件上传到远程仓库，进而可以多设备协同操作，但是在搭建远程仓库的过程中遇到了一些问题，所以想把这些问题记录下来，既可以分享给他人，也方便自己以后遇到相同问题好查看。 本博客将介绍我是如何上传代码到GitHub，以及我遇到的一些问题与总结","text":"介绍 最近想着把文件上传到远程仓库，进而可以多设备协同操作，但是在搭建远程仓库的过程中遇到了一些问题，所以想把这些问题记录下来，既可以分享给他人，也方便自己以后遇到相同问题好查看。 本博客将介绍我是如何上传代码到GitHub，以及我遇到的一些问题与总结 由于是新手教程，步骤会比较多，但是讲了可能会遇到的问题以及部分细节 如何上传我将上传代码分为2个部分： 在GitHub上建仓库 在本地进行Git Bash上传 在GitHub上创建仓库进入GitHub进入 Repositories 发现了一个绿色按钮，点击创建新的仓库 填写想要创建的仓库的名称与是否添加readme文档 完成后向下滑动，点击 远程就创建完成了接着可以从本地通过Git上传 记得复制Code下的SSH或者HTTPS 本地bash操作步骤1：下载Git先下载Git软件，这个就不多介绍了（有手就行），Git下载链接 步骤2：进入目录安装好后进入想要使用Git上传的目录，单击右键 步骤3：进入Git Bash进入Git Bash Here 步骤5：初始化本地仓库然后输入 git init 初始化git文件 由于我这里以及初始化完成了，所以有下面这行字，如果没有，则说明init成功 会看到想要git的文件夹里面有个.git文件 如果没有看到，打开windows的隐藏文件夹选项看看 步骤6：把所有要上传文件名加载到Git目录git add -A 我这里意思是全部加载到Git中（因为我想要全部加入进去）， 如果不想全部加入， 可以参考下面的链接（或者搜索引擎），修改add后面的参数 https://git-scm.com/docs/git-add 加进去后可以检查一下 git ls-files 展示所有在git中的文件名 步骤7：输入远程仓库urlgit remote add 自己取个变量名（一般使用origin） 远程仓库的链接（GitHub Code那边） 步骤8：CommitCommit，相当于要告诉别人，谁做了什么，怎么做的,然后准备上传 git commit -m &quot;init repo&quot; 问题 开始没有commit，直接进行后面的操作，一堆Bug，如下 然后commit时没有输入 -m 或者 没有输入 commit 后面的信息， 问题如下 注意 没有输入commit后面的信息会进入bash shell文档，类似于这种 其实输入:q! 可以退出这个文档不保存（这是linux vm命令） 步骤9：创建分支git branch -M main 我这里创建的本地分支名称是main 步骤10：配置上传用户名git config --global user.email &quot;your_email@example.com&quot; git config --global user.name &quot;your_user_name&quot; 配置完检查 步骤11：最后一步Pushgit push -u origin main origin 是之前写的 remote url main 是之前写的本地分支 为了避免本地分支与远程分支不一样的情况，可以使用下面代码 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 参考链接 结果 总结常用命令查看本地Git目录中的文件git ls-files 查看在Git中，之后会上传的文件有哪些 重置Gitgit reset 重置Git中要上传的文件，虽然重置了，但是git remote中的url并没有重置 将文件全部清空可以达到类似效果，只是有些部分没有重置 git clean -xdf 把文件删除清空 Remote url操作添加remote urlgit remote add origin https://github.com/peter-bear/JavaFundationPractice.git 添加remote url， 换句话说就是把url存到某个变量中，以便后面使用 git remote add 变量 远程仓库地址 查看remote urlgit remote -v 查看remote url 修改remote urlgit remote set-url origin git@github.com:peter-bear/JavaPractice.git 修改url： origion 是 remote url变量名， git@github.com:peter-bear/JavaPractice.git 是 远程仓库地址 修改url需要知道url变量的名字，这个变量需要存在， 不然结果如下 删除remote urlgit remote rm main 当有些url我们不想用时，我们可以使用此命令删除 main 在这里指的是 之前我们设置的url变量 其他关于remote的操作的中文版 (GitHub)https://docs.github.com/cn/get-started/getting-started-with-git/managing-remote-repositories Branch 分支创建本地分支git branch -M main 查看本地分支git branch 查看本地分支 关于分支的介绍 Git 文档 Config 配置config 用户名与邮箱git config --global user.email &quot;your_email@example.com&quot; git config --global user.name &quot;your_user_name&quot; 获取config的结果git config --get user.name get config --get user.email","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://xiongy-rhit.github.io/tags/Git/"}]},{"title":"Muti-Integrals","slug":"2021-10-30-Muti-Integrals","date":"2021-10-30T04:00:00.000Z","updated":"2021-11-01T18:13:00.000Z","comments":true,"path":"2021-10-30-Muti-Integrals/","link":"","permalink":"http://xiongy-rhit.github.io/2021-10-30-Muti-Integrals/","excerpt":"介绍多重积分是对于普通积分的衍生，多用于解决高维的问题。常用的多重积分有二重积分与三重积分。 本章将介绍二重、三重积分的解法，以及它们在几何上的意义","text":"介绍多重积分是对于普通积分的衍生，多用于解决高维的问题。常用的多重积分有二重积分与三重积分。 本章将介绍二重、三重积分的解法，以及它们在几何上的意义 Double Integral二重积分的表现形式如下 直接看代数，其实有点不好理解，所以我们要像普通积分一样，结合几何图形一起理解 普通积分可以看作是很多个长方形加在一起求面积的和，如图 当长方形的个数达到无数时，我们就能找出这个函数在某段区间的面积 多重积分同理，我们以二重积分为例，二重积分由于有2个积分符号，说明我们要有2个坐标轴方向的积分，换算成几何意义就是，二重积分需要我们求出函数在某段区间的体积，如图 和普通的积分一样，这个体积也可以由无数个长方体组成 所有长方体加起来就是函数在这个范围内的体积 Double Integral Over RectanglesDouble Integral Over Rectangles就是说求一个函数在2段不同轴方向的函数的体积 按照基本的求积分公式代值即可，由内而外 按照Fubini’s Theorem: 函数f(x,y)若在区间 a&lt;= x &lt;= b, c &lt;= y &lt;= d 内 continuous连续，则x,y求积分的顺序可以交换，图如下 当我们求积分，一个方向不好开始时，可以换一个方向，按照Fubini理论，指不定柳暗花明又一村 Double Integral Over Regions根据被包围的范围，求出函数在这个范围内的体积。判断范围，根据范围列式是多重积分的一大难点 注意 求积分按照常数求，得出的范围是一段长方形的范围，而不是包围边界的大小 所以我们要根据给出的关系列式，画图 Fubini Theorem增强版 根据提示找出范围 ，列式计算 例题1.函数x^2 *y +1 在由(0,0),(4,0),(4,2)围成的三角形中，求出这段三角形覆盖下的体积 看着很麻烦，其实我们只需要关注这个三角形的部分就好了，应为z轴部分是由x,y轴部分共同决定 根据Fubini法则，我们既可以先从y出发，也可以从x出发，计算过程，如图所示 例题2.有时候我们只知道函数公式，同时给出的式子无法帮助我们直接求出答案 为了求出这段体积，我们需要根据给出的范围画出图像，然后根据Fubini法则变换计算的顺序 hint： 把式子转为int(int(sqrt(x^5)+1,x=y^(1/4)..2),y=0..16) 对于判断范围其实更为直观一点 Double Integral (Geometry Meaning)1重积分，当函数为1时，计算的是线段的长度（1维） 2重积分，当函数为1时，计算的是包围的面积（2维） 图如下 此做法和我们之前1重积分计算面积的方法一样，之前求面积，就是目前的第三步 Average Value1重积分计算平均值（Average Value） 平均值算的是范围内的平均高度 2重积分同理 我们可以想象一下： The region as being the base of a tank with vertical walls around the boundary of the region, and imagining that the tank is filled with water that is sloshing around. The value f(x,y) is then the height of the water that is directly above the point (x,y). The average height of the water in the tank can be found by letting the water settle down to a constant height. This height is equal to the volume of water in the tank divided by the area of R. (翻译过来) 有一个大水箱，水箱中水的体积可以形成式子f(x,y)，二重积分计算的是箱子中水的体积；若水的体积除以水的底面积（箱子的底面积），则计算的是平均值（水高于底面的高度）（平均高度） Polar Coordinate有许多坐标系，不同的坐标系表示的方法也不一样，他们能够帮助我们解决不一样的问题（有时Cartesian Coordinate不行，不如试试Polar Coordinate） Polar Coordinate,极坐标，原点到函数的距离称之为r， r与x轴形成的角称之为 theta 所以，根据这个特征，我们能够将Polar Coordinate与Cartesian Coordinate进行转化 Polar Coordinate Integral极坐标求积分 扇形面积公式 最终公式 注意，极坐标无法改变积分顺序 Relationship Between Double Integral and Polar Integral由于Polar Coordinate与Cartesian Coordinate可以转换，有时我们在Cartesian坐标系无法解决，可以转到Polar Coordinate 尤其是遇到圆的情况时，使用Polar Coordinate 很方便 例子1 例子2 Triple Integral三重积分得出的答案位于4维空间 计算方法与二重积分类似，在Cartesian Coordinate中满足Fubini定理，可以变换积分顺序 Triple Integral Over Rectangles Or Regions 例子1 例子2求4个点围成的三角体的体积 例子3 注意，遇到圆方程时，可考虑使用Polar Coordinate Triple Integral (Geometry Meaning)三重积分计算的是4维空间的事物，当函数为1时，计算的结果是3维空间在此范围中的体积 Convenient Way To Solve Problems 找出边界（boundary） 确定好x, y, z的顺序 区分好Rectangle Boundary和Function Boundary 遇到圆，注意转换坐标系","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://xiongy-rhit.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"LeetCode练习","slug":"LeetCode练习","date":"2021-10-18T04:00:00.000Z","updated":"2021-10-18T22:13:43.079Z","comments":true,"path":"LeetCode练习/","link":"","permalink":"http://xiongy-rhit.github.io/LeetCode%E7%BB%83%E4%B9%A0/","excerpt":"123 股票问题题目给一个数组，它的第i个元素是一支给定的股票在第i天的价格。 设计一个算法来计算可获得的最大利润，你最多可以完成两笔交易 （可以只完成1笔） Attention: 你不能同时参与多笔交易 例子： 输入 [3，3，0，0，5，3，1，4]； 结果 8; 解释 第4天买入，第6天卖出， 第7天买入，第8天卖出， 总计利润 6 输入 [1，2，3，4，5]； 结果 4； 解释 第1天买入，第5天卖出， 总利润 4","text":"123 股票问题题目给一个数组，它的第i个元素是一支给定的股票在第i天的价格。 设计一个算法来计算可获得的最大利润，你最多可以完成两笔交易 （可以只完成1笔） Attention: 你不能同时参与多笔交易 例子： 输入 [3，3，0，0，5，3，1，4]； 结果 8; 解释 第4天买入，第6天卖出， 第7天买入，第8天卖出， 总计利润 6 输入 [1，2，3，4，5]； 结果 4； 解释 第1天买入，第5天卖出， 总利润 4 分析考虑到可以进行2笔交易，最后的数组应该是一个二维数组（用于记录每个点的最大收益），这需要用到动态规划算法; 二维数组每次比较得出此时的max profit然后存入数组中， max profit有2种选择 profits[i][j-1] //前一个的点的max profit price[j] - price[n] + profits[i-1][n] // n = 0..j-1 在选项2中我们要遍历price数组从而得出max profit， 这个过程可以进行优化 （针对选项2）优化如下 我们发现从前一种情况到后一种情况求出max profit时有重复的地方 其实我们可以用一个变量来表示重复部分，然后每次更新时比较一下，若利润更大，则更新 int tempProfit = -price[0]+profits[i-1][0]; for(int j=1;j&lt;profits[0].length;j++) &#123; if(profits[i-1][j-1]-price[j-1] &gt; tempProfit) &#123; tempProfit = profits[i-1][j-1]-price[j-1]; &#125; profits[i][j] = Math.max(profits[i][j-1], price[j]+tempProfit); &#125; 代码 public class StockProfitMax &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] price = &#123;3,3,0,5,3,1,4&#125;; System.out.println(MaxProfit(price,2)); &#125; public static int MaxProfit(int[] price, int times) &#123; int[][] profits = new int[times+1][price.length]; for(int i=1;i&lt;profits.length;i++) &#123; int tempProfit = -price[0]+profits[i-1][0]; for(int j=1;j&lt;profits[0].length;j++) &#123; if(profits[i-1][j-1]-price[j-1] &gt; tempProfit) &#123; tempProfit = profits[i-1][j-1]-price[j-1]; &#125; profits[i][j] = Math.max(profits[i][j-1], price[j]+tempProfit); &#125; &#125; return profits[profits.length-1][profits[0].length-1]; &#125; &#125; 剑指offer 3.1 数组中重复的数 （改变数组结构）题目找出数组中重复的数字。 在一个长度为n的数组里所有数字都在0~n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复，也不知道重复几次。找出数组中任意一个重复的数字。 输入：[2,3,1,0,2,5,3] 结果：2或3 分析由于所有成员数字都在0~n-1之间，我们可以根据数字找到对应的下标，让每个数字于其下标一致，若在移位过程中发现位置被占，则代表此数字重复。 这种解法时间复杂度为O(n)，空间复杂度为O(1) 代码 public static int SortArrMethod(int[] arr) &#123; for(int i=0;i&lt;arr.length;i++) &#123; int tmp =i; int tmp2; while(arr[tmp]!=tmp) &#123; tmp2 = arr[arr[tmp]]; if(tmp2 == arr[tmp]) return tmp2; arr[arr[tmp]] = arr[tmp]; tmp = tmp2; &#125; &#125; return -1; &#125; 虽然里面还有一个for循环，但是每个数字最多2次找到自己位置，所以时间复杂度还是O(n); 剑指offer 3.2 数组中重复的数 （数组结构不变）题目不修改数组找出重复数字 输入：[2,3,5,4,3,2,6,7] 结果：2或3 分析不改变原数组结构，需要重新再建一个数组，以哈希表的形式修改存储，由于数组中数字在0~n-1范围内，每增添一个，临时数组下标对应的值就+1；最后判断哪个下标的值&gt;=2，返回此数字； 这种方法的时间复杂度为O(n),空间复杂度为O(n) 代码 public static int hashMethod(int arr[]) &#123; int[] tempArr = new int[arr.length]; for(int i=0;i&lt;arr.length;i++) &#123; tempArr[arr[i]] +=1; &#125; for(int j=0;j&lt;tempArr.length;j++) &#123; if(tempArr[j] &gt;= 2) return j; &#125; return -1; &#125; 剑指offer 4 在二维数组中查找题目在二维数组中，每一行都按照从左到右递增，每一列都按照从上到下递增，输入一个二维数组和一个值，找出数组是否含有这个值 输入： 7 [1 2 8 9] [2 4 9 12] [4 7 10 13] [6 8 11 15] 结果：true 分析可以根据右上角数字的大小来压缩搜索范围，比如说第一行从右往左读取，8和9大于7，column-2, 2小于7，row+1, 根据第2行第2列，4小于7，再向下找，得出7，返回true 代码要注意考虑边界，左上角代表最小，右下角代表最大 public static boolean FindNum(int[][] arr, int num) &#123; int row=arr.length; int column = arr[0].length; if(arr[row-1][column-1] &lt;num) return false; else if(arr[row-1][column-1] ==num) return true; if(arr[0][0] &gt;num) return false; else if(arr[0][0] ==num) return true; for(int i=0;i&lt;row;i++) &#123; for(int j=column-1;j&gt;=0;j--) &#123; if(arr[i][j]&lt;num) row++; if(arr[i][j]&gt;num) column--; if(arr[i][j]==num) return true; &#125; &#125; return false; &#125; 剑指offer 5 替换空格题目实现一个函数将空格替换成%20 输入：”We are happy” 结果：“We%20are%20happy” 分析这道题适合使用C++来解，先读取原来字符串长度，再用while循环统计空格的个数，newlength = originLength + BlankNum*2; 使用2个指针，一个P1指向原字符串末尾，还有一个P2指向新的长度的末尾，P1每读取一个字符，P2将此字符串存起来，若遇到空格，则在P2前3个位置存放”%20“，结束条件是P1指向头 时间复杂度为O(n) 代码代码就不写了，java用数组可以实现 剑指offer 6 从尾到头打印链表题目输入一个链表，要求从尾到头打印此链表中的值 输入：ListA[a,b,c,d,e,f] 输出：f,e,d,c,b,a 分析（在不改变原链表的情况下）用递归可以基本实现实现，递归的本质就是栈。 退出递归的条件就是当读取的指针为空指针时，return 代码package PointOffer; public class PrintNodeReverse &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyLinkedList list = new MyLinkedList(); list.add(123); list.add(456); list.add(789); list.add(666); printNodesReverse(list); &#125; public static void printNodesReverse(MyLinkedList list) &#123; if(list == null || list.head == null) return; else &#123; printNodesReverse(list.head); &#125; &#125; private static void printNodesReverse(Node head) &#123; if(head == null) return; printNodesReverse(head.next); System.out.println(head.num); &#125; public static class MyLinkedList&#123; public Node head=null; public void add(int num) &#123; if(head == null) head = new Node(num, null); else &#123; Node cur = head; while(cur.next!=null) cur = cur.next; cur.next = new Node(num, null); &#125; &#125; &#125; private static class Node&#123; public int num; public Node next; Node(int num, Node next)&#123; this.num = num; this.next = next; &#125; &#125; &#125; 剑指offer 9 用2栈实现队列题目用2个栈实现1个队列，队列需要有2个函数：appendTail和deleteHead（在队列尾部插入，在队列头部删除） 输入队列：[a,b,c,d] 删除队列头：[b,c,d] 插入队列尾：[b,c,d,e] 分析2个栈（A和B）， 从尾部插入：直接将所有数据压入A栈 从队列中删除头部数据：先检查B是否为空，为空则从A中把A中的数据压入到B中，B再pop出一个数据，不为空则直接在B中pop； 代码package PointOffer; import java.util.Stack; public class StackAchieveQueue &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyQueue&lt;Character&gt; q = new MyQueue&lt;&gt;(); q.appendTail(&#39;a&#39;); q.appendTail(&#39;b&#39;); q.appendTail(&#39;c&#39;); System.out.println(q.deleteHead()); System.out.println(q.deleteHead()); System.out.println(q.deleteHead()); &#125; private static class MyQueue&lt;E&gt;&#123; private Stack&lt;E&gt; A; private Stack&lt;E&gt; B; public MyQueue() &#123; // TODO Auto-generated constructor stub this.A = new Stack&lt;&gt;(); this.B = new Stack&lt;&gt;(); &#125; public void appendTail(E element) &#123; A.push(element); &#125; public E deleteHead() &#123; if(B.isEmpty()) &#123; if(A.isEmpty()) return null; while(!A.empty()) &#123; B.push(A.pop()); &#125; &#125; return B.pop(); &#125; &#125; &#125; 剑指offer 10.1 斐波那契数列题目写一个函数，输入n，求斐波那契数列的第n项。 分析一般情况下大家都会使用递归来解决此问题 public static int Fibonacci(int n) &#123; if(n&lt;=0) return 0; else if(n==1) return 1; else &#123; return Fibonacci(n-1) + Fibonacci(n-2); &#125; &#125; 递归的实现方法是栈而当栈过多时，栈会溢出，此时程序崩溃；同时，使用递归求解问题有时会重复； 为了避免程序运行慢或者崩溃，求第n个斐波那契数列可以使用循环来完成 a = 0; b=1; for(i=2;i&lt;=n;i++){ ​ rst = a+b; ​ a =b; ​ b = rst; //向后移 } 代码 public static int Fibonacci2(int n) &#123; if(n&lt;=0) return 0; else if(n==1) return 1; else &#123; int a=0; int b=1; int rst=2; for(int i=2;i&lt;=n;i++) &#123; rst = a+b; a = b; b = rst; &#125; return rst; &#125; &#125; 剑指offer 10.2 青蛙跳台阶问题题目一只青蛙可以跳1个台阶，也可以跳2个台阶，求该青蛙跳n个台阶一共有多少种跳法？ 输入：0 输出：0 输入：1 输出：1 分析这道题可以看作是斐波那契数列的应用，当有0个台阶时，青蛙有0种跳法；有2个台阶时，青蛙可以选择连续跳1个台阶，也可以选择一下跳2个台阶； 假设青蛙跳n个台阶，结果是f(n)；当n&gt;2时，假设青蛙第一次跳1级台阶，青蛙有f(n-1)种跳法，假设第一次跳2级台阶，青蛙有f(n-2)种跳法，n级台阶有f(n) = f(n-1) + f(n-2)种跳法 这是斐波那契数列 0, 1, 2, 3, 5, 8 代码 public static int frog(int n) &#123; if(n&lt;=0) return 0; else if(n==1) return 1; else if(n==2) return 2; else &#123; int a=1; int b=2; int rst=3; for(int i=3;i&lt;=n;i++) &#123; rst = a+b; a = b; b = rst; &#125; return rst; &#125; &#125; 剑指offer 10.3 矩形覆盖问题题目有2*N大小的矩形需要用2*1的矩形覆盖，请问有多少种方法 分析这个也是斐波那契数列的应用，当n=8时，覆盖8列有f(8)种方法，图如下： 起初为了覆盖整个图，矩形从左覆盖时有2种选择：横着或竖着；若横着则还有f(6)种，若竖着则还有f(7)种，总共方法f(8) = f(7) + f(6)， 这是斐波那契数列 代码 public static int rect(int n) &#123; if(n&lt;=0) return 0; else if(n==1) return 1; else if(n==2) return 2; else &#123; int a=1; int b=2; int rst=3; for(int i=3;i&lt;=n;i++) &#123; rst = a+b; a = b; b = rst; &#125; return rst; &#125; &#125; 剑指offer 11 旋转数组的最小数字题目把一个数组最开始的若干元素搬到数组的末尾，这个称之为数组的旋转。 输入一个增序数组的旋转，输出旋转数组的最小元素； 输入：[5,1,2,3,4] 输出：1 分析一般会想到从头到尾遍历，但时间复杂度为O(n)，效率很低；一维平面（顺序表）可以选择二分查找，log(n) 通过观察我们发现，最小元素的左侧元素大于最小元素，最小元素右侧元素大于最小元素或者没有 步骤： 读取数组最右侧和第一个下标 如果最右侧元素小于倒数第二个元素，直接输出 选取中间的元素 若中间的元素小于等于左侧元素同时大于等于右侧元素，输出 没有，则缩小范围 考虑特殊情况，数组中有数字重复，如 {1,0,1,1,1} 输入：[5,5,1,1,2,3,3,4] 输出：1 当数组中有重复数字时，我们无法判断pivot属于前递增子数组，还是后递增子数组，因此我们只能从前往后遍历 代码输入数组中没有重复的数字 public static int getMin(int[] arr) &#123; int left=0; int right = arr.length-1; if(arr[right] &lt; arr[right-1]) return arr[right]; while(left &lt; right-1) &#123; int pivot = (left +right)/2; System.out.println(arr[left]+&quot; &quot;+arr[pivot]+&quot; &quot;+arr[right]); if(arr[pivot] &lt; arr[pivot-1] &amp;&amp; arr[pivot] &lt; arr[pivot+1]) return arr[pivot]; if(arr[pivot]&lt;arr[pivot+1]) right = pivot; if(arr[pivot]&gt;arr[pivot+1]) left = pivot; &#125; return arr[left]; &#125; 考虑数组中有重复的数字 public static int getMin2(int[] arr) &#123; int left=0; int right = arr.length-1; if(arr[right] &lt; arr[right-1]) return arr[right]; while(left &lt; right-1) &#123; int pivot = (left +right)/2; if(arr[left]==arr[pivot] &amp;&amp; arr[pivot] == arr[right]) return MinOrder(arr); if(arr[pivot] &lt; arr[pivot-1] &amp;&amp; arr[pivot] &lt; arr[pivot+1]) return arr[pivot]; if(arr[pivot]&lt;arr[pivot+1]) right = pivot; if(arr[pivot]&gt;arr[pivot+1]) left = pivot; &#125; return arr[left]; &#125; //从前往后遍历 public static int MinOrder(int[] arr) &#123; int small=0; for(int i=1;i&lt;arr.length;i++) &#123; if(arr[i]&lt;arr[small]) small =i; &#125; return arr[small]; &#125; 剑指offer 12 矩阵中的路径题目输入一条字符串，判断矩阵是否包含这条字符串路径，路径可以从任意1格开始，可以 (上,下,左,右) 移动，但不能走重复的路。 矩阵： ​ [a b t g] ​ [c f c s] ​ [j d e h] 输入：bfce 输出：true 输入：bfbd 输出：false 分析需要使用回溯算法来考虑每一种情况(因为需要寻找上下左右的坐标) 开始使用for循环，寻找起始坐标 找到坐标后获取下一批节点 读取节点查看是否包含path的下一个节点， 若遍历完还没有，则返回false；若遍历完还有，则获取此点的下一批节点（依次递归，知道结束） 代码 public static void TestForCanThrough() &#123; char[][] matrix= &#123; &#123;&#39;a&#39;,&#39;b&#39;,&#39;t&#39;,&#39;g&#39;&#125;, &#123;&#39;c&#39;,&#39;f&#39;,&#39;c&#39;,&#39;s&#39;&#125;, &#123;&#39;j&#39;,&#39;d&#39;,&#39;e&#39;,&#39;h&#39;&#125; &#125;; String path = &quot;cfbtcs&quot;; System.out.println(canThrough(matrix,path)); &#125; //输入字符串与路径矩阵 public static boolean canThrough(char[][] matrix, String p) &#123; char[] path = p.toCharArray(); boolean include = false; boolean[][] isVisited = new boolean[matrix.length][matrix[0].length]; LinkedList&lt;Node&lt;Character&gt;&gt; nexts = null; //找出起点 for(int i=0;i&lt;matrix.length;i++) &#123; for(int j=0;j&lt;matrix[0].length;j++) &#123; if(matrix[i][j] == path[index] &amp;&amp; isVisited[i][j] == false) &#123; isVisited[i][j] = true; include = true; nexts = getNext(i, j, matrix, isVisited); index++; break; &#125; &#125; &#125; if(include) &#123; return checkPath(nexts,path, index, matrix, isVisited); &#125; else &#123; return false; &#125; &#125; //递归检查输入的路径能否走通 public static boolean checkPath(LinkedList&lt;Node&lt;Character&gt;&gt; nexts, char[] path, int index, char[][] matrix,boolean[][] isVisited) &#123; if(index == path.length) return true; for(Node&lt;Character&gt; tmp:nexts) &#123; if(tmp.value == path[index]) &#123; return checkPath(getNext(tmp.r, tmp.c, matrix, isVisited), path, ++index, matrix, isVisited); &#125; &#125; return false; &#125; //获取上下左右能走的点 public static LinkedList&lt;Node&lt;Character&gt;&gt; getNext(int row, int column, char[][] matrix, boolean[][] isVisited)&#123; LinkedList&lt;Node&lt;Character&gt;&gt; nexts = new LinkedList&lt;&gt;(); if(row +1 &lt; matrix.length &amp;&amp; !isVisited[row+1][column]) nexts.add(new Node&lt;&gt;(row+1,column, matrix[row+1][column])); if(row -1 &gt;= 0 &amp;&amp; !isVisited[row-1][column]) nexts.add(new Node&lt;&gt;(row-1,column, matrix[row-1][column])); if(column +1 &lt; matrix[0].length &amp;&amp; !isVisited[row][column+1]) nexts.add(new Node&lt;&gt;(row,column+1, matrix[row][column+1])); if(column -1 &gt;= 0 &amp;&amp; !isVisited[row][column-1]) nexts.add(new Node&lt;&gt;(row,column-1, matrix[row][column-1])); return nexts; &#125; //创建节点 private static class Node&lt;E&gt;&#123; int r; int c; E value; Node(int row, int column, E v)&#123; r = row; c = column; value = v; &#125; &#125; 剑指offer 14 剪绳子题目有长度为n的绳子，把绳子剪为m段（n和m都是整数，n&gt;1,m&gt;1）,每段长度记为k[0], k[1], k[2]…k[m], （均为整数）,要求输出最大的每段长的乘积：max( k[0] * k[1] * … * k[m] ) 输入：n=8 输出：18 分析解法1：动态规划算法 （假设输入n=8） 动态规划算法从上往下分析问题，从下往上解决问题。 先将问题拆解，我们可以先考虑长度为2的绳子，剪成n段，最大长度乘积为多少； 再考虑长度为3的绳子，剪成n段，最大乘积为多少；我们把最大长度乘积存入到数组products中 当绳子长度大于3后，products[i] 可以是 前面任意长度的最大乘积的组合：比如在寻找max products[4]时，我们比较products[1]*products[3] 和 products[2]*products[2]，最后products[4]为最后比较的结果 max=0; for(int j=1;j&lt;=i/2;j++) &#123; int tmp = products[j]*products[i-j]; if(tmp &gt; max) max =tmp; products[i] = max; &#125; 解法2：贪婪算法 代码 public static int CutMethod1(int n) &#123; if(n&lt;2) return 0; else if(n==2) return 1; else if(n==3) return 2; int max; int[] products = new int[n+1]; products[0]=0; products[1]=1; products[2]=2; products[3]=3; //最大乘积可以分为2,2,3段 for(int i=4;i&lt;=n;i++) &#123; //从4开始到长度为n结束 max=0; for(int j=1;j&lt;=i/2;j++) &#123;//除以二是为了避免重复 int tmp = products[j]*products[i-j];//核心算法 if(tmp &gt; max) max =tmp; products[i] = max; &#125; &#125; return products[n]; &#125; 剑指offer 15 二进制中1的个数题目输入一个整数，输出这个整数二进制中1的个数 输入：9 (1001) 输出：2 分析一般会想到将二进制数右移进行与运算，若true则cnt++;但是考虑到负数进行右移运算可能会导致死循环，我们不得不采取左移求解。左移是将比较的变量左移，例如：我们假设flag = 1, flag和1001进行与运算，最开始为true, cnt++; 接着我们将flag左移（空位补零），接着按位与，while循环，直到flag全为0; 这种效率略微低下，要进行32次循环。 效率更高的一种方法： 当一个二进制数（原数）减1时，其第一个1前面的位都不变，1变为0，1后面的0变为1，此时我们可以对这个二进制的数和原数进行与运算 代码方法1（C++版本）： java无法进行按位与 int numOf1(int n)&#123; int cnt=0; unsigned int flag=1; while(flag)&#123; if(n &amp; flag) cnt++; flag = flag &lt;&lt; 1; &#125; return cnt; &#125; 方法2： int numOf1(int n)&#123; int cnt=0; while(n)&#123; cnt++; n = (n-1)&amp;n; &#125; return cnt; &#125; 剑指offer 16 数值的整数次方题目实现函数 double power(double base, int exponent), 求base 的exponent次方， exponent为整数 输入：base= 6, exponent=2 输出：36 分析exponent指数需要考虑负数的情况，一个数的负数次方为这个数次方的倒数，即1/n 当exponent为0时，所有数为1（0除外） 当exponent为1时，所有数是其本身 计算次方数1：使用循环 计算次方数2：使用公式（时间效率更高为log(N)） 代码方法1 public static double power(double power, int exponent) &#123; if(new BigDecimal(power).compareTo(new BigDecimal(0.0))==0 &amp;&amp; exponent ==0) &#123; return 0.0; &#125; if(exponent == 0) return 1.0; else if(exponent==1) return power; double rst=1; for(int i=0;i&lt;Math.abs(exponent);i++) rst *= power; if(exponent &lt;0) return 1.0/rst; return rst; &#125; 方法2 public static double power2(double base, int exponent) &#123; if(new BigDecimal(base).compareTo(new BigDecimal(0.0))==0 &amp;&amp; exponent ==0) return 0.0; double rst=cal(base, Math.abs(exponent)); if(exponent&lt;0) return 1.0/rst; return rst; &#125; public static double cal(double base, int exponent) &#123; if(exponent == 0) return 1.0; else if(exponent==1) return base; double rst= cal(base, exponent&gt;&gt;1); //右移表示除2 rst *= rst; if((exponent &amp; 0x1) ==1) //按位与判断奇偶 rst *= base; return rst; &#125; 剑指offer 18.2 删除链表中重复的节点题目在一个排序的链表中剔除重复的节点 分析需要2个指针，preNode还有curPoint; 本代码仅限删除偶数倍重复的数字 考虑头部重复情况 考虑中间重复情况 考虑尾部重复情况 代码 public static void delSameNodes(MyLinkedList list) &#123; if(list == null || list.head == null) return; else &#123; Node pre = list.head; Node cur = pre; while(cur != null) &#123; if(cur.num == cur.next.num) &#123; if(cur == list.head) &#123; list.head = cur.next.next; pre = list.head; cur = pre; continue; &#125; pre.next = cur.next.next; cur = pre.next; &#125; else &#123; cur = cur.next; if(cur.next==null) break; &#125; &#125; &#125; &#125; 剑指offer 20 表示数值的字符串题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数） 输入：+100 输出: true 输入：5e2 输出：true 输入：12e 输出：false 分析先要了解整数和小数的表达方式，整数包括正整数和负整数；小数也有正数和负数；小数中10可以有科学计数法（E或e)，科学计数法的指数可为正数与负数 正确的例子：+100, -123, 5e2, 3.14159, -1E-16, 先找出错误的情况：一般结尾以非数字结尾（直接排除） 我们把整个数分为3段（整数部分，小数部分，E部分），其中E部分后面不能包含小数 将小数部分细分，可分为小数点与整数，E部分同理 最终：有符号整数 . 整数 E 有符号整数 整数有时需要跳过符号，我们可以设计两个函数，前面一个函数用于有符号整数（跳过一个符号），后面一个用于无符号整数。有符号函数仅仅用于跳过一个符号，所以返回时还要利用无符号函数 代码package PointOffer; public class isNumeric &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String s=&quot;+6.66E-6&quot;; System.out.println(isNumber(s)); &#125; public static boolean isNumber(String number) &#123; //判空 if(number == null) return false; char[] s=number.toCharArray(); //直接判断最后一个是否为常规数字 if(s[s.length-1]&lt;=48 || s[s.length-1]&gt;=57) return false; //第一轮扫描，判断有符号整数，以小数点结束 int num = ScanInteger(0,s); //若返回的恰巧超出范围则读取结束 if(num&gt;=s.length-1) return true; //第二轮扫描，扫描小数后，判断是否为无符号整数，以非整数停止 if(s[num]==&#39;.&#39;) num = ScanUnsighInteger(++num, s); //若返回的恰巧超出范围则读取结束 if(num&gt;=s.length-1) return true; //第三轮扫描，扫描E后面的数是否为有符号整数 if(s[num]==&#39;E&#39; || s[num]==&#39;e&#39;) num = ScanInteger(++num,s); //若扫描完发现还有剩余的没扫完，则表示E后面是小数，false if(num&lt;number.length()-1) return false; else &#123; return true; &#125; &#125; //判断整数 public static int ScanInteger(int i, char[] s) &#123; if(s[i]==&#39;+&#39; || s[i]==&#39;-&#39;) i++; return ScanUnsighInteger(i, s); &#125; //无符号整数 public static int ScanUnsighInteger(int i, char[] s) &#123; while(i&lt;s.length &amp;&amp; s[i]&gt;=48 &amp;&amp; s[i]&lt;=57) i++; return i; &#125; &#125; 剑指offer 21 调整数组顺序使奇数位于偶数前面题目输入一批整数数组，调整数组中数字的顺序，使所有奇数位于数组的前半部分，使所有偶数位于数组的后半部分。 输入：【1,4,7,18,14,16,55】 输出：【1,7,55,4,18,14,16】 分析解法类似于快速排序 使用两个指针分别指向开头与结尾，左边的指针指向奇数时向右移动，右边指针指向偶数时向左移动，（指针移动条件必须是左指针在右指针左侧），然后两个指针指向的数字交换位置，继续 这里用到一个小知识点：与运算 num&amp;0x1!=0 偶数在二进制中以0结尾，奇数以1结尾，我们可以和0x1做与运算，若结果为1则为奇数，结果为0则为偶数 0 &amp; 1 = 0；1 &amp; 1 = 1 代码package PointOffer; import java.util.Arrays; public class SwitchOddAndEven &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr= &#123;1,2,3,4,5&#125;; SwitchNum(arr); System.out.println(Arrays.toString(arr)); &#125; public static void SwitchNum(int[] arr) &#123; int left=0; int right = arr.length-1; int tmp=0; while(left&lt;right) &#123; while((left&lt;right)&amp;&amp;(arr[left]&amp;0x1)!=0) left++; while((left&lt;right)&amp;&amp;(arr[right]&amp;0x1)==0) right--; if(left&lt;right) &#123; tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; &#125; &#125; 剑指offer 22 链表中倒数第k个节点题目输入一个链表，输出该链表中倒数第k个节点，从1开始计数 输入：1-&gt;2-&gt;3-&gt;4-&gt;5 , 2 输出：4 分析当第一眼看到这道题时，也许会想到递归，就像反向输出链表一样；但是递归不能告诉你倒数第几个，所以还是要用指针。 我们可以选取2个指针：一个在前，一个在后，两个相差k； 使用while循环将指针向后移动 当前面的指针到尾部null时，后面的指针刚好在倒数第k个位置，输出此时的节点的值。 我们其实还要考虑特殊情况，例如： k大于实际链表的长度 链表为空 代码 public static void PrintLastKth(MyLinkedList list, int k) &#123; //空链表 if(list == null) return; //设置指针 Node pre = list.head; Node aft = pre; //设置偏差 for(int i=0;i&lt;k;i++) &#123; pre = pre.next; //k大于list长度 if(pre==null &amp;&amp; i!=k-1) return; &#125; //循环向后移 while(pre!=null) &#123; pre = pre.next; aft = aft.next; &#125; //打印最终结果 System.out.println(aft.num); &#125; 剑指offer 25 合并两个排序链表题目输入两个链表（两个增序链表），合并两个链表形成第三个（依然是一个增序链表） 输入：1-&gt;3-&gt;5-&gt;10, 2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12 输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10-&gt;11-&gt;12 分析和归并排序很相似，我们需要比较两个链表中的数，然后再分配给第三个链表 1-&gt;3-&gt;5-&gt;10 2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12 当2个链表中的一个读取玩，直接把另一个剩余部分接入第三个链表 我们使用递归的方法解决这道题 第一步：1, 比较3-&gt;5-&gt;10 和 2-&gt;4-&gt;8-&gt;9-&gt;11-&gt;12 第二步：1-&gt;2, 比较3-&gt;5-&gt;10 和 4-&gt;8-&gt;9-&gt;11-&gt;12 第三步：1-&gt;2-&gt;3 , 比较5-&gt;10 和 4-&gt;8-&gt;9-&gt;11-&gt;12 …… 倒数第一步: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10, 比较null 与 11-&gt;12 最后：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;8-&gt;9-&gt;10-&gt;11-&gt;12 代码 public static void MergeList(MyLinkedList list1, MyLinkedList list2) &#123; printList(MergeList(list1.head, list2.head)); &#125; private static Node MergeList(Node n1, Node n2) &#123; if(n1==null) return n2; if(n2==null) return n1; Node NewHead = null; if(n1.num &lt; n2.num) &#123; NewHead = n1; //设置小的 NewHead.next = MergeList(n1.next, n2); &#125;else &#123; NewHead = n2; NewHead.next = MergeList(n1, n2.next); &#125; return NewHead; //返回头节点，这个头节点是上一个节点的下一个节点 &#125; 剑指offer 26 判断树的子结构题目输入两棵二叉树A和B，判断B是不是A的子结构 例子： 分析这仅仅是一个二叉树，二叉树问题一般使用递归来解决。 要判断A和B的结构，需要使用2个指针，一个给A，另一个给B。 若两指针指向的value相同，开始对比左右节点；反之，A的指针向左移，继续对比（类似于前序遍历） 设置2个函数，第一个用于判断镜像（返回boolean值），另一个用于判断每个节点的值是否相等（考虑到double类型数据） Attention：要注意二叉树判断有许多null，空指针的情况 代码 public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(CheckInclude()); &#125; public static boolean CheckInclude() &#123; BinaryNode[] heads=CreateBinaryTree(); PrintTree(heads[0]); System.out.println(); PrintTree(heads[1]); System.out.println(); return HasSubTree(heads[0], heads[1]); &#125; //正式判断A和B树 private static boolean HasSubTree(BinaryNode head1, BinaryNode head2) &#123; boolean rst = false; //进行递归的条件，左侧和右侧都不为null if(head1!=null &amp;&amp; head2!=null) &#123; //若开头就相等，进入向后递归函数 if(Equal(head1.value, head2.value)) &#123; rst = CheckTree(head1, head2); &#125; //若不相等，左递归 if(!rst) rst = HasSubTree(head1.left, head2); //左边判断完还是不相等，进行右递归 if(!rst) rst = HasSubTree(head1.right, head2); &#125; return rst; &#125; //上面判断相等之后进行下一步的判断 private static boolean CheckTree(BinaryNode head1, BinaryNode head2) &#123; //发现B到头，说明这一个部分已经找完 if(head2 == null) return true; //发现A到头，说明没找到，返回false if(head1==null) return false; //判断发现不相等，返回false if(!Equal(head1.value, head2.value)) return false; //一般情况下进行左递归和右递归，两者相同才返回true return CheckTree(head1.left, head2.left) &amp;&amp; CheckTree(head1.right, head2.right); &#125; //判断double数相等 private static boolean Equal(double num1, double num2) &#123; if(num1-num2 &lt;0.0000001 &amp;&amp; num1-num2 &gt;-0.0000001) return true; else &#123; return false; &#125; &#125; 剑指offer 27 二叉树的镜像题目输入一棵二叉树，输出它的镜像，即左右按照中间对调，例子如下 分析根据例子可以看出：每次镜像都是根据非叶子节点将其左子节点与右子节点进行对调； 递归操作，递归结束的条件是遍历到叶子节点（left == null &amp;&amp; right == null） 代码 public static void MirrorTree() &#123; BinaryNode head = CreateBinaryTree2(); PrintTree(head); MirrorTree(head); System.out.println(); PrintTree(head); &#125; //镜像翻转 private static void MirrorTree(BinaryNode head) &#123; //开始时此节点为空 if(head == null) return; //此节点为叶子节点 if(head.left ==null &amp;&amp; head.right==null) return; //非叶子节点交换其左子节点与右子节点 BinaryNode tmp = head.left; head.left = head.right; head.right = tmp; //交换完后，向左遍历 if(head.left !=null) MirrorTree(head.left); //对左边进行翻转后再对右侧进行翻转 if(head.right != null) MirrorTree(head.right); &#125; //创造二叉树（简单的二叉树） private static BinaryNode CreateBinaryTree2() &#123; BinaryNode head = new BinaryNode(8); head.left = new BinaryNode(6, new BinaryNode(5), new BinaryNode(7)); head.right = new BinaryNode(10, new BinaryNode(9), new BinaryNode(11)); return head; &#125; 剑指offer 28 判断对称二叉树题目判断二叉树是否是对称二叉树，例子如下 分析可以通过二叉树的前序遍历与对称二叉树的前序遍历来判断是否完全对称 以上面图为例：左侧的二叉树的前序遍历：657；右侧二叉树再进行前序遍历657(当左侧进入左子节点，右侧进入右子节点) 这道题考察对二叉树遍历的理解，了解判false的条件很重要 Attention判断条件： 若left和right同时为null， 返回true； 若head == null, 返回false； 若head.left == null || head.right == null, 返回false； 若left与right的value不相等，返回false; 若都相等，接着递归 代码 public static boolean IsSymetric() &#123; BinaryNode head = CreateBinaryTree3(); if(head == null) return false; return IsSymetric(head.left, head.right); &#125; private static boolean IsSymetric(BinaryNode left, BinaryNode right) &#123; if(left == null &amp;&amp; right == null) return true; if(left == null || right == null) return false; if(!Equal(left.value, right.value)) return false; //左侧与右侧同时遍历（左侧与右侧都相等） return IsSymetric(left.left, right.right)&amp;&amp; IsSymetric(left.right, right.left); &#125; //判断对称二叉树 private static BinaryNode CreateBinaryTree3() &#123; BinaryNode head = new BinaryNode(8); head.left = new BinaryNode(6, new BinaryNode(5), new BinaryNode(7)); head.right = new BinaryNode(6, new BinaryNode(7), new BinaryNode(5)); return head; &#125; 剑指offer 29 顺时针打印矩阵题目按照矩阵排布顺时针打印矩阵 输入： 输出：1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10 分析代码","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数学Maple使用手册","slug":"2021-10-17-数学Maple使用手册","date":"2021-10-17T04:00:00.000Z","updated":"2021-10-17T15:03:17.507Z","comments":true,"path":"2021-10-17-数学Maple使用手册/","link":"","permalink":"http://xiongy-rhit.github.io/2021-10-17-%E6%95%B0%E5%AD%A6Maple%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"介绍学习数学时需要用到名叫Maple的软件，但是有些指令不太熟悉，在网上也找不到中文教程，于是决定写下这篇blog，用于记录我学到的Maple指令","text":"介绍学习数学时需要用到名叫Maple的软件，但是有些指令不太熟悉，在网上也找不到中文教程，于是决定写下这篇blog，用于记录我学到的Maple指令 变量 Variable函数 Functionf(x):=a 化简 Simplicitysimplify() 求值 Valueevalf() subs() 极限 Limitlimit() 微分 Differential Derivativediff() 积分 Integrationint() 级数 Series矢量 Vector点乘 DotProduct 叉乘 CrossProduct 画图 Plotplot plot3d implicitplot3d SpaceCurve","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Maple","slug":"Maple","permalink":"http://xiongy-rhit.github.io/tags/Maple/"}]},{"title":"视频背景导航主页","slug":"2021-10-17-视频背景导航主页","date":"2021-10-17T04:00:00.000Z","updated":"2021-10-17T14:47:42.098Z","comments":true,"path":"2021-10-17-视频背景导航主页/","link":"","permalink":"http://xiongy-rhit.github.io/2021-10-17-%E8%A7%86%E9%A2%91%E8%83%8C%E6%99%AF%E5%AF%BC%E8%88%AA%E4%B8%BB%E9%A1%B5/","excerpt":"介绍展示一下最终效果（背景是动态的，截图无法展示出来）（https://peter-bear.github.io/wallpage/） 顶部有时钟显示，会根据此时的时间而变化；中间是搜索组件，输入www开头的网址能够直接进入对应网址，若输入其他的会自动进行百度搜索然后跳转；最下面是我自己常用的网址，点击可直接跳转。","text":"介绍展示一下最终效果（背景是动态的，截图无法展示出来）（https://peter-bear.github.io/wallpage/） 顶部有时钟显示，会根据此时的时间而变化；中间是搜索组件，输入www开头的网址能够直接进入对应网址，若输入其他的会自动进行百度搜索然后跳转；最下面是我自己常用的网址，点击可直接跳转。 HTML 部分&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;导航页面&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./reset.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;style&gt; *&#123; cursor: url(&quot;mouse.ani&quot;), auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--upper用于显示时间--&gt; &lt;div class=&quot;upper&quot;&gt; &lt;!--&lt;img src=&quot;./images/upperPic.png&quot; alt=&quot;&quot;&gt;--&gt; &lt;span id=&quot;nowTime&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;!--middle用于显示搜索栏--&gt; &lt;div class=&quot;middle&quot;&gt; &lt;form action=&quot;https://www.baidu.com/s&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;wd&quot; value=&quot;请输入网址........&quot; autocomplete =&quot;off&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;!--bottom用于陈列所有导航链接--&gt; &lt;div class=&quot;bottom clearfix&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;https://mail.qq.com/cgi-bin/loginpage&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/game_azurlane.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;QQ邮箱&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://www.runoob.com&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/terminal_emulator.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;菜鸟教程&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://www.aigei.com&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/picacomic.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;素材网&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://www.runoob.com/manual/jdk1.6&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/game_zjsn.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;JAVA api&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://b-ok.cc&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/game_cywl.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;Z-Library&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://www.dm530p.cc&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/mimikkoui.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;动漫&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://moodle.rose-hulman.edu/login/index.php&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/moe_bai.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;Moodle&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://outlook.office.com/mail/inbox&quot;&gt; &lt;div class=&quot;icons&quot;&gt;&lt;img src=&quot;./images/microsoft_outlook.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;urls&quot;&gt;邮箱&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--背景动态视频--&gt; &lt;div id=&quot;videoBorder&quot;&gt; &lt;video autoplay loop&gt; &lt;source src=&quot;https://firebasestorage.googleapis.com/v0/b/testproject-a9299.appspot.com/o/background.mp4?alt=media&amp;token=523f2101-b9ef-4d08-ae8e-91b6125cccfd&quot;&gt; &lt;/video&gt; &lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;!--时钟的js--&gt; &lt;script type=&quot;text/javascript&quot;&gt; var newDate = &#39;&#39;; getLangDate(); function dateFilter(date)&#123; //值小于10时，在前面补0 if(date &lt; 10)&#123; return &quot;0&quot;+date; &#125; return date; &#125; function getLangDate()&#123; var dateObj = new Date(); //表示当前系统时间的Date对象 var hour = dateObj.getHours(); //当前系统时间的小时值 var minute = dateObj.getMinutes(); //当前系统时间的分钟值 var second = dateObj.getSeconds(); //当前系统时间的秒钟值 var timeValue = &quot;&quot; +((hour &gt;= 12) ? (hour &gt;= 18) ? &quot;晚上&quot; : &quot;下午&quot; : &quot;上午&quot; ); //当前时间属于上午、晚上还是下午 newDate = dateFilter(hour)+&quot;:&quot;+dateFilter(minute) document.getElementById(&quot;nowTime&quot;).innerText = newDate; setTimeout(getLangDate,1000); &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS 部分reset.css (重置所有常用样式) html,body,div,span,applet,object,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video &#123; margin:0; padding:0; border:0; font-size:100%; font:inherit; font-weight:normal; vertical-align:baseline; text-decoration:none; &#125; /* HTML5 display-role reset for older browsers */ article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section &#123; display:block; &#125; ol,ul,li &#123; list-style:none; &#125; blockquote,q &#123; quotes:none; &#125; blockquote:before,blockquote:after,q:before,q:after &#123; content:&#39;&#39;; content:none; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; th,td &#123; vertical-align:middle; &#125; /* custom */ a &#123; outline:none; text-decoration:none; &#125; a:focus &#123; outline:none; &#125; input:focus,select:focus,textarea:focus &#123; outline:-webkit-focus-ring-color auto 0; &#125; index.css 对主页进行修饰 body&#123; /* width: 1200px; */ /* margin: 0 auto; */ /*默认有一个背景图片*/ background-image: url(./images/background.jpg); &#125; /*消除浮动带来的影响*/ .clearfix::before, .clearfix::after&#123; content: &#39;&#39;; display: table; clear: both; &#125; /*设置顶部（时钟）的区域*/ .upper&#123; width: 600px; height: 250px; margin: auto; margin-top: 50px; &#125; /*中间搜索框的外边框*/ .middle&#123; height: 40px; width: 640px; margin: auto; margin-top: 0px; &#125; /*中间搜索框的样式*/ .middle input&#123; border-style: none; height: 40px; width: 640px; border-radius: 20px; padding: 0 20px; color: #999; text-align: center; background-color: rgba(236, 228, 228, 0.829); &#125; /*底部样式*/ .bottom&#123; margin: 20px auto; width: 450px; &#125; /*底部链接样式*/ .bottom a&#123; font-weight: 400; /* color: #fff; */ color: rgba(253, 252, 252, 0.863); &#125; .bottom li&#123; float: left; width: 100px; height: 100px; margin: 5px 5px; background-color:transparent; &#125; /*修改导航图标样式*/ .icons&#123; background-color: #fff; margin-top: 16px; margin-left: auto; margin-right: auto; border-radius: 50%; height: 50px; width: 50px; overflow: hidden; &#125; .urls&#123; padding-top: 5px; width: 100px; text-align: center; &#125; .icons img&#123; width: 50px; height: 50px; &#125; /*时钟样式*/ #nowTime&#123; display: block; margin: auto 0px; margin-bottom: 0px; font-size: 100px; text-align: center; line-height: 200px; letter-spacing: 3px; font-family:Arial, Helvetica, sans-serif; color: rgba(255, 255, 255, 0.863); &#125; /*放置背景的外边框样式*/ #videoBorder&#123; position: absolute; top: 0; left: 0; bottom: 0; right: 0; /* width: 1920px; */ z-index: -1; overflow: hidden; &#125; /*视频的样式*/ #videoBorder &gt; video&#123; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; &#125; JS 部分index.js 部分用于处理搜索框的跳转 //1. 获取元素 var text = document.querySelector(&#39;input&#39;); //2. 注册事件,获得焦点事件 text.onfocus = function()&#123; if(this.value ==&#39;请输入网址........&#39;)&#123; this.value=&#39;&#39;; &#125; //将文本框颜色变为黑色 this.style.color = &#39;#333&#39;; &#125; //3. 注册事件，失去焦点 text.onblur = function()&#123; if(this.value==&#39;&#39;)&#123; this.value =&#39;请输入网址........&#39;; &#125; this.style.color = &#39;#999&#39;; &#125; text.addEventListener(&#39;keyup&#39;, function()&#123; if(text.value.indexOf(&quot;www.&quot;)==0)&#123; text.name=&#39;&#39;; document.querySelector(&#39;form&#39;).action = &quot;http://&quot;+text.value; &#125;else&#123; text.name=&#39;wd&#39;; document.querySelector(&#39;form&#39;).action =&quot;https://www.baidu.com/s&quot;; &#125; &#125;) 总结这个项目总体上而言，可以当作一个小屏保挂在显示器上。 本次小项目做完，对于css 的 margin, border, float等有了更深入的认识，知道如何使用居中样式; 这个项目有许多缺点： 导航图标等的链接完全可以使用JSON在JS中解决 代码有部分冗余，不完美 视频背景不够完美，无法自动播放，有时需要手动开启 有时自动播放，无法屏蔽声音","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://xiongy-rhit.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"静态网页","slug":"静态网页","permalink":"http://xiongy-rhit.github.io/tags/%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"}]},{"title":"Calculus 3-Partial Derivative","slug":"2021-10-15-Calculus-3-Partial-Derivative","date":"2021-10-15T04:00:00.000Z","updated":"2021-10-16T05:41:21.805Z","comments":true,"path":"2021-10-15-Calculus-3-Partial-Derivative/","link":"","permalink":"http://xiongy-rhit.github.io/2021-10-15-Calculus-3-Partial-Derivative/","excerpt":"介绍学习微积分的重点在微分与积分，正式进入微分后，我们将把微分与几何（前面学到的众多矢量）相结合。 本章将侧重在微分的操作上，如何计算极限；如何计算对应函数的偏微分；偏微分的应用：Gradient梯度；寻找判断某函数的（相对或绝对）最大、最小点；","text":"介绍学习微积分的重点在微分与积分，正式进入微分后，我们将把微分与几何（前面学到的众多矢量）相结合。 本章将侧重在微分的操作上，如何计算极限；如何计算对应函数的偏微分；偏微分的应用：Gradient梯度；寻找判断某函数的（相对或绝对）最大、最小点； 多变量函数（domain 和range）F(x) = x^2拥有1个变量x, 将此函数绘制出来，我们会得出一个二维平面的图像 当函数的变量扩展至2个及以上时，这便是多变量函数；而此时画出的图像将不再局限与2维平面，而是多维平面 F(x,y) = x^2 + y^2, 原来我们只有1个变量时，定义域Domain取决于那1个变量，值域Range也只是变量变化的范围 当变为多个变量，如2个时，定义域Domain应该是x的范围+y的范围，值域Range也是由于x与y的变化而变化 定义看一下精准的定义 Example2变量 3变量 极限Limit极限的计算与之前1个变量时的极限一样 连续 Continuous计算极限之前先判断此函数是否连续在此点 极限判断条件 判断极限在范围内不存在的条件 If we can find two paths upon which the function approaches different values as we get near the point then we will know that the limit doesn’t exist. 如果发现通过2条路线接近的是不同的点，则此极限不存在 Example极限在某点存在的情况 极限不存在的情况（判断） 偏微分Partial derivative偏微分的计算本质上是求极限，下面是定义 多变量的微分计算和之前1个变量的计算一样， 但是我们多变量求导只对某个特定方向求导：如f_x，是对x方向求导； f_y，是对y方向求导 希望这张图对理解有帮助 当我们求导计算时，另几个变量通常会被当做常数项处理 Example 通过上面的图，我们可以发现求指定方向的求导，其实是求函数在指定方向的tangent line的slope（切线斜率） 二次求导二次求导和1个变量的二次求导一样，同样我们要将其他的变量当作常数处理 有一点需要注意: Mixed Derivative Theorem若函数f(x,y)，f_x, f_y, f_xy, f_yx 存在点(a,b)，且在点(a,b)连续，则f_xy(a,b) = f_yx(a,b) Example (f_xy(a,b) != f_yx(a,b)) 链式法则chain rule多变量的链式法则与1个变量的链式法则有点不同（需要加起来） 为了方便做题，我们可以画一张图，如下 做题的时候，往上套就好；上面只显示2个变量，3个甚至多个同理 Example（1） 这道题要使用反推法 X = X(3,4) = 5 Y = Y(3,4) = 5 Z_v(3,4) = Z_v(u=3,v=4) = f_x(x=5,y=5) * X_v(u=3,v=4) + f_y(x=5,y=5) * Y_v(u=3,v=4) （2） 方向求导 directional derivatives沿着特定矢量u方向进行的求导（切线）（我们一般的求导是沿着x或y轴方向） 梯度Gradient与Directional Derivative之间的关系 Directional Derivative 与 Gradient变化 （**Max[Du.f]**） 水平面Level Surfacelevel surface可以看作是高维物体在低维空间的投影 3 维物体的level surface （level curve）在2 维平面上 4 维物体的level surface 在3 维平面上 举个例子 梯度Gradient 梯度是1个向量：在(x,y)点，刚好垂直与对应函数的level curve 相切平面等式the equation of the tangent planeTangent Plane 定义： 一个平面在某点与原函数相切 法线normal linenormal line在前面有见过，normal line就是垂直与平面的一个矢量 normal line的方向就是Gradient的方向 2个变量 z = f(x, y) Example 解题步骤： 找出surface的gradient 由于平行，tangent plane的normal line相互平行，surface 的 gradient之间的比例与tangent plane系数的比例相当 假设存在点(a, b, c)，根据比例带入surface等式， 得出a,b, c 线性估计linear approximation当我们得出一个函数在某点的slope斜率时，我们可以用它来估计周围的点 Example 最大点与最小点当我们只有1个变量时，求导可以帮助我们分析出此函数的Relative Max 或 Min，多个变量同样如此 首先我们要先找出 critical point Critical Point 当然我们找到critical point并不意味着我们就找到了Max或Min点，critical point也有可能什么都不是，这需要进一步判断 相对最大与最小Relative (Local) Max and Min 简单点说： D的另一种表示 把critical point带入这几类中进行判断 其中有个saddle point解释一下 绝对最大与最小 Absolute(Absolute) Max and Min绝对最大与最小是指在给定一个范围内，此函数的绝对最大或最小值可能是critical point，也有可能是在boundary上，也有可能都不是 判断方法 找出原来函数的critical point 通过给定范围找出x与y或其他变量间的关系，形成1个函数，找出此函数的critical point 找出boundary 上的点 带入原函数，检查这些点的大小 Examples（1） Relative Max and Min (2) Absolute Max and Min (3) Absolute Max and Min","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://xiongy-rhit.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"Calculus 3-Vector Application","slug":"2021-10-3-Calculus-3-Vector-Application","date":"2021-10-03T04:00:00.000Z","updated":"2021-10-04T02:01:53.369Z","comments":true,"path":"2021-10-3-Calculus-3-Vector-Application/","link":"","permalink":"http://xiongy-rhit.github.io/2021-10-3-Calculus-3-Vector-Application/","excerpt":"介绍矢量也可以被进行参数化，如之前提到的Line Equation,线等式其实也是矢量进行参数化的一种表现形式。若我们将矢量进行参数化，我们就能用矢量方程去模拟X,Y,Z平面的物体运动变化。本节将介绍矢量方程以及随着矢量方程衍生的其他矢量。","text":"介绍矢量也可以被进行参数化，如之前提到的Line Equation,线等式其实也是矢量进行参数化的一种表现形式。若我们将矢量进行参数化，我们就能用矢量方程去模拟X,Y,Z平面的物体运动变化。本节将介绍矢量方程以及随着矢量方程衍生的其他矢量。 矢量方程 Vector Function 矢量方程，r(t), x,y,z方向变化随着参数t变化而变化 矢量方程x,y,z各个方向都有指定的函数，如f(t), g(t), h(t). 矢量方程同样可以进行求导，求积分，算极限 极限 求导 矢量方程的求导法则 求积分 Arc Length In The Space计算线段在空间中随着时间所行走的长度 化简 换句话 Unit Tangent Vector and Unit Normal Vector Unit Normal Vector Normal 和 Tangent 在图中的表现形式 （T的方向与V速度的方向一致）： Curvature 一般计算Curvature都是通过电脑maple计算，Curvature(r(t)) k = 1/ R, 直线的curvature为1 AccelerationAcceleration其实分为Tangential Acceleration 与 Normal Acceleration (分别对应Tangent方向与Normal方向) |v|是speed， 速率 d|v|/dt 是the rate of speed, speed up or slow aT 为tangential 方向的acceleration大小 aN为normal方向acceleration大小 Questions and Examples下面是关于Acceleration和Tangential Vector与Normal Vector的例题 Q1 A satellite is travelling at a constant speed in a circular orbit 400 miles above the surface of earth where the acceleration of gravity is g = 30 ft/s^2. What is the speed of the satellite ? (Assumptions: radius of the earth 4000 miles; 1 mile is 5280ft) Q2 At a point P in the xy-plane, where distances are measured in meters, the unit tangent vector of an object’s path is &lt;3/5, 4/5&gt;, the curvature is 1 meter^-1, and its acceleration vector is &lt;3,5&gt; meters/second^2. At what rate is the object changing speed at P? What is the object’s speed at P? Q3 An object is traveling in a clockwise direction around the ellipse 4x^2+9y^2 = 36. When it reaches the point x =0, y=2 meters, its acceleration vector is 3i+5j meter/s^2. What is its speed and at what rate is it speeding up or slowing down at that time? Q4 What is the maximum magnitude of the force required to cause an 5kg object to move at a constant speed of 4 meters/second along the parabola y = x^2?","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://xiongy-rhit.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"Calculus 3-Vector Introduction","slug":"2021-9-9-Calculus-3-Vector-Introduction","date":"2021-09-09T04:00:00.000Z","updated":"2021-09-12T22:44:05.837Z","comments":true,"path":"2021-9-9-Calculus-3-Vector-Introduction/","link":"","permalink":"http://xiongy-rhit.github.io/2021-9-9-Calculus-3-Vector-Introduction/","excerpt":"介绍微积分3内容主要是围绕多维空间展开，本章节为矢量引入，将包含unit vector (单位向量), dot product (点乘), cross product (叉乘), line and plane equation (如何通过矢量获得线等式和平面等式)","text":"介绍微积分3内容主要是围绕多维空间展开，本章节为矢量引入，将包含unit vector (单位向量), dot product (点乘), cross product (叉乘), line and plane equation (如何通过矢量获得线等式和平面等式) Vector矢量英文名Vector, 用于表示一个变量或常量在空间中的方向与大小； 我们在空间中任取2个点 P(0, 0) 和 Q(2, 2)，由于矢量具有方向，我们计算矢量PQ$$\\vec{PQ} = ,&lt;2-0, 2-0&gt;, = ,&lt;2,,2&gt;\\表示从P到Q点\\\\vec{QP} = ,&lt;0-2, 0-2&gt;, = ,&lt;-2,,-2&gt;\\表示从Q到P点$$ 我们在空间中画矢量，通常以原点(original Point)为起点绘画，如图 下面的是在三维矢量的图片 //maple 代码 with(VectorCalculus) v := &lt;2, 2, 2&gt; PlotVector(v, color = red) 三维世界中我们用 i, j, k 分别代表x, y, z轴方向,二维平面亦如此，所以 矢量v写作：$$\\vec{v} = 2i+2j+2k,或\\ \\vec{v} = &lt;2, 2, 2&gt;$$意思是，矢量v在x 轴方向大小2, 在y轴方向大小2, 在z轴方向大小2 矢量之间也能做加减$$\\vec{v} + \\vec{w} = &lt;v_1+w_1, v_2+w_2, v_3+w_3&gt;\\\\vec{v} - \\vec{w}= &lt;v_1-w_1, v_2-w_2, v_3-w_3&gt;\\c*(\\vec{v}+\\vec{w}) = c\\vec{v} + c\\vec{w}$$矢量的长度和：与计算勾股定理斜边长类似，可以说无论三维还是二维计算矢量长度本质上都是勾股定理 以上面矢量 w=&lt;2,2&gt; 和 v =&lt;2,2,2&gt; 为例$$||\\vec{w}|| = \\sqrt{2^2+2^2} = 2\\sqrt{2}\\||\\vec{v}|| = \\sqrt{2^2+2^2+2^2} = 2\\sqrt{3}$$一般式子$$||\\vec{v}|| = \\sqrt{a^2+b^2+c^2}$$ Unit VectorUnit Vector 是单位向量（通常可用来表示一个向量的方向），指长度为1的向量。最常见的单位向量便是坐标轴的单位$$&lt;1, 0, 0&gt;\\&lt;0, 1, 0&gt;\\&lt;0, 0, 1&gt;$$ 我们还可以根据公式得出任意矢量的单位向量$$\\vec{u}, =,\\frac{\\vec{v}}{||\\vec{v}||}$$例子：$$\\vec{v}=&lt;2,2,2&gt;, ;求;unit;vector\\\\vec{u}=\\frac{&lt;2,2,2&gt;}{\\sqrt{2^2+2^2+2^2}},=&lt;\\frac{1}{\\sqrt{3}},, \\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}},&gt;$$ Dot Product点乘$$\\vec{v}\\cdot\\vec{w}=v_1w_1+v_2w_2+v_2w_2=||\\vec{v}||||\\vec{w}||*cos(\\theta)$$通过点乘，我们还可以判断两个矢量是否相互垂直，因为cos(theta)，两矢量的夹角，若夹角为90度，即垂直cos=0, 点乘结果为0，所以在u和v不为0的情况下，u与v相互垂直 矢量投影求矢量u在矢量v上的投影，首先我们要知道v的方向，这个可以用单位向量表示，矢量u的大小乘以cos夹角刚好可以得出投影的大小，最后总结出来的公式如下：$$proj_v\\vec{u} = (||\\vec{u}||*cos(\\theta))*\\frac{\\vec{v}}{||\\vec{v}||}\\=(\\frac{\\vec{u}\\cdot\\vec{v}}{||\\vec{v}||})*\\frac{\\vec{v}}{||\\vec{v}||}\\=(\\frac{\\vec{u}\\cdot\\vec{v}}{||\\vec{v}||^2})*\\vec{v}$$u在v上的投影是与v平行的，如图所示 若要求垂直的部分$$垂直部分结果,=\\vec{u}-proj_v\\vec{u}$$ Cross Product叉乘$$\\vec{w}\\times\\vec{v} = \\begin{matrix}i&amp;j&amp;k\\w_1&amp;w_2&amp;w_3\\v_1&amp;v_2&amp;v_3\\end{matrix}=(w_2v_3-v_2w_3)i-(w_1v_3-w_3v_1)j+(w_1v_2-w_2v_1)k$$ 叉乘的结果在图上表示 蓝色的就是叉乘的结果，红色与黄色是原来的矢量 叉乘前后矢量的顺序不一样会导致结果大小相同，方向不同$$\\vec{v}\\times\\vec{w} \\neq\\vec{w}\\times\\vec{v}$$ 常见的叉乘公式 叉乘的几何意义 dot product 与 cross product相结合，计算平行四边体的体积 Line And Plane Equation本节是关于线与平面的等式 Line Equation当我们确定线上的2个点或者知道1个点与线的方向时，我们可以从中得出这条线的等式(方程，参数方程) 例题 已知P(2,3,4), Q(6,8,9) 求PQ所在直线的线性等式$$先找出方向\\\\vec{PQ}=&lt;6-2,8-3,9-4&gt;\\=:&lt;4,5,5&gt;\\选P或者Q带入公式中\\r(t)=&lt;2,3,4&gt;+t*&lt;4,5,5&gt;=&lt;4t+2，5t+3,5t+4&gt;$$ Line Equation的几何现实意义 通过这个等式，我们可以得出任何时间在此直线上点的坐标 求点到线段的距离 从图上我们可以看出要求s到p所在直线的距离，即求PS的正弦距离，叉乘中有运用正弦角 所以： Plane Equation得出plane equation的过程：根据2个矢量相互垂直等于0 推到过程 最后Equation$$Ax,+By,+Cz,-Ax_0,-By_0,-Cz_0,=0\\Ax,+By,+Cz, = Ax_0,+By_0,+Cz_0\\Ax,+By,+Cz, = D$$ 求点到平面的距离这种问题通过图片可以很直观地找出解决方法 求S点到P点所在平面（3x+2y+6z=6）的距离，其实就是找矢量PS在矢量n方向的投影","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"http://xiongy-rhit.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"}]},{"title":"JAVA局域网聊天小程序","slug":"2021-08-23-JAVA局域网聊天小程序","date":"2021-08-23T04:00:00.000Z","updated":"2021-08-25T01:55:09.456Z","comments":true,"path":"2021-08-23-JAVA局域网聊天小程序/","link":"","permalink":"http://xiongy-rhit.github.io/2021-08-23-JAVA%E5%B1%80%E5%9F%9F%E7%BD%91%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"（局域网聊天）TCP/IP协议的局域网Socket通信简介马上开学了，闲着没事做，决定重新温习JAVA功课，于是想起了曾经见过的一个项目：基于JAVA语言的局域网通信，可以参考QQ，如下","text":"（局域网聊天）TCP/IP协议的局域网Socket通信简介马上开学了，闲着没事做，决定重新温习JAVA功课，于是想起了曾经见过的一个项目：基于JAVA语言的局域网通信，可以参考QQ，如下 一级菜单 二级菜单 由于本身水平以及开发工具的限制，只能以简单的控制台来模拟程序，但是麻雀虽小五脏俱全。 和上面表现的一样，控制台的程序同样拥有一级菜单（登录之后的选项）和二级菜单（聊天界面） 考虑到开发的时间，本程序登录不需要用户名与密码，开启程序后即可连接服务器；用户聊天时根据IP与电脑名来查找聊天对象。 完成此项目需要对多线程有所了解，Socket的网络知识，对象流的IO，序列化知识的初步了解，JAVA基础知识 步骤讲解写程序前要先构思画图确认方案之后再进行编码，所以我先把后期的画面使用画图软件确认下来。 view一级菜单如下： 二级菜单： 原理局域网通信是典型的Client - Server情形, 我们可以有多个客户端连接同一个服务器，所以服务器端始终保持着多个Socket线程， 而Client也能够拥有多个线程：一个用于聊天，一个用于传输文件(由于最近时间有限，尚未增添此功能，不过和上面服务器操作有异曲同工之妙，之后讲解可能有讲到，但程序中并未添加此功能)。 我们的客户端接收信息是一个动态的过程，我们可以在聊天面板打开时接收信息，也可以在刚登陆时接收信息，因此这也需要线程的知识； 说了这么多，还是直接画张图明白： T代表线程，Socket代表传输信息的通道，当我们想要把一段数据发给其他人时，我们其实是先把数据发给服务器，以服务器为中转再将内容发给接收者（看上面的信息数据传输箭头） 类对象看着上面的图我们可以想到之后可能要创建的class类对象 客户端 服务端 程序分析确定完之前的一些东西之后，要开始编码 我将程序分为客户端与服务端两部分 客户端User当用户打开程序时，程序会自动创建一个User类，此类储存了用户的IP地址和用户电脑的Local Host Name, 这样会方便之后使用。 package com.peter.Modle; import java.net.InetAddress; import java.net.NetworkInterface; import java.net.SocketException; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.Enumeration; public class User &#123; private String UID = &quot;127.0.0.1&quot;; private String Uname=null; public User()&#123; /* * 考虑到我的电脑安装了虚拟机，需要检查具体的IP，所以下面的程序用于扫描本机所有网络端口，根据需要选择相应的ip * */ try &#123; Uname = InetAddress.getLocalHost().getHostName(); //获取主机名 &#125; catch (UnknownHostException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; Enumeration&lt;NetworkInterface&gt; i =null; try &#123; i = NetworkInterface.getNetworkInterfaces(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; ArrayList&lt;String&gt; IPlist = new ArrayList&lt;&gt;(); while(i.hasMoreElements()) &#123; NetworkInterface n = i.nextElement(); Enumeration&lt;InetAddress&gt; ea = n.getInetAddresses(); while(ea.hasMoreElements()) &#123; InetAddress a = ea.nextElement(); if(a.getHostAddress().toCharArray()[3] ==&#39;.&#39;) &#123; IPlist.add(a.getHostAddress()); &#125; &#125; &#125; //选取对应的IP(根据自己的要求) for(String ip:IPlist) &#123; if(ip.indexOf(&quot;137.&quot;)!=-1) &#123; UID = ip; break; &#125; if(ip.indexOf(&quot;192.&quot;)!=-1) &#123; UID = ip; &#125; &#125; &#125; //获取ID public String getUID() &#123; return UID; &#125; //获取主机名 public String getUname() &#123; return Uname; &#125; &#125; MessageType这是一个接口，接口中的变量都是public static final, 所以可以用来储存一些数据，比如每个数字都有自己的含义。 package com.peter.Modle; //方便判断 public interface MessageType &#123; int allUsers = 0; int chat = 1; int sendFile = 2; int getFile = 3; int connect = 4; int exit = 9; &#125; MessageMessage是用于客户端向服务器传递信息的载体，里面包括了获取在线用户的容器[ArrayList], 告诉计算机我们要做什么的MessageType(MT), 有Sender和Receiver，还有最重要的Words，这些信息都承载在一个Message对象中，最后要通过Socket的outputStream写给服务器；为保证Message类能够在服务器中正常被读取，我们采用序列化操作，继承Serializable接口，储存了SerialVersionUID. package com.peter.Modle; import java.io.Serializable; import java.util.ArrayList; import java.util.Map; import java.util.Set; public class Message implements Serializable&#123; private static final long serialVersionUID = 1L; private String words=null; private int MT = 9; private String sender=null; private String receiver=null; private ArrayList&lt;String&gt; users =null; public ArrayList&lt;String&gt; getUsers() &#123; return users; &#125; public void setUsers(ArrayList&lt;String&gt; users) &#123; this.users = users; &#125; public String getSender() &#123; return sender; &#125; public void setSender(String sender) &#123; this.sender = sender; &#125; public String getReceiver() &#123; return receiver; &#125; public void setReceiver(String receiver) &#123; this.receiver = receiver; &#125; public String getWords() &#123; return words; &#125; public void setWords(String words) &#123; this.words = words; &#125; public int getMT() &#123; return MT; &#125; public void setMT(int mT) &#123; MT = mT; &#125; &#125; UserThread用户的线程，每个客户端的开启可以看作是一个进程，main函数是主进程，我们为了让用户开启程序就能接收到消息，任何时候都能接收到消息😉，于是启用多线程服务，UserThread就是一个线程 package com.peter.Modle; import java.io.IOException; import java.io.ObjectInputStream; import java.net.Socket; import java.util.ArrayList; import java.util.Map; import java.util.Set; //用户线程类，用于接收服务器发送过来的信息 public class UserThread extends Thread&#123;//此线程继承Thread类 private Socket UserSocket=null; private static ArrayList&lt;String&gt; allUsers=null; private static ArrayList&lt;String&gt; ChatContent=new ArrayList&lt;&gt;(); //allUsers 和 ChatContent都使用静态变量的原因是：一旦程序开启，他们就可以一直全局访问 public UserThread(Socket us) &#123; UserSocket = us; &#125; public Socket getUserSocket() &#123; return UserSocket; &#125; public ArrayList&lt;String&gt; getAllUsers() &#123; return allUsers; &#125; public ArrayList&lt;String&gt; getContent()&#123; return ChatContent; &#125; //重写Run方法 @Override public void run() &#123; //使用循环表示一直在运行，不然这个线程执行一遍后就不执行了 while(true) &#123; ObjectInputStream ois; try &#123; ois = new ObjectInputStream(UserSocket.getInputStream()); Message mms = (Message)ois.readObject(); //如果服务器没有发送数据，通道会一直阻塞 //服务器向用户发送的message是allUser if(mms.getMT() == MessageType.allUsers) &#123; UserThread.allUsers = mms.getUsers(); //发送但是信息 &#125;else if(mms.getMT() == MessageType.chat) &#123; ChatContent.add(mms.getSender()+&quot; 对 &quot;+mms.getReceiver()+&quot; 说:\\n &quot;+mms.getWords()); System.out.println(&quot;过往信息：&quot;); //显示过往消息信息 for(String chatContent:ChatContent) System.out.println(chatContent); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; UserConnectService开始用户需要将电脑连接到服务器，以此来构建Socket通信,并开启线程 public static void ConnectToServer() &#123; try &#123; //137.112.237.25是服务器所在IP，10086是监听端口 UserSocket = new Socket(&quot;137.112.237.25&quot;, 10086); //创建Message对象，在这个载体中写入我们的信息 Message message = new Message(); message.setMT(MessageType.connect); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); //输出流将message对象写给服务器端 ObjectOutputStream output = new ObjectOutputStream(UserSocket.getOutputStream()); output.writeObject(message); //我们把这个建立连接的Socket放入到线程，持续监听服务器发送的信息 userThread = new UserThread(UserSocket); userThread.start();//别忘了开启线程 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 获取在线用户的IP和名称 //获取在线用户IP public static ArrayList&lt;String&gt; GetAllIP() &#123; //建立Message对象 Message message = new Message(); message.setMT(MessageType.allUsers); //这个是为了方便服务器判断IP，这样就不会发送本机的IP了 message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); try &#123; //发送 ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); //等待接收IP，网络有延迟 if(userThread.getAllUsers() == null) &#123; Thread.sleep(5000); &#125; //等一会之后还没有就返回空 if(userThread.getAllUsers() == null) return null; return userThread.getAllUsers(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125; 向指定用户传输信息 这里我们要输入对应的IP地址和信息，由于是Service，我做成了一个静态方法，方便之后在Menus（View）中调用。 //向指定用户传输信息 public static String SendChatContent(String receiver, String words)&#123; //同上 Message message = new Message(); message.setMT(MessageType.chat); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); message.setReceiver(receiver); //我们要加入发送的时间 Date date = new Date(); message.setWords(words+&quot;\\t&quot;+date.toString()); try &#123; ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); String words1 = message.getSender()+&quot; 对 &quot;+message.getReceiver()+&quot; 说:\\n &quot;+message.getWords(); //userThread.getContent().add(words1); //返回发送的内容，到时候在View控制台中打印出来 return words1; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return &quot;连接超时，信息未发送&quot;; &#125; 退出服务 退出之前我们要告诉服务器我们要退出了，让服务器在服务器中删除我们的线程，关闭我们的Socket通道，我们然后直接退出。 //退出服务 public static void Exit() &#123; //向服务器发送退出指令 Message message = new Message(); message.setMT(MessageType.exit); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); try &#123; ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); System.exit(0);//系统退出 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; UserConnectService 全部代码，都是public static method package com.peter.Service; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; import java.util.ArrayList; import java.util.Date; import java.util.Map; import java.util.Set; import com.peter.Modle.Message; import com.peter.Modle.MessageType; import com.peter.Modle.User; import com.peter.Modle.UserThread; public class UserConnectService &#123; private static Socket UserSocket = null; private static User user= new User(); private static UserThread userThread; public static void ConnectToServer() &#123; try &#123; UserSocket = new Socket(&quot;137.112.237.25&quot;, 10086); Message message = new Message(); message.setMT(MessageType.connect); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); ObjectOutputStream output = new ObjectOutputStream(UserSocket.getOutputStream()); output.writeObject(message); userThread = new UserThread(UserSocket); userThread.start(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //获取在线用户IP public static ArrayList&lt;String&gt; GetAllIP() &#123; Message message = new Message(); message.setMT(MessageType.allUsers); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); try &#123; ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); //等待发送IP if(userThread.getAllUsers() == null) &#123; Thread.sleep(5000); &#125; if(userThread.getAllUsers() == null) return null; return userThread.getAllUsers(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return null; &#125; //向指定用户传输信息 public static String SendChatContent(String receiver, String words)&#123; Message message = new Message(); message.setMT(MessageType.chat); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); message.setReceiver(receiver); Date date = new Date(); message.setWords(words+&quot;\\t&quot;+date.toString()); try &#123; ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); String words1 = message.getSender()+&quot; 对 &quot;+message.getReceiver()+&quot; 说:\\n &quot;+message.getWords(); userThread.getContent().add(words1); return words1; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return &quot;连接超时，信息未发送&quot;; &#125; //退出服务 public static void Exit() &#123; //向服务器发送退出指令 Message message = new Message(); message.setMT(MessageType.exit); message.setSender(user.getUname()+&quot;:&quot;+user.getUID()); try &#123; ObjectOutputStream output = new ObjectOutputStream(userThread.getUserSocket().getOutputStream()); output.writeObject(message); System.exit(0);//系统退出 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; Menusmenus是菜单，一级菜单，二级菜单的显示都在这里，可以说是显示层 package com.peter.View; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; import com.peter.Service.UserConnectService; import java.util.Scanner; import java.util.Set; public class Menus &#123; //到时候测试类调用Start方法就好 public static void Start() &#123; FirstMenu(); &#125; //显示一级菜单 private static void FirstMenu() &#123; boolean open =true; Scanner input =null; UserConnectService.ConnectToServer(); //一级菜单使用循环，若退出则循环终止 while(open) &#123; System.out.println(&quot;\\n\\n====聊天一级菜单====&quot;); System.out.println(&quot;\\t1. 聊天面版&quot;); System.out.println(&quot;\\t4.退出&quot;); System.out.print(&quot; 选择：&quot;); input = new Scanner(System.in); switch (input.next()) &#123; case &quot;1&quot;: Chatting(input); break; case &quot;4&quot;: UserConnectService.Exit(); open = false; break; default: break; &#125; &#125; input.close(); &#125; //二级菜单 private static void Chatting(Scanner input) &#123; boolean open = true; //同样使用循环控制，方便持续交流 while(open) &#123; System.out.println(&quot;\\n\\n====聊天二级菜单(聊天面板)====&quot;); System.out.println(&quot;在线联系人如下：&quot;); //内容的获取都是根据之前的UserConnectService工具类来获得 ArrayList&lt;String&gt; tmpSet = UserConnectService.GetAllIP(); //若无在线用户，直接不让用户进行交流 if(tmpSet == null) &#123; System.out.println(&quot;暂时无上线用户&quot;); open = false; &#125;else &#123; //有则进行下一步，打印在线用户 for(String tmp: tmpSet) &#123; System.out.println(tmp); &#125; System.out.println(&quot;\\n\\t1.选择人聊天&quot;); System.out.println(&quot;\\t2.退出&quot;); System.out.print(&quot;你的选择：&quot;); String choice = input.next(); input.reset();//为避免scanner的问题，使用reset重启方法 switch (choice) &#123; case &quot;1&quot;: System.out.print(&quot;聊天对象的IP：&quot;); String receiver = input.next(); input.reset(); System.out.print(&quot;想说的话：&quot;); input.nextLine();//吃掉一个\\n String words = input.nextLine(); input.reset(); //打印刚才发送的信息 System.out.println(UserConnectService.SendChatContent(receiver, words)); break; case &quot;2&quot;: open = false; break; default: break; &#125; &#125; &#125; &#125; &#125; 服务端Terminal服务器终端类，用于控制服务器的开启，需要开启服务器端先实例化一个Terminal对象，传入服务器监听端口 服务器端是一直进行while循环，用于持续监听是否有新的连接 package com.peter.Modle; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.ServerSocket; import java.net.Socket; /* * 服务器类 * * */ public class Terminal &#123; private ServerSocket listener; //用于监听端口 public Terminal(int port)&#123; try &#123; System.out.println(&quot;服务器Start&quot;); listener = new ServerSocket(port); //确认端口 Socket accept; //连接的Socket通道 while(true) &#123; accept = listener.accept(); //建立通道连接 //获取连接后将此socket通道放入线程和线程池中进行管理 ObjectInputStream input = new ObjectInputStream(accept.getInputStream()); Message message = (Message)input.readObject();//开始时判断是否是在登录 if(message.getMT() == MessageType.connect) &#123; ServerThread thread = new ServerThread(accept, message.getSender()); System.out.println(message.getSender()+&quot;上线了&quot;); thread.start();//开启线程 ManageClientThreads.addThread(message.getSender(), thread);//加入到线程池中 &#125; &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; ServerThread服务器的线程类，和客户端的线程类一样， package com.peter.Modle; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.net.Socket; import com.peter.Service.ShowOnline; public class ServerThread extends Thread&#123; private Socket socket; private String UID; //在服务器端管理的线程，每个线程有对应的UID public ServerThread(Socket s, String id) &#123; socket = s; UID =id; &#125; public String getUID() &#123; return UID; &#125; public Socket getSocket() &#123; return socket; &#125; @Override public void run() &#123; //使用循环，使此socket线程一直保持监听状态，若没有内容发过来，则阻塞在此 while(true) &#123; Message message; try &#123; ObjectInputStream input = new ObjectInputStream(socket.getInputStream()); message = (Message)input.readObject(); //判断发送过来的内容 if(message.getMT()==MessageType.allUsers) &#123; //请求所有在线用户 System.out.println(UID+&quot;向服务器请求在线用户&quot;); message.setUsers(ShowOnline.getAllIP(UID)); ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(message); &#125; else if(message.getMT() == MessageType.chat) &#123;//A用户请求与B用户通信 String receiver = message.getReceiver(); ServerThread receiverThread = ManageClientThreads.getThread(receiver);//我们先根据B用户的名称找到B用户的线程 System.out.println(message.getSender()+&quot;向&quot;+receiver+&quot;发送:\\n&quot;+message.getWords()); //判断一下此用户是否存在 if(receiverThread!=null) &#123; ObjectOutputStream output = new ObjectOutputStream(receiverThread.getSocket().getOutputStream()); output.writeObject(message); &#125;else &#123; //若不存在，这个怎么处理还没写 &#125; &#125; else if(message.getMT()==MessageType.exit) &#123; //请求退出 //退出时从线程池中删除，将socket通道关闭 ManageClientThreads.delThread(UID); socket.close(); System.out.println(message.getSender()+&quot;退出&quot;); break; //终止循环 &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; ManageClientThreads线程池，管理线程，对线程进行增删查 每个线程被储存在HashMap中，以用户ID为key, Thread为value，方便查询 package com.peter.Modle; import java.util.HashMap; //管理线程的类，线程池 public class ManageClientThreads &#123; public static HashMap&lt;String, ServerThread&gt; threads = new HashMap&lt;&gt;(); //UID为线程Key，socket为value public static void addThread(String UID, ServerThread s ) &#123; threads.put(UID, s); &#125; //删除线程 public static void delThread(String UID) &#123; threads.remove(UID); &#125; //获取对应线程 public static ServerThread getThread(String UID) &#123; for(String id:threads.keySet()) &#123; if(KMP(id,UID,MatchMap(UID))!=-1) &#123; return threads.get(id); &#125; &#125; return null; &#125; //由于用户存储的是用户名+IP，而当用户要与另外一个用户通信时输入的是IP地址，所以我们这里需要做字符串匹配以找到符合的字符串 //使用KMP算法做字符串匹配 private static int[] MatchMap(String dest) &#123; int[] map = new int[dest.length()]; map[0]=0; for(int i=0,j=0;i&lt;dest.length();i++) &#123; while(j&gt;0&amp;&amp;dest.charAt(i)!=dest.charAt(j)) j = map[j-1]; if(dest.charAt(i)==dest.charAt(j)) j++; map[i] = j; &#125; return map; &#125; private static int KMP(String st1, String st2, int[] map) &#123; for(int i=0, j=0;i&lt;st1.length();i++) &#123; while(j&gt;0&amp;&amp;st1.charAt(i)!=st2.charAt(j)) j = map[j-1]; if(st1.charAt(i)==st2.charAt(j)) j++; if(j&gt;=st2.length()) return i-j+1; &#125; return -1; &#125; &#125; ShowOnline显示所有在线用户，其实就是遍历线程池，将每个Key（除查询本机的用户以外）返回给此查询用户 package com.peter.Service; import java.util.ArrayList; import java.util.Set; import com.peter.Modle.ManageClientThreads; public class ShowOnline &#123; //根据线程池中的所有线程，获取所有UID，即在线的用户 public static ArrayList&lt;String&gt; getAllIP(String UID)&#123; ArrayList&lt;String&gt; ips = new ArrayList&lt;&gt;(ManageClientThreads.threads.keySet()); ips.remove(UID); //在线用户查看时，排除用户自己 return ips; &#125; &#125; MessageType和MessageMessageType和Message与客户端是一样的，MessageType就好像是一个密码本，使客户端与服务器了解彼此要做的事。Message必须要进行序列化操作，同时保证客户端与服务器的Message对象一样，这样在从客户端传输Message对象到服务器端时就不会报错，（Class Not Found Exception） 拓展本程序有许多可拓展的地方，如让用户之间可以传输文件，当用户输入错的IP时，服务器会提示用户输入的信息有错误等等。时间有限，部分功能尚未完成，请谅解。 展示效果最后只需要将Menus和Terminal分别放到2个测试类当中就好，这样就能开始进行服务器，2台客户端间的通信了。下面是成果展示： 服务器端 客户端 一级菜单 二级菜单 二级菜单收到另一个用户发来的信息(由于是控制台表示信息收发与选项选择，信息显示会有所冲突) 安全退出 Comments这个程序说实话做的有点草率，很多地方其实有Bug，许多边际情况确实没有考虑，但这依然不失是一个好的练习题，用来练习多线程管理，Socket通信等。 参考HSP老师的视频：https://www.bilibili.com/video/BV1j54y1b7qv?p=30","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://xiongy-rhit.github.io/tags/JAVA/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"http://xiongy-rhit.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"}]},{"title":"java数据结构与算法汇总","slug":"java数据结构与算法汇总","date":"2021-07-23T17:56:47.000Z","updated":"2021-07-23T08:06:10.502Z","comments":true,"path":"java数据结构与算法汇总/","link":"","permalink":"http://xiongy-rhit.github.io/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/","excerpt":"作者:Yao Xiong [TOC] 序学习计算机主要是了解计算机组成结构与如何灵活运用计算机；在灵活运用计算机时，数据结构与算法起到重中之重的作用。要想成为计算机大神，数据结构与算法是必须跨过的坎。Good Luck👍。","text":"作者:Yao Xiong [TOC] 序学习计算机主要是了解计算机组成结构与如何灵活运用计算机；在灵活运用计算机时，数据结构与算法起到重中之重的作用。要想成为计算机大神，数据结构与算法是必须跨过的坎。Good Luck👍。 Comparable 与 Iterable 接口Comparable介绍Interface Comparable 如果一个类实现Comparable接口，其必须实现CompareTo方法，调用此方法的对象将与里面的o对象进行比较 例如： x.CompareTo(T y) x和y进行比较，如果相等返回0；若x&gt;y，返回1；若x&lt;y，返回-1；当然，CompareTo方法的实现由我们自己定义 实现此接口的对象拥有自然顺序（natural ordering） 对象之间可以使用CompareTo(T o)来进行比较 如果对储存此对象的集合调用sort方法，Collections工具类会根据CompareTo方法排序：Collections.sort(list2); //节点实现Comparable接口 class Node implements Comparable&lt;Node&gt; &#123; private int num; Node(int num)&#123; this.num = num; &#125; @Override public int compareTo(Node arg0) &#123; // TODO Auto-generated method stub int num2 = arg0.num; return num - num2; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; //在主程序中调用 public class NaturalOrderTest &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(66); list.add(33); list.add(66); list.add(68); list.add(23); list.add(78); LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;(); for(Integer i:list) &#123; list2.add(new Node(i)); &#125; Node node = new Node(23); Collections.sort(list2); System.out.println(list2); &#125; &#125; 集合调用进行排序假如我们需要对一组集合中的对象进行2种不同的排序方法 Collections.sort(…)有2种形式 // Collections指集合工具类 Sort by the natural order: Collections.sort(todoList); todoList里面的对象必须是Comparable的 Collections.sort(list2); Sort according to a specified order Collections.sort(list2, ComparatorClass); ComparatorClass是一个类，实现了Comparator接口 Comparator也是一个接口 Interface Comparator 要实现compare(T o1, T o2)方法，返回值是int，与Comparable类似 o1是前一个元素， o2是后一个元素 针对第2中形式(Comparator)，我写了一个例子 //实现Comparator接口 class ComparatorClass implements Comparator&lt;Node&gt;&#123; @Override public int compare(Node arg0, Node arg1) &#123; // TODO Auto-generated method stub return arg1.num-arg0.num; //进行逆序排列 &#125; &#125; //原来实现Comparable接口的类 class Node implements Comparable&lt;Node&gt; &#123; int num; Node(int num)&#123; this.num = num; &#125; @Override public int compareTo(Node arg0) &#123; // TODO Auto-generated method stub int num2 = arg0.num; return num - num2; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; //测试类 public class NaturalOrderTest &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(66); list.add(33); list.add(66); list.add(68); list.add(23); list.add(78); LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;(); for(Integer i:list) &#123; list2.add(new Node(i)); &#125; //进行排序 Collections.sort(list2, new ComparatorClass()); System.out.println(list2); &#125; &#125; 有了Comparator接口的实现类，我们可以对已有的集合中的元素(元素属性足够多)进行各种指定的排序，如 Collections.sort(list, new BigToSmallComparator()); //从大到小 Collections.sort(list, new LftToRtComparator());//从左到右 Collections.sort(list, new TopToBotComparator());//从上到下 Comparator 和Comparable总结Comparable interface for objects that can be compared control classes’ natural ordering 实现方法：int compareTo(T o1); Comparator still an interface for objects but used to defined the rule use Comparator to sort objects in an order other than their natural ordering 实现方法：int compare(T o1, T o2); Iterable介绍 Iterable也是一个接口 实现这个接口，必须实现其Iterator方法，返回一个迭代器 class MyList implements Iterable&lt;MyList&gt;&#123; @Override public Iterator iterator() &#123; // TODO Auto-generated method stub return null; &#125; &#125; 同时，实现了iterable接口的集合都可以进行for-each-loop（增强for），当然还要返回有效的iterator() 所以同时我们也要实现iterator接口（一般使用内部类来实现此接口） 实现Iterator接口 boolean hasNext() E next() void remove() 使用内部类来实现 外部类实现Iterable接口，内部类实现Iterator接口 为什么要用内部类？ 引用Data Structure and Algorithm Analysis in Java的原话 The inner class is useful in a situation in which each inner class object is associated with exactly one instance of an outer class object. In such a case, the inner class object can never exist without having an outer class object with which to be associated. 翻译过来就是：当一个类需要使用另一个类里面的元素时，同时要保证被引用的类的元素是私有的，此时我们就可以使用内部类；在这种情况下，如果没有外部类，内部类就无法存在。 Iterator和Iterable总结Iterator与Iterable两个接口缺一不可 Iterator接口让实现Iterable的对象返回一个迭代器对象 Iterable为Iterator的使用创造条件 实现Iterable接口后，集合就可以进行for-each循环 Iterable is an interface specification for a class that is equipped with an Iterator Iterator is an interface specification for a class that can generate iterative elements Each Collection class needs an associated Iterator class Iterator may access inside of collection Iterator provides elements one at a time. 数据结构：链表介绍JAVA中有许多的数据结构,例如数组，队列，栈，链表等。与其他数据结构相比，链表具有增删快，充分利用碎片化空间的特点。链表是引用类型数据，它就像一个表格，包含众多节点（内部的数据通过一个个指针链所相连接）。就像下面这张图链表都是由一个个节点构成，每个节点中包含数据与指针，指针为节点指明方向，即下一个数据或上一个数据。 分类链表也可以分类 单向链表 双向链表 单向循环链表 单向链表是指链表中每个节点都只能指向下一个节点，不能指向上一个。（上面那张示意图就是单向链表） 双向链表是指链表中每个节点都可以指向上一个节点，同时也可以指向下一个节点，示意图如下单向循环链表：一个单向链表的最后一个节点的next指针，指向开头的节点。（示意图如下） 实现链表对于链表，我们要实现增删改查的功能。增添数据、删除数据、修改数据、查找数据 单向链表package DataStructure; import java.util.Stack; /** * @author 23881 * 链表的增删改查 * 合并链表 * 逆序打印 *反转链表 *打印倒是第n个元素 */ public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; SingleLinkedList list = new SingleLinkedList(); // list.add(new HeroNode(1,&quot;peter&quot;,&quot;peterbear&quot;)); // list.add(new HeroNode(3,&quot;tony&quot;,&quot;hairCutter&quot;)); System.out.println(&quot;\\t增添元素&quot;); list.AddByOrder(new HeroNode(1,&quot;peter&quot;,&quot;peterbear&quot;)); list.AddByOrder(new HeroNode(3,&quot;tony&quot;,&quot;hairCutter&quot;)); list.AddByOrder(new HeroNode(2,&quot;jerry&quot;,&quot;printf&quot;)); list.AddByOrder(new HeroNode(5,&quot;jim&quot;,&quot;java&quot;)); list.AddByOrder(new HeroNode(6,&quot;trump&quot;,&quot;python&quot;)); list.AddByOrder(new HeroNode(2,&quot;jerry&quot;,&quot;printf&quot;)); list.print(); System.out.println(&quot;\\t查找元素&quot;); list.Search(0); System.out.println(&quot;\\t更改元素&quot;); list.Update(new HeroNode(2,&quot;zhang&quot;,&quot;专业户&quot;)); list.print(); System.out.println(&quot;\\t删除元素&quot;); list.Delete(2); list.print(); System.out.println(&quot;\\t此链表中节点的个数：&quot;+list.size()); System.out.println(&quot;\\t倒数第n个元素\\n&quot;+list.NodeFromLast(3)); System.out.println(&quot;\\t反转后的链表&quot;); list.ReserveNode(); list.print(); System.out.println(&quot;\\t逆序打印&quot;); list.RevPrint(); list.ReserveNode(); System.out.println(&quot;\\t合并链表&quot;); System.out.println(&quot;链表1：&quot;); list.print(); System.out.println(&quot;链表2：&quot;); SingleLinkedList list2 = new SingleLinkedList(); list2.AddByOrder(new HeroNode(5,&quot;Biden&quot;,&quot;瞌睡虫&quot;)); list2.AddByOrder(new HeroNode(8,&quot;John&quot;,&quot;somebody&quot;)); list2.print(); System.out.println(&quot;合并后：&quot;); list.Combine(list2); list.print(); &#125; &#125; class HeroNode&#123; public int No; public String Name; public String NickName; public HeroNode next; //指向下一个节点 public HeroNode(int No, String Name, String NickName) &#123; this.No = No; this.Name = Name; this.NickName = NickName; &#125; @Override public String toString() &#123; return &quot;Node[ No: &quot;+this.No+&quot;; Name: &quot;+this.Name+&quot;; NickName: &quot;+this.NickName+&quot; ]&quot;; &#125; @Override public boolean equals(Object obj) &#123; HeroNode node = (HeroNode)obj; return node.No == this.No &amp;&amp; node.Name.equals(node.Name) &amp;&amp; node.NickName.equals(node.NickName); &#125; &#125; class SingleLinkedList&#123; //先初始化一个头节点 public HeroNode Head = new HeroNode(0,&quot;&quot;,&quot;&quot;); //添加节点 //找到当前列表的最后一个节点，将最后一个节点的next指向下一个 public void add(HeroNode node) &#123; //head节点不能动，用一个指针指向head HeroNode cur = Head; //遍历链表 while(cur.next != null) &#123; cur = cur.next; &#125; cur.next = node; &#125; //按照heronode的编号来存储数据，判断数据是否存在与存储数据 public void AddByOrder(HeroNode node) &#123; HeroNode cur = Head; if(isempty()) &#123; add(node); return; &#125; while(cur.next != null) &#123; if(cur.next.No &gt; node.No) &#123; node.next = cur.next; cur.next = node; break; &#125; else if(cur.next.No == node.No ) &#123; System.out.printf(&quot;%s的编号%d 已存在，无法添加\\n&quot;,node.Name,node.No); break; &#125; cur = cur.next; if(cur.next == null) &#123; add(node); break; &#125; &#125; &#125; //对链表中数据进行反转 public void ReserveNode() &#123; HeroNode cur = Head.next; HeroNode temp = new HeroNode(0,&quot;&quot;,&quot;&quot;); while(cur!=null) &#123; Head.next = cur.next; cur.next = temp.next; temp.next = cur; cur = Head.next; &#125; Head = temp; //第二种 // HeroNode next =null; // while(cur!=null) &#123; // next = cur.next; // cur.next = temp.next; // temp.next = cur; // cur = next; // &#125; // Head = temp; &#125; //删除信息 public void Delete(int No) &#123; if(isempty()) &#123; System.out.println(&quot;此链表为空链表，无法删除任何元素&quot;); return; &#125; if(No == 0) &#123; System.out.println(&quot;无法删除头节点&quot;); return; &#125; HeroNode cur = Head; while(cur.next != null) &#123; if(cur.next.No == No) &#123; cur.next = cur.next.next; return; &#125; cur = cur.next; &#125; System.out.println(&quot;未找到匹配的信息&quot;); &#125; //改变信息 public void Update(HeroNode NewNode) &#123; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; if(NewNode.No == 0) &#123; System.out.println(&quot;无法改变头节点的值&quot;); return; &#125; HeroNode cur = Head; while(cur!=null) &#123; if(cur.next.No == NewNode.No) &#123; NewNode.next = cur.next.next; cur.next = NewNode; return; &#125; cur = cur.next; &#125; &#125; //查找信息 public void Search(int No) &#123; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; if(No == 0) &#123; System.out.println(&quot;此节点为头节点&quot;); return; &#125; HeroNode cur = Head; while(cur!=null) &#123; if(cur.No == No) &#123; System.out.println(&quot;编号 &quot;+No+&quot;:&quot;+cur); return; &#125; cur = cur.next; &#125; System.out.println(&quot;未找到匹配信息&quot;); &#125; //查找单链表倒数第k个结点 public HeroNode NodeFromLast(int k) &#123; if(k&gt;size()||k&lt;=0) &#123; return null; &#125; HeroNode cur = Head.next; for(int i=0;i&lt;(size()-k);i++) &#123; cur = cur.next; &#125; return cur; &#125; //判空 public boolean isempty() &#123; return Head.next == null; &#125; //遍历打印链表 public void print() &#123; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; HeroNode cur = Head.next; while (cur != null) &#123; System.out.println(cur); cur = cur.next; &#125; &#125; //从尾到头打印链表 //1.将单链表反转，然后遍历（会破坏原来的结构） //2.利用栈，将各个节点压入到栈中，先进后出的特点，实现逆序打印的效果 public void RevPrint() &#123; if(isempty()) &#123; System.out.println(&quot;此链表为空&quot;); return; &#125; Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;(); HeroNode cur = Head.next; while (cur != null) &#123; stack.push(cur); cur = cur.next; &#125; while(stack.size()&gt;0) &#123; System.out.println(stack.pop()); &#125; &#125; //获取链表节点个数 public int size() &#123; int count =0; HeroNode cur = Head; while(cur.next != null) &#123; cur=cur.next; count++; &#125; return count; &#125; //合并链表 public void Combine(SingleLinkedList list) &#123; HeroNode cur = list.Head.next; while(cur!=null) &#123; list.Head = cur.next; cur.next = null; this.AddByOrder(cur); cur = list.Head; &#125; &#125; &#125; 单向链表改进版对于上方的单向链表，我们还可以进行升级，以减少代码的冗余程度，比如我们在添加或删除时，都需要对整个链表进行遍历，以找到确切的位置，我们可以把查找变成一个函数，只在添加或删除时对结点进行操作，如下 //在这里面，我们用2个结点，一个表示开头，一个表示结尾，一个变量表示大小 private Node&lt;E&gt; beginMaker; private Node&lt;E&gt; endMaker; private int theSize=0; package ReviewForDataStructure; import java.util.Iterator; import java.util.NoSuchElementException; public class MySingleList&lt;E&gt; implements Iterable&lt;E&gt;&#123; public MySingleList() &#123; doClear(); &#125; public void clear() &#123; doClear(); &#125; public int size() &#123; return theSize; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; //默认添加到最后 public void add(E element) &#123; add(size(), element); &#125; //添加到指定位置 public void add(int idx, E element) &#123; addAfter(getNode(idx, 0, size()),element); &#125; public E getData(int idx) &#123; return getNode(idx+1, 0, size()).data; &#125; public E remove() &#123; return remove(size()-1); &#125; public E remove(int idx) &#123; Node&lt;E&gt; pre = getNode(idx, 0, size()); Node&lt;E&gt; node = getNode(idx+1, 0, size()); pre.next = node.next; theSize--; return node.data; &#125; //内部Node类 private static class Node&lt;E&gt;&#123; public Node&lt;E&gt; next; public E data; public Node(E data, Node&lt;E&gt; nx)&#123; this.data = data; this.next = nx; &#125; &#125; private class MyListIterator implements Iterator&lt;E&gt;&#123; Node&lt;E&gt; current = beginMaker.next; @Override public boolean hasNext() &#123; // TODO Auto-generated method stub return current != endMaker; &#125; @Override public E next() &#123; // TODO Auto-generated method stub if(!hasNext()) throw new NoSuchElementException(); E nextItem = current.data; current = current.next; // System.out.println(&quot;\\n----&quot;+nextItem); return nextItem; &#125; &#125; private void addAfter(Node&lt;E&gt; p, E element) &#123; p.next = new Node&lt;E&gt;(element,p.next); theSize++; &#125; /** * always get the pointed node * @param idx * @param lower * @param upper * @return */ private Node&lt;E&gt; getNode(int idx, int lower, int upper) &#123; if(idx&lt;lower || idx &gt; upper) &#123; throw new NullPointerException(); &#125; Node&lt;E&gt; p=beginMaker; for(int i=0;i&lt;idx;i++) &#123; p=p.next; &#125; return p; &#125; private void doClear() &#123; endMaker = new Node&lt;E&gt;(null, null); beginMaker = new Node&lt;E&gt;(null, endMaker); theSize =0; &#125; private Node&lt;E&gt; beginMaker; private Node&lt;E&gt; endMaker; private int theSize=0; @Override public Iterator&lt;E&gt; iterator() &#123; // TODO Auto-generated method stub return new MyListIterator(); &#125; &#125; 双向链表package DataStructure; public class DoubleLinkDemo &#123; public static void main(String[] args) &#123; DoubleLinkList list = new DoubleLinkList(); list.add(120,&quot;CSSE&quot;); list.add(399,&quot;ESL&quot;); list.add(220,&quot;CSSE&quot;); list.add(399,&quot;ESL&quot;); list.add(102,&quot;CSSE&quot;); list.add(221,&quot;MA&quot;); System.out.println(&quot;\\tlist的大小：&quot;+list.size()); System.out.println(&quot;\\t正序打印&quot;); list.print(); System.out.println(&quot;\\t逆序打印&quot;); list.Rsprint(); System.out.println(&quot;\\t查找数据&quot;); Node[] array = list.search(&quot;CSSE&quot;); for(Node node:array) &#123; if(node!=null) &#123; System.out.println(node); &#125; &#125; System.out.println(&quot;\\t删除数据&quot;); list.del(220); list.print(); System.out.println(&quot;\\t更改数据&quot;); list.update(new Node(221,&quot;MA&quot;), new Node(113,&quot;MA&quot;)); list.print(); &#125; &#125; class Node&#123; int num; String name; Node pre; Node next; Node(int num,String name)&#123; this.num = num; this.name =name; pre =null; next=null; &#125; @Override public String toString() &#123; return name+&quot; &quot;+num; &#125; @Override public boolean equals(Object obj) &#123; Node node = (Node)obj; return node.num == this.num&amp;&amp;node.name.equals(this.name); &#125; &#125; class DoubleLinkList&#123; private Node head; DoubleLinkList()&#123; head =null; &#125; //判空 public boolean isempty() &#123; return head == null; &#125; //增 public void add(int num,String name) &#123; Node node = new Node(num,name); if(isempty()) &#123; head = node; return; &#125; Node cur = head; while(cur.next!=null) &#123; if(cur.equals(node)) &#123; System.out.println(node+&quot; 节点已存在，无法添加&quot;); return; &#125; cur = cur.next; &#125; cur.next = node; node.pre = cur; &#125; //删 //根据编号删除数据 public void del(int num) &#123; Node cur = head; //数据为空 if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; //数据在开头 if(cur.num == num) &#123; head = cur.next; return; &#125; //数据在中间 while(cur.next!=null) &#123; if(cur.num == num) &#123; cur.pre.next = cur.next; cur.next.pre = cur.pre; return; &#125; cur = cur.next; &#125; //数据在末尾 if(cur.num == num) &#123; cur.pre.next= null; return; &#125; System.out.println(&quot;未找到相关数据&quot;); &#125; //改,更改数据 public void update(Node Oldnode,Node Newnode) &#123; Node cur = head; //数据为空 if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; //数据在开头 if(cur.equals(Oldnode)) &#123; Newnode.next = cur.next; cur.next.pre = Newnode; head = Newnode; return; &#125; //数据在中间,数据在末尾 while(cur!=null) &#123; if(cur.equals(Oldnode)) &#123; Newnode.next = cur.next; cur.pre.next = Newnode; Newnode.pre = cur.pre; return; &#125; cur = cur.next; &#125; System.out.println(&quot;未找到相关数据&quot;); &#125; //查 //根据name查找数据 public Node[] search(String name) &#123; Node cur = head; boolean exist = false; Node[] array = new Node[this.size()]; int count=0; //数据为空 if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return null; &#125; while(cur!=null) &#123; if(cur.name.equals(name)) &#123; array[count] = cur; exist =true; count++; &#125; cur = cur.next; &#125; if(!exist) &#123; System.out.println(&quot;未找到相关数据&quot;); &#125; return array; &#125; //list的大小 public int size() &#123; int count=0; Node cur = head; while(cur!=null) &#123; cur = cur.next; count++; &#125; return count; &#125; //正遍历 public void print() &#123; Node cur = head; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; while(cur!= null) &#123; System.out.println(cur); cur = cur.next; &#125; &#125; //逆遍历 public void Rsprint() &#123; Node cur = head; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; while(cur.next!=null) &#123; cur = cur.next; &#125; while(cur!=null) &#123; System.out.println(cur); cur = cur.pre; &#125; &#125; &#125; 单向循环链表public class CircleLinkedListDemo &#123; public static void main(String[] args) &#123; CircleLinkedList list = new CircleLinkedList(); for(int i=0;i&lt;5;i++) &#123; list.add(i); &#125; System.out.println(&quot;\\t添加数据&quot;); list.print(); System.out.println(&quot;\\t删除头部数据&quot;); list.del(0); list.print(); System.out.println(&quot;\\t更改数据&quot;); list.update(new Node(3), new Node(0)); list.print(); System.out.println(&quot;\\t查找数据，是否包含此数据&quot;); System.out.println(list.contains(3)); // System.out.println(&quot;\\t删除中间数据&quot;); // list.del(3); // list.print(); // System.out.println(&quot;\\t删除尾部数据&quot;); // list.del(4); // list.print(); &#125; &#125; class Node&#123; int num; Node next; Node(int num)&#123; this.num = num; next = null; &#125; @Override public boolean equals(Object obj) &#123; Node node =(Node) obj; return node.num == this.num; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; class CircleLinkedList&#123; private Node head; public CircleLinkedList() &#123; head = null; &#125; //判空 public boolean isempty() &#123; return head == null; &#125; //增 public void add(int num) &#123; Node node = new Node(num); //开始为空 if(isempty()) &#123; head = node; node.next = head; return; &#125; //开始不为空 Node cur = head; while(cur.next!=head) &#123; if(cur.equals(node)) &#123; System.out.println(&quot;此数据已存在&quot;); return; &#125; cur =cur.next; &#125; cur.next = node; node.next = head; &#125; //删 public void del(int num) &#123; Node cur = head; //判空 if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; while(cur.next!=head) &#123; if(cur.next.num == num) &#123; //数据在尾部 if(cur.next.next == head) &#123; cur.next = head; return; &#125; cur.next = cur.next.next; return; &#125; cur = cur.next; &#125; //数据在头部,此时指针在尾部 if(cur.next.num == num) &#123; head = head.next; cur.next = cur.next.next; return; &#125; System.out.println(&quot;未找到相关数据&quot;); &#125; //改 public void update(Node OldNode, Node NewNode) &#123; Node cur = head; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; //中间与尾部 while(cur.next != head) &#123; if(cur.next.equals(OldNode)) &#123; NewNode.next = cur.next.next; cur.next = NewNode; return; &#125; cur =cur.next; &#125; //数据在头部 if(cur.next.equals(OldNode)) &#123; NewNode.next = head.next; head = NewNode; cur.next = head; return; &#125; System.out.println(&quot;未找到相关数据&quot;); &#125; //查 public boolean contains(int num) &#123; Node cur = head; do&#123; if(cur.num == num) &#123; return true; &#125; cur=cur.next; &#125;while(cur!=head) ; return false; &#125; //遍历 public void print() &#123; Node cur = head; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; do&#123; System.out.println(cur); cur = cur.next; &#125;while(cur!= head); &#125; Josephus问题（约瑟夫问题）总结链表的学习比较抽象，刚开始接触会很懵，不知道哪个是哪个。多画图，多分析，对于链表的理解就会更加深刻。 数据结构：栈介绍栈和队列一样是一种特殊的线性表结构，它的特点是先进后出（first in last out）。下面有一张图来描述栈 栈有两个常用方法 pop()，出栈，从尾部弹出元素 push(int value)，压栈，把数据压入栈中 实现栈实现栈的方式有多种，我列举2种：一种是用数组来实现栈，还有一种是用链表来实现栈 ArrayStack（数组） LinkedListStack（链表） ArrayStackpackage DataStructure; public class ArrayStackDemo &#123; public static void main(String[] args) &#123; ArrayStack stack= new ArrayStack(3); System.out.println(&quot;\\t压栈&quot;); stack.push(120); stack.push(220); stack.push(221); stack.push(449); System.out.println(&quot;\\t打印栈元素&quot;); stack.print(); try &#123; System.out.println(&quot;\\t弹出栈元素&quot;); System.out.println(&quot;弹出的元素：&quot;+stack.pop()); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; System.out.println(&quot;\\t弹出后的元素&quot;); stack.print(); &#125; &#125; class ArrayStack&#123; private int MaxSize; private int top;//标号，默认为-1 private int[] array; //构造器 public ArrayStack(int size) &#123; MaxSize = size; top = -1; array = new int[MaxSize]; &#125; //判空 public boolean isempty() &#123; return top == -1; &#125; //判满 public boolean isfull() &#123; //判断满，数组最后一位下标MaxSize-1 return top == MaxSize -1; &#125; //入栈,压栈 public void push(int value) &#123; if(isfull()) &#123; System.out.println(&quot;已满，无法添加元素:&quot;+value); return; &#125; top++;//压栈，先+1 array[top] = value;//开始赋值 &#125; //出栈，弹出 public int pop() &#123; if(isempty()) &#123; throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;); &#125; int value = array[top]; top--; return value; &#125; //遍历栈，从上往下 public void print() &#123; if(isempty()) &#123; System.out.println(&quot;栈为空&quot;); return; &#125; for(int i=top;i&gt;=0;i--) &#123; System.out.printf(&quot;Stack[%d] = %d\\n&quot;,i,array[i]); &#125; &#125; &#125; LinkedListStackpackage DataStructure; public class LinkedListStackDemo &#123; public static void main(String[] args) &#123; LinkedListStack stack= new LinkedListStack(3); System.out.println(&quot;\\t压栈&quot;); stack.push(120); stack.push(220); stack.push(221); stack.push(449); System.out.println(&quot;\\t打印栈元素&quot;); stack.print(); try &#123; System.out.println(&quot;\\t弹出栈元素&quot;); System.out.println(&quot;弹出的元素：&quot;+stack.pop()); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125; System.out.println(&quot;\\t弹出后的元素&quot;); stack.print(); &#125; &#125; class StackNode&#123; int value; StackNode next; public StackNode(int num) &#123; value = num; next = null; &#125; @Override public String toString() &#123; return value+&quot;&quot;; &#125; &#125; class LinkedListStack&#123; private int MaxSize; private StackNode head; //构造器 public LinkedListStack(int size) &#123; MaxSize = size; head =null; &#125; //容器中元素个数 public int size() &#123; int count =0; StackNode cur = head; while(cur != null) &#123; count ++; cur = cur.next; &#125; return count; &#125; //判空 public boolean isempty() &#123; return head == null; &#125; //判满 public boolean isfull() &#123; return size() == MaxSize; &#125; //压栈 public void push(int value) &#123; StackNode node = new StackNode(value); if(isempty()) &#123; head = node; return; &#125; if(isfull()) &#123; System.out.println(&quot;已满，无法添加元素:&quot;+value); return; &#125; StackNode cur = head; while(cur.next != null) &#123; cur = cur.next; &#125; cur.next = node; &#125; //出栈 public StackNode pop() &#123; if(isempty()) &#123; throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;); &#125; StackNode pre = head; if(size()==1) &#123; head = null; return pre; &#125; StackNode cur = pre.next; while(cur.next != null) &#123; pre = pre.next; cur = cur.next; &#125; StackNode temp = cur; pre.next = null; return temp; &#125; //从上到下遍历 public void print() &#123; if(isempty()) &#123; System.out.println(&quot;栈为空&quot;); return; &#125; LinkedListStack container = new LinkedListStack(size()); StackNode cur = head; while(cur!=null) &#123; container.push(cur.value); cur = cur.next; &#125; while(container.size()&gt;0) &#123; System.out.println(container.pop()); &#125; &#125; &#125; LinkedListStack 改进版由于Stack First In Last Out的性质， 我们可以对之前的LinkedListStack进行优化，当pop或push元素时我们只操纵第一个元素，如下 下面是代码实现 package DataStructure; import java.util.AbstractList; public class LinkedListStackDemo2&lt;E&gt;&#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub LinkedListStackDemo2&lt;Integer&gt; stack= new LinkedListStackDemo2&lt;&gt;(); System.out.println(&quot;\\t压栈&quot;); stack.push(120); stack.push(220); stack.push(221); stack.push(449); System.out.println(&quot;ShowAll&quot;); stack.ShowAll(); System.out.println(&quot;Size&quot;); System.out.println(stack.Size); System.out.println(&quot;出栈&quot;); System.out.println(stack.pop()); System.out.println(&quot;Size&quot;); System.out.println(stack.Size); System.out.println(&quot;Peek&quot;); System.out.println(stack.peek()); &#125; private Node&lt;E&gt; head=null; private int Size=0; // Return the Size of this Queue public int size() &#123; return Size; &#125; // Return whether this queue is Empty public boolean isEmpty() &#123; return head == null; &#125; // Add new item into the queue public void push(E item) &#123; if(isEmpty()) &#123; head = new Node&lt;&gt;(item); Size++; return; &#125; head = new Node&lt;&gt;(item, head); Size++; &#125; // Return the top data public Node&lt;E&gt; peek() &#123; if(isEmpty()) return null; return new Node&lt;&gt;(head.data); &#125; // Return the top data public Node&lt;E&gt; pop()&#123; Node&lt;E&gt; temp = head; if(!isEmpty()) &#123; head = head.next; Size--; &#125; return temp; &#125; // Show all the items in the stack public void ShowAll() &#123; ShowAll(head); &#125; // Internal Method For Showing the items private void ShowAll(Node&lt;E&gt; root) &#123; if(root == null) return; else &#123; System.out.println(root); ShowAll(root.next); &#125; &#125; private static class Node&lt;E&gt;&#123; E data; Node&lt;E&gt; next; public Node(E d) &#123; data =d; next =null; &#125; public Node(E d, Node&lt;E&gt; n) &#123; data =d; next =n; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;[ data: &quot;+data+&quot; ]&quot;; &#125; &#125; &#125; LinkedListStack时间复杂度这种方法实现的栈，入栈，出栈，效率大大提升(因为每次都只是在头部操作) 入栈时，时间复杂度为O(1) 出栈，时间复杂度也为O(1) 查询Size，同样是O(1) 用栈来实现计算器本计算器支持正整数的加减乘除运算 包含的知识 字符串转化为字符数组 字符与double类型数据间的转换 栈的pop与push 链表栈（本计算器是通过链表栈来实现的） 优先级判断 输入数字与符号给计算器时，计算器会考虑符号的优先级，例如乘号优先级&gt;减号的优先级； 实现步骤 当我们从控制台输入一连串字符时，我们的程序需要对字符串进行拆解， for循环区分数字与符号，然后将内容分别压入数字栈与符号栈； 使用while循环遍历符号栈，当符号栈为空时，运算终止 循环时，我们分别从符号栈和数字栈中pop出元素：num1, num2, operator; 计算完后再push入数字栈中（即计算完的值代替了原来的两个num）；通过循环进行最终得出最后的答案。 进行计算之前要先判断优先级，例如:”6X6-5”，我们需要先看一下符号栈后一个符号优先级是否大于即将pop的；如果是，我们要将他们数字与符号调换一下顺序：5-6X6 ，由于另一个符号是减号，我们要将减号改为+，其中一个数字乘上-1：-5+6X6 直到循环结束，numStack中的最后一个元素就是最终的答案. 本计算器使用上面的链表栈来实现的，其中节点稍作改动，节点接收double类型数据，因为我们不知道用户输入的数字个数具体有多少，所以此链表栈没有isfull（判满）。 在链表栈中，我们还增添了peek方法，用于查看倒数第2个符号是什么（判断优先级） package DataStructure; import java.util.Arrays; import java.util.Scanner; public class StackCalculatorDemo &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print(&quot;please input the operation equation: &quot;); String expression = input.next(); Calculator cal = new Calculator(); cal.process(expression); input.close(); &#125; &#125; class NumNode&#123; double value; NumNode next; public NumNode(double num) &#123; value = num; next = null; &#125; @Override public String toString() &#123; return value+&quot;&quot;; &#125; &#125; class Stack&#123; private NumNode head = null; //容器中元素个数 public int size() &#123; int count =0; NumNode cur = head; while(cur != null) &#123; count ++; cur = cur.next; &#125; return count; &#125; //判空 public boolean isempty() &#123; return head == null; &#125; //压栈 public void push(double value) &#123; NumNode node = new NumNode(value); if(isempty()) &#123; head = node; return; &#125; NumNode cur = head; while(cur.next != null) &#123; cur = cur.next; &#125; cur.next = node; &#125; //出栈 public NumNode pop() &#123; if(isempty()) &#123; throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;); &#125; NumNode pre = head; if(size()==1) &#123; head = null; return pre; &#125; NumNode cur = pre.next; while(cur.next != null) &#123; pre = pre.next; cur = cur.next; &#125; NumNode temp = cur; pre.next = null; return temp; &#125; //查看倒数第2个元素，但是不弹出 public NumNode peek() &#123; if(isempty()) &#123; throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;); &#125; NumNode pre = head; if(size()==1) &#123; return pre; &#125; NumNode cur = pre.next; while(cur.next != null) &#123; pre = pre.next; cur = cur.next; &#125; return pre; &#125; //从上到下遍历 public void print() &#123; if(isempty()) &#123; System.out.println(&quot;栈为空&quot;); return; &#125; Stack container = new Stack(); NumNode cur = head; while(cur!=null) &#123; container.push(cur.value); cur = cur.next; &#125; while(container.size()&gt;0) &#123; System.out.println(container.pop()); &#125; &#125; &#125; class Calculator&#123; public void process(String question) &#123; // String question = &quot;7*88+6*6-5/10&quot;; //将输入的字符串转为数组 char[] array = question.toCharArray(); // System.out.println(Arrays.toString(array)); //创建2个栈，一个用于存储符号，另一个用于存储数字 Stack operStack = new Stack(); Stack numStack = new Stack(); //number字符串用于存储多位数字的字符 String number =&quot;&quot;; //for循环遍历一遍 for(char i: array) &#123; //通过字符判断是否为数字， if(Character.isDigit(i)) &#123; number += i; &#125; else &#123; numStack.push(Integer.valueOf(number)); number=&quot;&quot;; operStack.push(i); &#125; &#125; //由于最后一个是数字，for循环最后一遍未压入数字栈，需要手动压入 numStack.push(Integer.valueOf(number)); //当最后一个符号栈遍历完，运算结束 while(!operStack.isempty()) &#123; char nextOpe = (char)operStack.peek().value; //判断优先级 if(priority(nextOpe) == 1) &#123; // System.out.println(&quot;数字&quot;); // numStack.print(); // System.out.println(&quot;符号&quot;); // operStack.print(); double num1 = numStack.pop().value; double num2 = numStack.pop().value; double num3 = numStack.pop().value; double ope1 = operStack.pop().value; //看下一个是否是‘-’号， if((char) ope1 == &#39;-&#39;) &#123; //更改符号，改变数字正负 ope1 = (int)&#39;+&#39;; num1*=-1; &#125; double ope2 = operStack.pop().value; numStack.push(num1); numStack.push(num3); numStack.push(num2); operStack.push(ope1); operStack.push(ope2); &#125; double num1 = numStack.pop().value; double num2 = numStack.pop().value; char ope = (char)operStack.pop().value; Double rst = cal(num1, num2, ope); numStack.push(rst); &#125; System.out.println(&quot;答案是：&quot;+numStack.pop()); &#125; //计算过程，使用switch case public double cal(double num1, double num2, char ope) &#123; double rst =0; switch (ope) &#123; case &#39;*&#39;: rst = num2*num1; break; case &#39;/&#39;: rst = num2*1.0/num1; break; case &#39;+&#39;: rst = num2+num1; break; case &#39;-&#39;: rst = num2-num1; break; default: break; &#125; return rst; &#125; //优先级判断 public int priority(char ope) &#123; if(ope == &#39;*&#39; || ope==&#39;/&#39;) &#123; return 1; &#125; else if(ope == &#39;+&#39; || ope ==&#39;-&#39;) &#123; return 0; &#125; else &#123; return -1; &#125; &#125; &#125; 前、中、后缀表达式（波兰、逆波兰计算器）式子：3+(7+8)x4-6 按照我们常规的计算方法，我们从左往右计算，看到括号先计算括号里面的数，再根据优先级算其他的数字；这就是所谓的中缀表达式 前缀表达式是把符号置于数字的左侧，以上面式子为例：**+3-x+7846**。当计算时，我们从右往左把数字压入栈中，顺序依次是：6-&gt;4-&gt;8-&gt;7（此时7在栈顶）；接着我们依次从栈中弹出2个元素：7和8，然后读取第一个符号进行计算。计算结果再压入栈中，依次循环，如果下一个是数字，压入栈中直到读取完最后一个符号。 前缀表达式又称波兰表达式，是波兰逻辑学家J·Lukasiewicz所发现的。 因为前缀表达式是从右往左扫描，数字和符号有自己的讲究，不能乱放（要按照优先级：括号&gt;乘号&gt;加号）。 后缀表达式被称为逆波兰表达式。和前缀表达式相似，后缀表达式的符号在数字的后面； 继续以上面的式子为例：**378+4x+6-**。 讲了这么多，既然中缀表达式与我们生活中使用的计算方式一样，为什么还要学前缀与后缀表达式呢？ 由于计算机是线性思维，它无法立刻发现括号等，所以使用中缀表达式不好操作；相反用后缀或前缀表达式可以解决这个问题，计算机只用从前往后读，或从后往前读就行，这样可以方便检索运算。 后缀表达式实现（逆波兰表达式） 后缀表达式从左向右扫描，如果遇到数字，将数字压入栈中 倘若遇到运算符，弹出2个数字，进行运算，运算后的结果压入栈 下一个是数字，再压入栈中，直到遇到运算符号 依次循环，向后遍历，直到最后一个符号被遍历完 最终存在栈中的元素就是计算的结果 先从中缀转后缀 package DataStructure; import java.util.Stack; public class PostfixDemo &#123; public static void main(String[] args) &#123; PolanCal cal = new PolanCal(&quot;3+(7+8)*4-6&quot;); cal.ToPostExpression(); System.out.println(cal.output); &#125; &#125; class PolanCal&#123; String input;//中缀表达式 String output = &quot;&quot;;//后缀表达式 Stack&lt;Character&gt; TempStack = new Stack&lt;&gt;(); //用于暂时存储中缀转后缀的符号 PolanCal(String input)&#123; this.input = input; &#125; public void ToPostExpression() &#123; //3+(7+8)*4-6 //378+4*+6- char[] words = this.input.toCharArray(); for(char i:words) &#123; switch (i) &#123; case &#39;+&#39;: case &#39;-&#39;: Prio(i,1);//优先级判断 break; case &#39;*&#39;: case &#39;/&#39;: Prio(i,2); break; case &#39;(&#39;: TempStack.push(i); break; case &#39;)&#39;: while(!TempStack.isEmpty()) &#123; //遍历，将括号间的符号加入到output char operator = TempStack.pop(); if(operator ==&#39;(&#39;) &#123; break; &#125; else &#123; output += operator; &#125; &#125; break; default: //读取的是数字就直接加入到output字符串中 output += i; break; &#125; &#125; //遍历完后，将暂时栈里面的符号弹出，存入到output while(!TempStack.isEmpty()) &#123; output += TempStack.pop(); &#125; &#125; public void Prio(char oper1, int priority1) &#123; while(!TempStack.isEmpty()) &#123; char onTop = TempStack.pop();//弹出位于栈顶部的符号 if(onTop ==&#39;(&#39;) &#123;//如果栈顶的是前括号，就不弹出 TempStack.push(onTop); break;//将输入的符号压入栈中 &#125; else &#123; //要比较栈顶的符号与输入的符号哪个优先级大 int priority2; if(onTop ==&#39;+&#39;||onTop==&#39;-&#39;) &#123; priority2 = 1; &#125; else &#123; priority2 = 2; &#125; //栈顶符号优先级小于输入的优先级 //符号还原，不pop if(priority2 &lt; priority1) &#123; TempStack.push(onTop); break; &#125; else &#123; output += onTop; &#125; &#125; &#125; TempStack.push(oper1); &#125; &#125; 实现中缀转后缀之后，现在要实现计算过程 其中有些代码稍作了改动 原来的中缀无法转多位数字，现在支持多位中缀转后缀：“3+(7+89)*4-66+8” 为了处理数据方便，后缀表达式各符号用空格分开 package DataStructure; import java.util.Arrays; import java.util.Stack; public class PostfixDemo &#123; public static void main(String[] args) &#123; PolanCal cal = new PolanCal(&quot;3+(7+89)*4-66+8&quot;); cal.ToPostExpression(); System.out.println(&quot;转逆波兰后缀表达式：&quot;+cal.output); cal.StartCal(); &#125; &#125; class PolanCal &#123; String input;// 中缀表达式 String output = &quot;&quot;;// 后缀表达式 Stack&lt;Character&gt; TempStack = new Stack&lt;&gt;(); // 用于暂时存储中缀转后缀的符号 PolanCal(String input) &#123; this.input = input; &#125; public void ToPostExpression() &#123; // 3+(7+8)*4-6 // 378+4*+6- char[] words = this.input.toCharArray(); for (int i=0;i&lt;words.length;i++) &#123; char word =words[i]; switch (word) &#123; case &#39;+&#39;: case &#39;-&#39;: Prio(word, 1);// 优先级判断 break; case &#39;*&#39;: case &#39;/&#39;: Prio(word, 2); break; case &#39;(&#39;: TempStack.push(word); break; case &#39;)&#39;: while (!TempStack.isEmpty()) &#123; char operator = TempStack.pop(); if (operator == &#39;(&#39;) &#123; break; &#125; else &#123; output += operator + &quot; &quot;; &#125; &#125; break; default: // 读取的是数字就直接加入到output字符串中 output += word; if(i&lt;words.length-1&amp;&amp;!Character.isDigit(words[i+1])) &#123; output +=&quot; &quot;; &#125; break; &#125; &#125; // 遍历完后，将暂时栈里面的符号弹出，存入到output output+=&quot; &quot;; while (!TempStack.isEmpty()) &#123; output += TempStack.pop(); &#125; &#125; public void Prio(char oper1, int priority1) &#123; while (!TempStack.isEmpty()) &#123; char onTop = TempStack.pop();// 弹出位于栈顶部的符号 if (onTop == &#39;(&#39;) &#123;// 如果栈顶的是前括号，就不弹出 TempStack.push(onTop); break;// 将输入的符号压入栈中 &#125; else &#123; // 要比较栈顶的符号与输入的符号哪个优先级大 int priority2; if (onTop == &#39;+&#39; || onTop == &#39;-&#39;) &#123; priority2 = 1; &#125; else &#123; priority2 = 2; &#125; // 栈顶符号优先级小于输入的优先级 // 符号还原，不pop if (priority2 &lt; priority1) &#123; TempStack.push(onTop); break; &#125; else &#123; output += onTop + &quot; &quot;; &#125; &#125; &#125; TempStack.push(oper1); &#125; public void StartCal() &#123; String[] nums = output.split(&quot; &quot;); Stack&lt;Double&gt; numStack = new Stack&lt;&gt;(); for (String i : nums) &#123; if (isNumeric(i)) &#123; numStack.push(Double.valueOf(i)); &#125; else &#123; double num1 = numStack.pop(); double num2 = numStack.pop(); double rst =0; if(i.equals(&quot;+&quot;)) &#123; rst = num2+num1; &#125;else if(i.equals(&quot;-&quot;)) &#123; rst = num2-num1; &#125;else if(i.equals(&quot;*&quot;)) &#123; rst = num2*num1; &#125;else if(i.equals(&quot;/&quot;)) &#123; rst = num2*1.0/num1; &#125; numStack.push(Double.valueOf(rst)); &#125; &#125; System.out.println(&quot;最终计算结果：&quot;+numStack.pop()); &#125; public static boolean isNumeric(String str)&#123; for (int i = str.length();--i&gt;=0;)&#123; if (!Character.isDigit(str.charAt(i)))&#123; return false; &#125; &#125; return true; &#125; &#125; 数据结构：队列Queue介绍与Stack栈相反，队列是First In First Out，像排队一样，在Java util包中，LinkedList就是一个Queue队列 实现原理为了方便查找开头与结尾，我们在队列的头和尾都用2个Node来指向 当我们使用这种方法实现队列，同样，时间复杂度为O(1),插入和删除 具体我就不实现了，其实和Stack大同小异 数据结构：哈希表 HashTable介绍HashTable是常见的数据结构，就像Set，List，Collition。哈希表常用于缓存中，功能与Raddis相似，但是后者比前者更强。哈希表是根据键值对来访问数据，（key）。HashTable一般由数组与链表所构成，如图 每个数组元素都是由链表所构成，当存储数据时，根据散列函数我们选择对应的链表，将节点数据存入链表中。 实现为了实现哈希表，先创建一个节点 因为是键值对的形式，我们的节点要有2个部分，1个key，1个value //因为key值是独一无二的，ID就是key, name就是value class NameNode&#123; int num; String name; NameNode next; NameNode(int num, String name)&#123; this.num = num; this.name = name; next = null; &#125; @Override public String toString() &#123; return &quot;[ ID: &quot;+num+&quot;, Name: &quot;+name+&quot; ]&quot;; &#125; &#125; 链表类 //List链表实现功能：增删遍历。当增添时不能增添已有ID，（满足key-value原则） class List&#123; NameNode head; List()&#123; head = null; &#125; public boolean isempty() &#123; return head == null; &#125; public void add(NameNode node) &#123; if(isempty()) &#123; head = node; return; &#125; if(isExist(node)) &#123; System.out.println(&quot;ID已存在，请重新输入&quot;); return; &#125; NameNode cur = head; while(cur.next != null) &#123; cur = cur.next; &#125; cur.next = node; &#125; public boolean isExist(NameNode node) &#123; NameNode cur = head; while(cur != null) &#123; if(node.num == cur.num) &#123; return true; &#125; cur = cur.next; &#125; return false; &#125; public void delete(NameNode node) &#123; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; NameNode cur = head; if(cur.num == node.num) &#123; head = cur.next; System.out.println(&quot;删除完毕&quot;); return; &#125; do &#123; NameNode pre =cur; cur =cur.next; if(cur.num == node.num) &#123; pre.next = cur.next; System.out.println(&quot;删除完毕&quot;); return; &#125; &#125;while(cur != null); System.out.println(&quot;没有相关元素ID&quot;); &#125; public void print() &#123; if(isempty()) &#123; System.out.println(&quot;链表为空&quot;); return; &#125; NameNode cur = head; while(cur != null)&#123; System.out.print(cur+&quot; ~&quot;); cur = cur.next; &#125; System.out.println(); &#125; &#125; 当我们使用HashTable时，我们使用的时HashTable而不是LinkedList，所以要再创建一个HashTable类 class HashTable&#123; private int size; List[] table; //这个就是哈希表中的数组 HashTable(int size)&#123; //根据传进去的size我们定义hashtable的大小 this.size =size; table = new List[size]; //初始化table数组，因为前面虽然创建，但是没有初始化，编译器会识别为null for(int i=0;i&lt; size;i++) &#123; table[i] = new List(); &#125; &#125; public void add(NameNode sb) &#123; int no = fintable(sb.num); table[no].add(sb); &#125; public void print() &#123; for(int i=0;i&lt;size;i++) &#123; System.out.print(&quot;第&quot;+(i+1)+&quot;行： &quot;); table[i].print(); &#125; &#125; public void delete(NameNode node) &#123; int no = fintable(node.num); table[no].delete(node); &#125; //散列函数，最简单的散列函数就是取模，% public int fintable(int num) &#123; return num % size; &#125; &#125; 测试类 写一个循环，让用户选择是要Add，Delete，还是print public class HashTableDemo1 &#123; public static void main(String[] args) &#123; HashTable table = new HashTable(5); Scanner scanner = new Scanner(System.in); String input=&quot;&quot;; while(input !=&quot;exit&quot;) &#123; System.out.println(&quot;Add 添加用户&quot;); System.out.println(&quot;Print 打印用户&quot;); System.out.println(&quot;Delete 删除用户&quot;); System.out.println(&quot;Exit 退出&quot;); input = scanner.next(); switch (input) &#123; case &quot;Add&quot;: System.out.print(&quot;用户ID：&quot;); int id = scanner.nextInt(); System.out.print(&quot;用户姓名：&quot;); String name = scanner.next(); table.add(new NameNode(id, name)); System.out.println(); break; case &quot;Print&quot;: System.out.println(&quot;列表如下&quot;); table.print(); System.out.println(); break; case &quot;Delete&quot;: System.out.print(&quot;删除用户的ID： &quot;); int num = scanner.nextInt(); table.delete(new NameNode(num, &quot;&quot;)); System.out.println(); break; case &quot;Exit&quot;: scanner.close(); System.exit(1); break; default: break; &#125; &#125; &#125; &#125; 数据结构：树我们在使用其他数据结构，例如数组和链表多少会有些缺陷；数组虽然可以通过下标快速定位到数据，但是在增删数据会有缺陷，因为数组大小一开始就固定好了，当数组满时在增添需要开辟更大的空间然后复制内容，这样会浪费空间且麻烦；同样链表也有缺陷，虽然链表增删快且方便，但是为了查找一个数据我们需要遍历整个链表去寻找，这样速度可能会比较慢。为了解决这些问题，大佬们创建了树，如下： 上面的树是二叉树，树的一种；其继承了二分查找与链表的优点：易增删，查找快 术语空树：没有任何结点 叶/叶结点：位于末梢的结点 父结点：后面继承了结点的结点 兄弟结点：拥有相同的父结点 深度：树的层数，以上面图为例，深度为4，有4层 节点：等于结点，英文名 Node 完全二叉树：对于k层的完全二叉树，节点数的范围2^ (k - 1) -1 &lt; N&lt; 2^k - 1; 二叉树（Binary Tree）介绍二叉树顾名思义，有2个叉的树，基本思路与树相同 二叉树遍历分为前序，中序还有后序； 前序：遍历先中间，左边再右边 ABDHECFG 中序：遍历先左边，中间再右边 HDBEAFCG 后序：遍历先左边，右边再中间 HDEBFGCA 实现首先需要创建一个树结点 前序、中序、后序的区别在于打印的不同 class TreeNode_1&#123; char word; TreeNode_1 left; TreeNode_1 right; TreeNode_1(char word)&#123; this.word = word; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return word+&quot;&quot;; &#125; //前序遍历 public void preOrder() &#123; System.out.print(this); if(this.left != null) &#123; this.left.preOrder(); &#125; if(this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序遍历 public void infixOrder() &#123; //先向左递归 if(this.left !=null) &#123; this.left.infixOrder(); &#125; //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个 System.out.print(this); //然后递归右结点 if(this.right!=null) &#123; this.right.infixOrder(); &#125; &#125; //后序遍历 public void postOrder() &#123; if(this.left != null) &#123; this.left.postOrder(); &#125; if(this.right != null) &#123; this.right.postOrder(); &#125; System.out.print(this); &#125; &#125; 建立一个二叉树类 class BinaryTree_1&#123; private TreeNode_1 root; BinaryTree_1()&#123; root = null; &#125; BinaryTree_1(TreeNode_1 root)&#123; this.root =root; &#125; public boolean isempty() &#123; return root == null; &#125; &#125; 二叉树的遍历方法，前，中，后序遍历 //前序遍历 public void preOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.preOrder(); System.out.println(); &#125; //中序遍历 public void infixOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.infixOrder(); System.out.println(); &#125; //后序遍历 public void postOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.postOrder(); System.out.println(); &#125; 添加元素 在上面一个二叉树中，我们从上往下，从左往右判断是否应该添加元素 先添加元素A，由于开始为空，root结点直接指向A 读取A，判断A左和右侧是否为null, 左侧为null，就添加B，右侧为null，就添加C 我们要一层一层往下读取，这个就是：广度优先遍历（层次遍历）【横向为广度，纵向为深度】 怎么才能确保先取出A，再取出B，接着取出C呢？ 这个需要用到队列 假设这个树最初有0个元素，我们要增添A,B,C,D 第1次 初始为空，root直接指向A 先把root加入到队列中, [ A ] 弹出队列中第一个元素，此时是A 遍历如果A的左边为null, A.left指向添加的元素 再次循环，第2次 初始为1，把root加入到队列中[ A ] 弹出第一个元素A A左边不为null, 把左边的元素压入 [B] 再判断A右边是否为null，右边是null,A.right 指向C 循环，第3次 初始为1，把root加入到队列中[ A ] 弹出第一个元素A A左边不为null, 把左边的元素压入 [B] 再判断A右边是否为null，右边是C, 把C压入队列 [ B, C] pop弹出队列第一个元素，B 判断B左侧是否为null, 是null, B.left 指向D …… 下面是add方法代码实现 public void add(TreeNode_1 node) &#123; if(isempty()) &#123; root = node; return; &#125; LinkedList&lt;TreeNode_1&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; TreeNode_1 cur = queue.pop(); if(cur.left == null) &#123; cur.left = node; return; &#125;else &#123; queue.add(cur.left); &#125; if(cur.right == null) &#123; cur.right = node; return; &#125;else &#123; queue.add(cur.right); &#125; &#125; &#125; 查找元素 //前序遍历 public boolean preSearch(TreeNode_1 node) &#123; boolean rst =false; System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; return true; &#125; if(this.left != null) &#123; rst = this.left.preSearch(node); &#125; if(rst == true) &#123; return rst; &#125; if(this.right != null) &#123; rst = this.right.preSearch(node); &#125; return rst; &#125; //中序遍历 public boolean infixSearch(TreeNode_1 node) &#123; boolean rst =false; //先向左递归 if(this.left !=null) &#123; rst = this.left.infixSearch(node); &#125; if(rst == true) &#123; return rst; &#125; //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个 System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; return true; &#125; //然后递归右结点 if(this.right!=null) &#123; rst = this.right.infixSearch(node); &#125; return rst; &#125; //后序遍历 public boolean postSearch(TreeNode_1 node) &#123; boolean rst = false; if(this.left != null) &#123; rst = this.left.postSearch(node); &#125; if(rst == true) &#123; return rst; &#125; if(this.right != null) &#123; rst = this.right.postSearch(node); &#125; System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; rst = true; &#125; return rst; &#125; 最终 package DataStructure; import java.util.LinkedList; public class BinaryTreeDemo1 &#123; public static void main(String[] args) &#123; BinaryTree_1 tree = new BinaryTree_1(); String words =&quot;ABCDEFGH&quot;; for(char i : words.toCharArray()) &#123; tree.add(new TreeNode_1(i)); &#125; System.out.println(&quot;前序遍历&quot;); tree.preOrder(); System.out.println(&quot;中序遍历&quot;); tree.infixOrder(); System.out.println(&quot;后序遍历&quot;); tree.postOrder(); System.out.println(&quot;前序查找&quot;); System.out.println(tree.preSearch(new TreeNode_1(&#39;B&#39;))); System.out.println(&quot;中序查找&quot;); System.out.println(tree.infixSearch(new TreeNode_1(&#39;B&#39;))); System.out.println(&quot;后序查找&quot;); System.out.println(tree.postSearch(new TreeNode_1(&#39;B&#39;))); &#125; &#125; class TreeNode_1&#123; char word; TreeNode_1 left; TreeNode_1 right; TreeNode_1(char word)&#123; this.word = word; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return word+&quot;&quot;; &#125; //前序遍历 public void preOrder() &#123; System.out.print(this); if(this.left != null) &#123; this.left.preOrder(); &#125; if(this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序遍历 public void infixOrder() &#123; //先向左递归 if(this.left !=null) &#123; this.left.infixOrder(); &#125; //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个 System.out.print(this); //然后递归右结点 if(this.right!=null) &#123; this.right.infixOrder(); &#125; &#125; //后序遍历 public void postOrder() &#123; if(this.left != null) &#123; this.left.postOrder(); &#125; if(this.right != null) &#123; this.right.postOrder(); &#125; System.out.print(this); &#125; //前序遍历 public boolean preSearch(TreeNode_1 node) &#123; boolean rst =false; System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; return true; &#125; if(this.left != null) &#123; rst = this.left.preSearch(node); &#125; if(rst == true) &#123; return rst; &#125; if(this.right != null) &#123; rst = this.right.preSearch(node); &#125; return rst; &#125; //中序遍历 public boolean infixSearch(TreeNode_1 node) &#123; boolean rst =false; //先向左递归 if(this.left !=null) &#123; rst = this.left.infixSearch(node); &#125; if(rst == true) &#123; return rst; &#125; //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个 System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; return true; &#125; //然后递归右结点 if(this.right!=null) &#123; rst = this.right.infixSearch(node); &#125; return rst; &#125; //后序遍历 public boolean postSearch(TreeNode_1 node) &#123; boolean rst = false; if(this.left != null) &#123; rst = this.left.postSearch(node); &#125; if(rst == true) &#123; return rst; &#125; if(this.right != null) &#123; rst = this.right.postSearch(node); &#125; System.out.println(this+&quot; &quot;+node); if(this.word == node.word) &#123; rst = true; &#125; return rst; &#125; &#125; class BinaryTree_1&#123; private TreeNode_1 root; BinaryTree_1()&#123; root = null; &#125; BinaryTree_1(TreeNode_1 root)&#123; this.root =root; &#125; public boolean isempty() &#123; return root == null; &#125; public void add(TreeNode_1 node) &#123; if(isempty()) &#123; root = node; return; &#125; LinkedList&lt;TreeNode_1&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; TreeNode_1 cur = queue.pop(); if(cur.left == null) &#123; cur.left = node; return; &#125;else &#123; queue.add(cur.left); &#125; if(cur.right == null) &#123; cur.right = node; return; &#125;else &#123; queue.add(cur.right); &#125; &#125; &#125; //前序遍历 public void preOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.preOrder(); System.out.println(); &#125; //中序遍历 public void infixOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.infixOrder(); System.out.println(); &#125; //后序遍历 public void postOrder() &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return; &#125; this.root.postOrder(); System.out.println(); &#125; //前序查找 public boolean preSearch(TreeNode_1 node) &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return false; &#125; return this.root.preSearch(node); &#125; //中序查找 public boolean infixSearch(TreeNode_1 node) &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return false; &#125; return this.root.infixSearch(node); &#125; //后序查找 public boolean postSearch(TreeNode_1 node) &#123; if(isempty()) &#123; System.out.println(&quot;树为空&quot;); return false; &#125; return this.root.postSearch(node); &#125; &#125; 顺序存储二叉树 我们将二叉树的结点以数组的形式储存，虽然结点在数组中保存，但是我们仍然可以像树一样遍历数组（前序遍历、中序遍历、后序遍历） 顺序存储二叉树的特点 通常是完全二叉树 第n个元素的左子节点为2*n+1 第n个元素的右子节点为2*n+2 第n个元素的父节点为（n-1）/2 (取整) 举例：第0个元素的左子节点序号为1，第0个元素的右子节点序号为2， 第1个元素的父节点0，0 = (1-1) /2,同样第2个元素的父节点0, 0 = (2-1) /2 代码 package DataStructure; public class ArrayBinaryTreeDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5,6,7&#125;; //定义一个顺序数组 System.out.println(&quot;前序遍历&quot;); preOrder(arr, 0); //这个0指的是根的位置 System.out.println(&quot;\\n&quot;+&quot;中序遍历&quot;); infixOrder(arr, 0); System.out.println(&quot;\\n&quot;+&quot;后序遍历&quot;); postOrder(arr, 0); &#125; //完成顺序存储二叉树的前序遍历 public static void preOrder(int[] arr, int index) &#123; if(arr == null || arr.length == 0) &#123; System.out.println(&quot;数组为空&quot;); return; &#125; System.out.print(arr[index]); //向左递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +1); &#125; //向右递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +2); &#125; &#125; //中序遍历 public static void infixOrder(int[] arr, int index) &#123; if(arr == null || arr.length == 0) &#123; System.out.println(&quot;数组为空&quot;); return; &#125; //向左递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +1); &#125; System.out.print(arr[index]); //向右递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +2); &#125; &#125; //后序遍历 public static void postOrder(int[] arr, int index) &#123; if(arr == null || arr.length == 0) &#123; System.out.println(&quot;数组为空&quot;); return; &#125; //向左递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +1); &#125; //向右递归 if(2*index +2 &lt; arr.length) &#123; preOrder(arr, 2*index +2); &#125; System.out.print(arr[index]); &#125; &#125; 二叉树的应用堆排序堆排序是利用堆这种数据结构而设计的排序算法，堆排序是一种选择排序，它的时间复杂度为 O(nlogn),是不稳定的排序。我们使用树的思想来进行数组的排序，数组与树之间的转换，参考上面顺序存储二叉树 基础概念当完全二叉树的每个结点的值都大于或等于其左右孩子结点的值，我们称为大顶堆。若每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 大顶堆的图如上，小顶堆就是和大顶堆相反，小的在上，大的在下 一般使用大顶堆对数据进行升序排列，使用小顶堆进行降序排列 排序操作时操作的一直都是数组，但是为了方便理解，以树的形式来演示。 大顶堆特点：arr[i] &gt;= arr[2i +1] &amp;&amp; arr[i] &gt;= arr[2i +2] 第n个元素大于等于其左子节点即第2*n+1个元素 第n个元素大于等于其右子节点即第2*n+2个元素 小顶堆特点：arr[i] &lt;= arr[2i +1] &amp;&amp; arr[i] &lt;= arr[2i +2] 第n个元素小于等于其左子节点即第2*n+1个元素 第n个元素小于等于其右子节点即第2*n+2个元素 排序思想 将待排序数列构建成一个大顶堆 此时序列最大值再根节点 将根节点与数组最后一个数进行交换 将剩余的n-1个数再次形成一个大顶堆，依次循环 注意：堆排序不需要创建树，我们执行排序只是利用树的思路来解决数组的排序问题，整个过程都在处理数组 实现大顶堆的构建需要从下往上最下面index应该是倒数第二行第一个结点(父结点) 我们从下往上的顺序是：3 -&gt; 2-&gt;1,从而构建大顶堆 图解 第一个大顶堆 root根与最后一个交换 从剩下的n-1个数组中再找出最大的 再次循环 package Sorting; import java.util.Arrays; public class HeapSorting &#123; public static void main(String[] args) &#123; int[] arr = &#123;35, 10, 25, 15, 30, 40, 20, 50, 45&#125;; // int[] arr = &#123;101,34,119,1&#125;; Sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void Sort(int[] arr) &#123; int temp; //由下往上构建大顶堆,i指的是倒数位于中间的结点元素 for(int i=arr.length/2 -1;i&gt;-1;i--) &#123; heap(arr, i, arr.length); &#125; //进行arr.length-1次循环 for(int j=arr.length-1; j&gt;0; j-- ) &#123; //交换数组元素，第一个（本循环中最大的）与最后一个交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; //排除最后一个再次构建大顶堆 heap(arr, 0, j); &#125; &#125; //建立大顶堆 public static void heap(int[] arr, int index, int len) &#123; int temp = arr[index]; //用temp储存最顶端的值 //for循环只要k值即小于len的时候，才能开始遍历数组 //bigger = bigger*2+1 指向左遍历 for(int bigger=2*index+1; bigger &lt;len; bigger = bigger *2+ 1) &#123; //三个数进行比较，左、中、右，默认左边大于右边 // 如果右边大于左边，且右边有值时 //右边是index*2 +2 = bigger +1 if(bigger+1 &lt; len &amp;&amp;arr[bigger] &lt; arr[bigger+1]) &#123; bigger++; //更大的是右边 &#125; //如果此时左边或者右边中更大的数大于中间的数 if(arr[bigger] &gt; temp) &#123; //中间的数与最大的数交换位置 arr[index] = arr[bigger]; //用index记下最大的数原来的下标，方便向下查找比较 index =bigger; &#125;else &#123; break; &#125; &#125; //最后再交换最小的数 arr[index] =temp; &#125; &#125; 赫夫曼树（Huffman Tree）介绍 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的WPL(Weighted path length) 最小，它就是Huffman Tree，同时也称最优二叉树 WPL是指所有叶子结点的带权路径之和 Huffman Tree是带权路径长度最短的树，权值较大的结点离根较近 Huffman Tree的值都放在叶子结点上 上面这张图的WPL是$$103+302+252+202 = 180$$ package DataStructure; import java.util.ArrayList; import java.util.Collections; public class HuffmanTreeDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, 6, 7, 8, 13, 29&#125;; ArrayList&lt;HuffmanNode&gt; nodes = new ArrayList&lt;&gt;(); for(int i:arr) &#123; nodes.add(new HuffmanNode(i)); &#125; Collections.sort(nodes); CrtTree(nodes); System.out.println(&quot;前序遍历&quot;); preOrder(nodes.get(0)); &#125; public static void CrtTree(ArrayList&lt;HuffmanNode&gt; nodes) &#123; while(nodes.size() &gt;1) &#123; HuffmanNode leftNode = nodes.get(0); HuffmanNode rightNode = nodes.get(1); HuffmanNode parent = new HuffmanNode(leftNode.value +rightNode.value); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); Collections.sort(nodes); &#125; System.out.println(nodes.get(0)); &#125; public static void preOrder(HuffmanNode root) &#123; System.out.println(root); if(root.left != null) &#123; preOrder(root.left); &#125; if(root.right != null) &#123; preOrder(root.right); &#125; &#125; &#125; //为了使Node对象支持排序 class HuffmanNode implements Comparable&lt;HuffmanNode&gt;&#123; int value; HuffmanNode left; HuffmanNode right; HuffmanNode(int num)&#123; value = num; &#125; @Override public String toString() &#123; return &quot;HuffmanNode [value=&quot; + value + &quot;]&quot;; &#125; @Override public int compareTo(HuffmanNode node) &#123; // TODO Auto-generated method stub return this.value - node.value; &#125; &#125; 赫夫曼编码（Huffman Coding）赫夫曼编码常用于通信领域，由于其优异的编码方式，可以提高传输效率 例子我们要将“hello world”进行数据传输，首先我们要把字母转成对应的ASC字母表 104 101 108 108 110 32 119 114 111 114 108 100 然后把对应的十进制数字转为二进制 110 1000 110 0101 110 1100 110 1100 110 1110 10 0000 111 0111 111 0010 110 1111 111 0010 110 1100 110 0100 可以发现转为二进制传输非常长，假如内容更多，对应的二进制内容也会更长，传输效率会下降 我们将上面的内容换成赫夫曼编码 赫夫曼编码的前提是拥有一个赫夫曼树，统一向左为0，向右为1，我们统计每个字符出现的次数，其出现的次数为权，下面有一张图来解释 赫夫曼编码中每个字符没有重复的码，保证了唯一性 将”hello world”按照赫夫曼编码: 11011101010010000001000101100 注意，赫夫曼树的排序方法不同可能会导致对应的赫夫曼编码不同（几个数权值一样），但是最终大小都是一样 代码实现编码1）创建一个结点，储存数据和对应的权值 2）将内容数据转成byte[ ] 数组 3）统计byte数组中每个字符出现的次数，转存到map中 4）构建赫夫曼树，（根据前面得到的map的data和对应的权值来构建Node），把Node加入到List中进行排序 5）构建好的赫夫曼树返回的是一个根节点 6）根据根节点我们要遍历，获取对应的密码，向左为0，向右为1，把对应的密码存入到Map中 7）按照之前的byte[ ]数组，我们与密码一起匹配（压缩）转换成新的byte[ ]数组，这个数组存储的就是赫夫曼码 编码 1） 节点构建 此节点继承Comparable接口，有利于树的比较 //Node节点，储存数据与权值 class Node implements Comparable&lt;Node&gt;&#123; Byte data; int weight; Node left; Node right; Node(Byte data, int value)&#123; this.data = data; weight = value; &#125; @Override public String toString() &#123; return &quot;Node [data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;; &#125; @Override public int compareTo(Node o) &#123; return this.weight - o.weight; &#125; &#125; 2） 把字符串内容转为Byte类型数组 byte[] arr = msg.getBytes(); 3） 统计每个字符出现的次数，储存在Map中 【h:1 , e:1, l:3, o:2, w:1, r:1, d:1】 //统计每个字母出现的次数 private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123; HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); for(byte i:arr) &#123; Byte data = new Byte(i); if(!map.containsKey(data)) &#123; map.put(data, 1); &#125; else &#123; map.replace(data, map.get(data), map.get(data)+1); &#125; &#125; return map; &#125; 4） 按照这些字符出现的次数，我们进行排序，然后构建赫夫曼树 //构建赫夫曼树，返回根节点 private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123; ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for(Byte i:map.keySet()) &#123; nodes.add(new Node(i, map.get(i))); &#125; Collections.sort(nodes); while(nodes.size() &gt; 1) &#123; Node leftNode = nodes.get(0); Node rightNode =nodes.get(1); Node parentNode = new Node(null, leftNode.weight+rightNode.weight); parentNode.left = leftNode; parentNode.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); Collections.sort(nodes); &#125; return nodes.get(0); &#125; 5） 构建好树之后，我们要对树进行遍历，向左为0，向右为1，像这样 最终可以得到 由于权值相同，得出的code可能会与上面展示的不一样 我们将转好的密码存入Map //得出密码，赫夫曼码 private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123; if(root.left != null) &#123; buf.append(0); password(root.left, buf, map); &#125; if(root.left == null &amp;&amp; root.right == null) &#123; map.put(root.data, buf.toString()); buf.deleteCharAt(buf.length()-1); return null; &#125; if(root.right != null) &#123; buf.append(1); password(root.right, buf, map); &#125; // if(buf.length()&gt;0) try &#123; buf.deleteCharAt(buf.length()-1); &#125;catch(Exception e) &#123; &#125; return map; &#125; 6）按照密码进行字符串对应的byte[ ]数组压缩，返回的是byte[ ]数组 //数组转换成赫夫曼编码格式 private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123; StringBuilder meg =new StringBuilder(); for(int i=0;i&lt;arr.length;i++) &#123; meg.append(dic.get(arr[i])); &#125; // System.out.println(meg); //转成byte数组 //1 byte 等于8 bits, 0001001是bits,要转成byte int len; if(meg.length()%8==0) &#123; len = meg.length()/8; &#125;else &#123; len = meg.length()/8+1; &#125; byte[] codes =new byte[len]; //把刚才存好的字符串，8位8位读取，添加进byte数组中 int count=0; for(int j=0;j&lt;meg.length();j+=8)&#123; String temp; if(j+8 &gt; meg.length()) &#123; temp = meg.substring(j); &#125; else temp = meg.substring(j, j+8); //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型 codes[count] = (byte)Integer.parseInt(temp, 2); count++; &#125; return codes; &#125; 最终 只要调用Zip函数，向Zip函数传入字符串参数，就能得到相应的赫夫曼编码数组 //赫夫曼编码 public static byte[] Zip(String msg) &#123; byte[] arr = msg.getBytes(); HashMap&lt;Byte, Integer&gt; map = Count(arr); Node root = HuffmanTree(map); StringBuffer buf=new StringBuffer(); HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;(); password(root, buf,Dic); // for(Byte i:Dic.keySet()) &#123; // System.out.println((char)(byte)i+&quot;:&quot;+Dic.get(i)); // &#125; return UpdateCode(arr,Dic); &#125; //统计每个字母出现的次数 private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123; HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); for(byte i:arr) &#123; Byte data = new Byte(i); if(!map.containsKey(data)) &#123; map.put(data, 1); &#125; else &#123; map.replace(data, map.get(data), map.get(data)+1); &#125; &#125; return map; &#125; //构建赫夫曼树，返回根节点 private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123; ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for(Byte i:map.keySet()) &#123; nodes.add(new Node(i, map.get(i))); &#125; Collections.sort(nodes); while(nodes.size() &gt; 1) &#123; Node leftNode = nodes.get(0); Node rightNode =nodes.get(1); Node parentNode = new Node(null, leftNode.weight+rightNode.weight); parentNode.left = leftNode; parentNode.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); Collections.sort(nodes); &#125; return nodes.get(0); &#125; //得出密码，赫夫曼码 private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123; if(root.left != null) &#123; buf.append(0); password(root.left, buf, map); &#125; if(root.left == null &amp;&amp; root.right == null) &#123; map.put(root.data, buf.toString()); buf.deleteCharAt(buf.length()-1); return null; &#125; if(root.right != null) &#123; buf.append(1); password(root.right, buf, map); &#125; // if(buf.length()&gt;0) try &#123; buf.deleteCharAt(buf.length()-1); &#125;catch(Exception e) &#123; &#125; return map; &#125; //数组转换成赫夫曼编码格式 private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123; StringBuilder meg =new StringBuilder(); for(int i=0;i&lt;arr.length;i++) &#123; meg.append(dic.get(arr[i])); &#125; // System.out.println(meg); //转成byte数组 //1 byte 等于8 bits, 0001001是bits,要转成byte int len; if(meg.length()%8==0) &#123; len = meg.length()/8; &#125;else &#123; len = meg.length()/8+1; &#125; byte[] codes =new byte[len]; //把刚才存好的字符串，8位8位读取，添加进byte数组中 int count=0; for(int j=0;j&lt;meg.length();j+=8)&#123; String temp; if(j+8 &gt; meg.length()) &#123; temp = meg.substring(j); &#125; else temp = meg.substring(j, j+8); //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型 codes[count] = (byte)Integer.parseInt(temp, 2); count++; &#125; return codes; &#125; 解码上面讲的是编码，下面的程序是解码程序 解码与编码相反 1）把得到的byte[ ]数组转为2进制，一个一个读取，存入到一个字符串中 2）按照字符串和之前的密码本进行匹配，最后就得出原数据 public static void Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123; //反向查询解码 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); // System.out.println(msg); System.out.println(&quot;Huffman decode&quot;); for(Byte word:dic.keySet()) &#123; map.put(dic.get(word), word); &#125; int count =1; String value; //匹配对应的字符 for(int i=0;i&lt;msg.length();i+= value.length()) &#123; while(true) &#123; value = msg.substring(i, i+count); if(map.containsKey(value)) &#123; System.out.print((char)(byte)map.get(value)); count =1; break; &#125; count ++; &#125; &#125; &#125; //把byte数组转为二进制类型 public static String Unzip(byte[] msg) &#123; StringBuilder container = new StringBuilder(); for(int i=0;i&lt;msg.length;i++) &#123; int value =new Byte(msg[i]); String temp =Integer.toBinaryString(value); //判断最后一位是否为8bit长度，如果不是，直接加进去 if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123; container.append(temp); &#125; else &#123; if(temp.length()&gt;24) container.append(temp.substring(24)); else &#123; for(int j=0;j&lt;(8-temp.length());j++) &#123; container.append(&quot;0&quot;); &#125; container.append(temp); &#125; &#125; // System.out.println(temp); &#125; return container.toString(); &#125; 压缩+解码 package HuffmanCoding; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; public class HuffmanCodingDemo1 &#123; public static void main(String[] args) &#123; String msg =&quot;hello world my friend, this is peterbear&quot;; byte[] arr = msg.getBytes(); HashMap&lt;Byte, Integer&gt; map = Count(arr); Node root = HuffmanTree(map); StringBuffer buf=new StringBuffer(); HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;(); System.out.println(&quot;Huffman Code&quot;);; byte[] code = Zip(msg); System.out.println(Arrays.toString(code)); Decode(Unzip(code),password(root, buf,Dic)); &#125; //赫夫曼编码 public static byte[] Zip(String msg) &#123; byte[] arr = msg.getBytes(); HashMap&lt;Byte, Integer&gt; map = Count(arr); Node root = HuffmanTree(map); StringBuffer buf=new StringBuffer(); HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;(); password(root, buf,Dic); // for(Byte i:Dic.keySet()) &#123; // System.out.println((char)(byte)i+&quot;:&quot;+Dic.get(i)); // &#125; return UpdateCode(arr,Dic); &#125; //统计每个字母出现的次数 private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123; HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); for(byte i:arr) &#123; Byte data = new Byte(i); if(!map.containsKey(data)) &#123; map.put(data, 1); &#125; else &#123; map.replace(data, map.get(data), map.get(data)+1); &#125; &#125; return map; &#125; //构建赫夫曼树，返回根节点 private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123; ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for(Byte i:map.keySet()) &#123; nodes.add(new Node(i, map.get(i))); &#125; Collections.sort(nodes); while(nodes.size() &gt; 1) &#123; Node leftNode = nodes.get(0); Node rightNode =nodes.get(1); Node parentNode = new Node(null, leftNode.weight+rightNode.weight); parentNode.left = leftNode; parentNode.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); Collections.sort(nodes); &#125; return nodes.get(0); &#125; //得出密码，赫夫曼码 private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123; if(root.left != null) &#123; buf.append(0); password(root.left, buf, map); &#125; if(root.left == null &amp;&amp; root.right == null) &#123; map.put(root.data, buf.toString()); buf.deleteCharAt(buf.length()-1); return null; &#125; if(root.right != null) &#123; buf.append(1); password(root.right, buf, map); &#125; // if(buf.length()&gt;0) try &#123; buf.deleteCharAt(buf.length()-1); &#125;catch(Exception e) &#123; &#125; return map; &#125; //数组转换成赫夫曼编码格式 private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123; StringBuilder meg =new StringBuilder(); for(int i=0;i&lt;arr.length;i++) &#123; meg.append(dic.get(arr[i])); &#125; // System.out.println(meg); //转成byte数组 //1 byte 等于8 bits, 0001001是bits,要转成byte int len; if(meg.length()%8==0) &#123; len = meg.length()/8; &#125;else &#123; len = meg.length()/8+1; &#125; byte[] codes =new byte[len]; //把刚才存好的字符串，8位8位读取，添加进byte数组中 int count=0; for(int j=0;j&lt;meg.length();j+=8)&#123; String temp; if(j+8 &gt; meg.length()) &#123; temp = meg.substring(j); &#125; else temp = meg.substring(j, j+8); //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型 codes[count] = (byte)Integer.parseInt(temp, 2); count++; &#125; return codes; &#125; public static void Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123; //反向查询解码 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); // System.out.println(msg); System.out.println(&quot;Huffman decode&quot;); for(Byte word:dic.keySet()) &#123; map.put(dic.get(word), word); &#125; int count =1; String value; for(int i=0;i&lt;msg.length();i+= value.length()) &#123; while(true) &#123; value = msg.substring(i, i+count); if(map.containsKey(value)) &#123; System.out.print((char)(byte)map.get(value)); count =1; break; &#125; count ++; &#125; &#125; &#125; //把byte数组转为二进制类型 private static String Unzip(byte[] msg) &#123; StringBuilder container = new StringBuilder(); for(int i=0;i&lt;msg.length;i++) &#123; int value =new Byte(msg[i]); String temp =Integer.toBinaryString(value); //判断最后一位是否为8bit长度，如果不是，直接加进去 if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123; container.append(temp); &#125; else &#123; if(temp.length()&gt;24) container.append(temp.substring(24)); else &#123; for(int j=0;j&lt;(8-temp.length());j++) &#123; container.append(&quot;0&quot;); &#125; container.append(temp); &#125; &#125; // System.out.println(temp); &#125; return container.toString(); &#125; //前序遍历 public static void preOrder(Node root) &#123; System.out.println(root); if(root.left != null) &#123; preOrder(root.left); &#125; if(root.right != null) &#123; preOrder(root.right); &#125; &#125; //中序遍历 public static void infixOrder(Node root) &#123; if(root.left != null) &#123; infixOrder(root.left); &#125; System.out.println(root); if(root.right != null) &#123; infixOrder(root.right); &#125; &#125; &#125; //Node节点，储存数据与权值 class Node implements Comparable&lt;Node&gt;&#123; Byte data; int weight; Node left; Node right; Node(Byte data, int value)&#123; this.data = data; weight = value; &#125; @Override public String toString() &#123; return &quot;Node [data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;; &#125; @Override public int compareTo(Node o) &#123; return this.weight - o.weight; &#125; &#125; 文件压缩内容和上面差不多，唯一的区别在于文件压缩需要考虑IO，压缩数据时要使用对象流写入，读取时也需要，写入时要将密码也写入 package HuffmanCoding; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; public class HuffmanFileZip &#123; public static void main(String[] args) &#123; String input =&quot;C:\\\\Users\\\\23881\\\\Desktop\\\\Self_study\\\\Java基础\\\\HuffmanCoding\\\\music.mp3&quot;; String output =&quot;C:\\\\Users\\\\23881\\\\Desktop\\\\Self_study\\\\Java基础\\\\HuffmanCoding\\\\压缩\\\\store.zip&quot;; Zip(input, output); input = output; output = &quot;C:\\\\Users\\\\23881\\\\Desktop\\\\Self_study\\\\Java基础\\\\HuffmanCoding\\\\解压\\\\music.mp3&quot;; UnZipFile(input, output); &#125; //赫夫曼编码 public static void Zip(String input, String output) &#123; FileInputStream file=null; ObjectOutputStream oop=null; FileOutputStream out=null; byte[] arr; try &#123; file= new FileInputStream(input); arr = new byte[file.available()]; file.read(arr); HashMap&lt;Byte, Integer&gt; map = Count(arr); Node root = HuffmanTree(map); StringBuffer buf=new StringBuffer(); //密码就存在Dic字典中 HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;(); password(root, buf,Dic); byte[] rst = UpdateCode(arr,Dic); //输出流 out = new FileOutputStream(output); //与输出流关联对象流,便于恢复数据 oop = new ObjectOutputStream(out); //把编码后的数据写入压缩文件 oop.writeObject(rst); //同时我们还要把赫夫曼编码也写入文件中 oop.writeObject(Dic); System.out.println(&quot;压缩完成&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block System.out.println(&quot;此路径为空&quot;); &#125;finally&#123; try &#123; file.close(); out.close(); oop.close(); &#125; catch (IOException e) &#123; &#125; &#125; &#125; //统计每个字母出现的次数 private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123; HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;(); for(byte i:arr) &#123; Byte data = new Byte(i); if(!map.containsKey(data)) &#123; map.put(data, 1); &#125; else &#123; map.replace(data, map.get(data), map.get(data)+1); &#125; &#125; return map; &#125; //构建赫夫曼树，返回根节点 private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123; ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for(Byte i:map.keySet()) &#123; nodes.add(new Node(i, map.get(i))); &#125; Collections.sort(nodes); while(nodes.size() &gt; 1) &#123; Node leftNode = nodes.get(0); Node rightNode =nodes.get(1); Node parentNode = new Node(null, leftNode.weight+rightNode.weight); parentNode.left = leftNode; parentNode.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); Collections.sort(nodes); &#125; return nodes.get(0); &#125; //得出密码，赫夫曼码 private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123; if(root.left != null) &#123; buf.append(0); password(root.left, buf, map); &#125; if(root.left == null &amp;&amp; root.right == null) &#123; map.put(root.data, buf.toString()); buf.deleteCharAt(buf.length()-1); return null; &#125; if(root.right != null) &#123; buf.append(1); password(root.right, buf, map); &#125; try &#123; buf.deleteCharAt(buf.length()-1); &#125;catch(Exception e) &#123; &#125; return map; &#125; //数组转换成赫夫曼编码格式 private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123; StringBuilder meg =new StringBuilder(); for(int i=0;i&lt;arr.length;i++) &#123; meg.append(dic.get(arr[i])); &#125; // System.out.println(meg); //转成byte数组 //1 byte 等于8 bits, 0001001是bits,要转成byte int len; if(meg.length()%8==0) &#123; len = meg.length()/8; &#125;else &#123; len = meg.length()/8+1; &#125; byte[] codes =new byte[len]; //把刚才存好的字符串，8位8位读取，添加进byte数组中 int count=0; for(int j=0;j&lt;meg.length();j+=8)&#123; String temp; if(j+8 &gt; meg.length()) &#123; temp = meg.substring(j); &#125; else temp = meg.substring(j, j+8); //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型 codes[count] = (byte)Integer.parseInt(temp, 2); count++; &#125; return codes; &#125; public static void UnZipFile(String input, String output) &#123; System.out.println(input); FileInputStream file=null; FileOutputStream Outfile =null; ObjectInputStream ZipFile=null; try &#123; file = new FileInputStream(input); Outfile =new FileOutputStream(output); ZipFile = new ObjectInputStream(file); byte[] huffmanBytes = (byte[])ZipFile.readObject(); HashMap&lt;Byte, String&gt; dic = (HashMap&lt;Byte, String&gt;)ZipFile.readObject(); Outfile.write(Decode(Change(huffmanBytes),dic)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; try &#123; ZipFile.close(); Outfile.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; private static byte[] Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123; //反向查询解码 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); ArrayList&lt;Byte&gt; list = new ArrayList&lt;&gt;(); System.out.println(&quot;Huffman decode&quot;); for(Byte word:dic.keySet()) &#123; map.put(dic.get(word), word); &#125; int count =1; String value; for(int i=0;i&lt;msg.length();i+= value.length()) &#123; while(true) &#123; value = msg.substring(i, i+count); if(map.containsKey(value)) &#123; list.add(map.get(value)); count =1; break; &#125; count ++; &#125; &#125; byte[] arr = new byte[list.size()]; for(int i=0;i&lt;arr.length;i++) &#123; arr[i] = list.get(i); &#125; return arr; &#125; //把byte数组转为二进制类型 private static String Change(byte[] msg) &#123; StringBuilder container = new StringBuilder(); for(int i=0;i&lt;msg.length;i++) &#123; int value =new Byte(msg[i]); String temp =Integer.toBinaryString(value); //判断最后一位是否为8bit长度，如果不是，直接加进去 if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123; container.append(temp); &#125; else &#123; if(temp.length()&gt;24) container.append(temp.substring(24)); else &#123; for(int j=0;j&lt;(8-temp.length());j++) &#123; container.append(&quot;0&quot;); &#125; container.append(temp); &#125; &#125; &#125; return container.toString(); &#125; &#125; BST二叉排序树前面也提到了二叉树拥有数组和链表的2种优点，增删快，查询快，最典型的便是二叉排序树 添加二叉树结点时，我们要进行比较，小的放左边，大的放右边 当我们查找特定的值时，就像二分查找一样，十分迅速；我们想要删除一个结点，也可以像链表一样。 注意： 二叉排序树的难点在于删除的部分，我们需要考虑如何找到其父结点与对应的节点，然后怎么处理剩余的节点 二叉排序树，我实现了增删查的功能 树节点 class Node&#123; int num; Node left; Node right; public Node(int num) &#123; super(); this.num = num; &#125; public void add(Node node) &#123; if(this.num &gt; node.num) &#123; if(this.left == null) &#123; this.left = node; return; &#125;else &#123; //向左遍历 this.left.add(node); &#125; &#125;else &#123; if(this.right == null) &#123; this.right = node; return; &#125;else &#123; //向右遍历 this.right.add(node); &#125; &#125; &#125; public Node Search(Node node) &#123; if(this.num == node.num) &#123; return this; &#125; if(node.num &lt;this.num) &#123; if(this.left == null) &#123; return null; &#125; return this.left.Search(node); &#125;else &#123; if(this.right == null) &#123; return null; &#125; return this.right.Search(node); &#125; &#125; public Node Parent(Node node) &#123; if(this.left != null &amp;&amp; this.left.num == node.num|| this.right != null &amp;&amp; this.right.num == node.num) &#123; return this; &#125;else &#123; if(this.left != null &amp;&amp; node.num &lt; this.left.num ) &#123; return this.left.Parent(node); &#125;else if( this.right != null&amp;&amp;node.num &gt; this.right.num ) &#123; return this.right.Parent(node); &#125;else &#123; return null;//没有父结点 &#125; &#125; &#125; public void infixOrder() &#123; if(this.left != null) &#123; this.left.infixOrder(); &#125; System.out.print(this+&quot; &quot;); if(this.right != null) &#123; this.right.infixOrder(); &#125; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; 在树结点中有2几个方法是配合二叉排序树类一起使用的，他们都使用了递归的方法，这样可以方便遍历 二叉排序树 class BinarySortTree&#123; private Node root = null; public boolean isempty() &#123; return root == null; &#125; public void add(Node node) &#123; if(isempty()) &#123; root = node; &#125;else &#123; root.add(node); &#125; &#125; //删除节点 public void delete(Node node) &#123; //树为空 if(root == null) &#123; System.out.println(&quot;tree is empty&quot;); return; //只有一个节点 &#125;else if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.num == node.num) &#123; root = null; return; &#125; //目标节点未找到 Node target = root.Search(node); if(target == null) &#123; System.out.println(&quot;未找到相关结点&quot;); return; &#125; //寻找父结点 Node Parent = root.Parent(node); //发现父结点为头节点 if(Parent == null) &#123; Node cur = root.left; root = root.right; //把root指向root的右侧 if(root == null) &#123; root = cur; //发现右侧是空，指向左侧 return; &#125; //左侧不为null if(root.left != null) root.add(cur); return; &#125; //子结点在父结点左侧 if(Parent.left.num == target.num) &#123; Parent.left = target.right; if(target.left != null) root.add(target.left); &#125;else &#123; //子节点在父结点右侧 Parent.right = target.right; if(target.left != null) root.add(target.left); &#125; // System.out.println(target); // System.out.println(targetParent); &#125; //中序遍历 public void infixOrder() &#123; if(isempty()) &#123; System.out.println(&quot;Root is empty&quot;); &#125;else &#123; root.infixOrder(); System.out.println(); &#125; &#125; &#125; AVL tree平衡二叉树AVL tree可以说是BST 二叉排序树的优化，假如我们一直往BST 树中添加大的值，BST树就会像链表一样，添加效率甚至低于链表（多了几步判断），为了避免这样的事情发生，大佬们把BST进行了优化，变成AVL tree。 由于发现平衡二叉树的人名字中有AVL这几个字母，所以平衡二叉树简称AVL tree AVL tree基于BST tree进行优化，在添加时进行树的高度的检测，如果左子树的高度比右子树的高度大1，进行右旋转；反之右子树的高度比左子树的高度大1，进行左旋转。（3+1）/2 =2 新增添的功能： 检测左右树的高度 左旋转 右旋转 树的高度class Node&#123; //左子树的高度 public int leftHeight() &#123; //判断左边节点是否为null, 如果是，则返回0，如果不是，返回左边的高度 return this.left == null ? 0:this.left.height(); &#125; //右子树的高度 public int rightHeight() &#123; //判断右边节点是否为null, 如果是，则返回0，如果不是，返回右边的高度 return this.right == null ? 0:this.right.height(); &#125; //树的高度 public int height() &#123; //从所选节点开始，选取左右节点中高度最大的数值作为树的高度 return Math.max(this.left == null ? 0: this.left.height(), this.right == null? 0: this.right.height())+1;//为了判断高度，要进行递归，左子树向左递归，右子树向右递归，最后+1是要加上原来的根节点 &#125; &#125; 左旋转右子树的高度比左子树的高度大1 思路 复制此时的根节点，创建head_node 节点 把head_node左节点指向原左子节点 把head_node右节点指向原右子节点的左子节点 复制原右子节点，创建right_node节点 把right_node在右节点指向原右子节点右子节点 把right_node的左子节点指向head_node 最后把root节点指向此时的right_node节点 最后 就像把树向左旋转以此达到左右子树高度相同的效果， 代码class AVLtree&#123; //左旋转 public Node leftRotate(Node head) &#123; Node head_node = new Node(head.num); head_node.left = head.left; head_node.right = head.right.left; Node right_node = new Node(root.right.num); right_node.right = head.right.right; right_node.left = head_node; head = right_node; return head; &#125; &#125; 右旋转左子树的高度比右子树的高度大1 思路 复制头（根）节点，创建一个新的节点head_node 把head_node左节点指向原头节点的左节点的右子节点 把head_node右节点指向原头节点的右子节点 复制原头节点的左子节点，创建一个新的节点left_node 把left_node左节点指向原头节点的左子节点的左子节点 把left_node的右节点指向head_node 最后把root根节点指向head_node 最后效果 代码 //右旋转 public Node rightRotate(Node head) &#123; Node head_node = new Node(head.num); head_node.right = head.right; head_node.left = head.left.right; Node left_node = new Node(head.left.num); left_node.left = head.left.left; left_node.right = head_node; head = left_node; return head; &#125; 结合左旋转与右旋转把左旋转与右旋转加入到AVL tree的add方法中 //添加节点 public void add(Node node) &#123; if(isempty()) &#123; root = node; &#125;else &#123; root.add(node); &#125; if(rightHeight() -leftHeight() &gt;1) &#123; root = leftRotate(root); //传入的是头节点 &#125;else if(leftHeight() - rightHeight() &gt;1) &#123; root = rightRotate(root); &#125; &#125; 但是还有一个问题，当左子节点的右子节点高度大于其左子节点时，即使进行右旋转，还是无法将树的两边平衡，如图： 进行右旋转 为了解决这个问题 要先将左子节点进行左旋转 再将树进行右旋转 最后 //添加节点 public void add(Node node) &#123; if(isempty()) &#123; root = node; &#125;else &#123; root.add(node); &#125; if(rightHeight() -leftHeight() &gt;1) &#123; //右子树的左子树高度大于其右子树的高度 if(root.left != null &amp;&amp;root.left.leftHeight() - root.left.rightHeight()&gt;0) &#123; //先右旋转 root.right = rightRotate(root.right); &#125; root = leftRotate(root); &#125;else if(leftHeight() - rightHeight() &gt;1) &#123; //左子树的右子树高度大于其左子树的高度 if(root.left != null &amp;&amp;root.left.rightHeight() - root.left.leftHeight()&gt;0) &#123; //先左旋转 root.left = leftRotate(root.left); &#125; root = rightRotate(root); &#125; &#125; 最终实现package Trees; public class AVLTreeDemo1 &#123; public static void main(String[] args) &#123; AVLtree tree = new AVLtree(); // int[] arr = &#123;4,3,6,5,7,8&#125;; // int[] arr = &#123;10,12,8,9,7,6&#125;; int[] arr = &#123;10,11,7,6,8,9&#125;; for(int i:arr) &#123; tree.add(new Node(i)); &#125; // System.out.println(&quot;删除前&quot;); // System.out.printf(&quot;树的高度：%d\\n&quot;,tree.height()); // tree.infixOrder(); // tree.delete(new Node(7)); // System.out.println(&quot;删除后&quot;); // tree.infixOrder(); System.out.printf(&quot;树的高度：%d\\n&quot;,tree.height()); System.out.printf(&quot;树的左子树高度：%d\\n&quot;,tree.leftHeight()); System.out.printf(&quot;树的右子树高度：%d\\n&quot;,tree.rightHeight()); tree.infixOrder(); &#125; &#125; class AVLtree&#123; private Node root = null; public boolean isempty() &#123; return root == null; &#125; public int height() &#123; return root.height(); &#125; public int leftHeight() &#123; return root.leftHeight(); &#125; public int rightHeight() &#123; return root.rightHeight(); &#125; //左旋转 public Node leftRotate(Node head) &#123; Node head_node = new Node(head.num); head_node.left = head.left; head_node.right = head.right.left; Node right_node = new Node(root.right.num); right_node.right = head.right.right; right_node.left = head_node; head = right_node; return head; &#125; //右旋转 public Node rightRotate(Node head) &#123; Node head_node = new Node(head.num); head_node.right = head.right; head_node.left = head.left.right; Node left_node = new Node(head.left.num); left_node.left = head.left.left; left_node.right = head_node; head = left_node; return head; &#125; //添加节点 public void add(Node node) &#123; if(isempty()) &#123; root = node; &#125;else &#123; root.add(node); &#125; if(rightHeight() -leftHeight() &gt;1) &#123; //右子树的左子树高度大于其右子树的高度 if(root.left != null &amp;&amp;root.left.leftHeight() - root.left.rightHeight()&gt;0) &#123; //先右旋转 root.right = rightRotate(root.right); &#125; root = leftRotate(root); &#125;else if(leftHeight() - rightHeight() &gt;1) &#123; //左子树的右子树高度大于其左子树的高度 if(root.left != null &amp;&amp;root.left.rightHeight() - root.left.leftHeight()&gt;0) &#123; //先左旋转 root.left = leftRotate(root.left); &#125; root = rightRotate(root); &#125; &#125; //删除 public void delete(Node node) &#123; if(root == null) &#123; System.out.println(&quot;tree is empty&quot;); return; &#125;else if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.num == node.num) &#123; root = null; return; &#125; Node target = root.Search(node); if(target == null) &#123; System.out.println(&quot;未找到相关结点&quot;); return; &#125; Node Parent = root.Parent(node); if(Parent == null) &#123;//为头节点 Node cur = root.left; root = root.right; if(root == null) &#123; root = cur; return; &#125; if(root.left != null) root.add(cur); return; &#125; if(Parent.left.num == target.num) &#123; Parent.left = target.right; if(target.left != null) root.add(target.left); &#125;else &#123; Parent.right = target.right; if(target.left != null) root.add(target.left); &#125; // System.out.println(target); // System.out.println(targetParent); &#125; public void infixOrder() &#123; if(isempty()) &#123; System.out.println(&quot;Root is empty&quot;); &#125;else &#123; root.infixOrder(); System.out.println(); &#125; &#125; &#125; class Node&#123; int num; Node left; Node right; public Node(int num) &#123; super(); this.num = num; &#125; public int leftHeight() &#123; return this.left == null ? 0:this.left.height(); &#125; public int rightHeight() &#123; return this.right == null ? 0:this.right.height(); &#125; public int height() &#123; return Math.max(this.left == null ? 0: this.left.height(), this.right == null? 0: this.right.height())+1; &#125; public void add(Node node) &#123; if(this.num &gt; node.num) &#123; if(this.left == null) &#123; this.left = node; return; &#125;else &#123; //向左遍历 this.left.add(node); &#125; &#125;else &#123; if(this.right == null) &#123; this.right = node; return; &#125;else &#123; //向右遍历 this.right.add(node); &#125; &#125; &#125; public Node Search(Node node) &#123; if(this.num == node.num) &#123; return this; &#125; if(node.num &lt;this.num) &#123; if(this.left == null) &#123; return null; &#125; return this.left.Search(node); &#125;else &#123; if(this.right == null) &#123; return null; &#125; return this.right.Search(node); &#125; &#125; public Node Parent(Node node) &#123; if(this.left != null &amp;&amp; this.left.num == node.num|| this.right != null &amp;&amp; this.right.num == node.num) &#123; return this; &#125;else &#123; if(this.left != null &amp;&amp; node.num &lt; this.left.num ) &#123; return this.left.Parent(node); &#125;else if( this.right != null&amp;&amp;node.num &gt; this.right.num ) &#123; return this.right.Parent(node); &#125;else &#123; return null;//没有父结点 &#125; &#125; &#125; public void infixOrder() &#123; if(this.left != null) &#123; this.left.infixOrder(); &#125; System.out.print(this+&quot; &quot;); if(this.right != null) &#123; this.right.infixOrder(); &#125; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; 数据结构： 图 图也是数据结构中的一种，YYSY真的经典，学习图可以参考二叉树和二维数组； 直接讲图论可能会十分抽象，毕竟是看文字；数据结构中的图和现实生活中的地铁交通图很类似，如下 我们每一个交通枢纽可以看作是一个顶点，就像上图的A, B, C,D， 从一个枢纽（交叉口）到另一个交叉口之间的线（边）就像上面A,B,C顶点间的线，【用地铁这个解释，应该好理解一点】 图的概念顶点Vertex：对象，一个一个存储的小圆点 边Edge：顶点间的连线 无向图：一个顶点与另一个顶点之间的边没有指向，边没有方向 有向图：顶点与顶点间指向有方向 有权图：顶点间的边上有数值 无权图：顶点间的边上没有数值 图的创建图在程序中有2种实现方法：邻接矩阵和邻接表 邻接矩阵：我们根据顶点的个数构建一个二维数组，这个二维数组的横向index与纵向index分别代表对应的顶点，二维数组（矩阵）中存储0或1，0代表2个顶点没有连接，1代表有连接 邻接表：就像HashTable一样，邻接表由数组与链表一起构成， 数组中的每个index代表不同的顶点，链表中存储的数字是顶点对应的下标 邻接表与邻接矩阵：很明显，在顶点数量较少的情况下，使用邻接表可以节省更多的空间 下面以邻接矩阵为例，实现图 邻接矩阵图的主要方法： 返回顶点个数 返回有多少条边 获取根据下标获取顶点 添加新的顶点 给新的顶点建立边 显示图 package Graphs; import java.util.ArrayList; import java.util.LinkedList; public class Graph &#123; private ArrayList&lt;String&gt; vertexList; private int[][] edges; private int numOfEdges;//边的数目 /** * * @param n 传入顶点个数 */ Graph(int n)&#123; edges = new int[n][n]; //以二维邻接矩阵来构建图 vertexList = new ArrayList&lt;&gt;(n);//用于存储顶点信息 numOfEdges =0; &#125; /** * * @return 有多少个顶点 */ public int VertexNum() &#123; return vertexList.size(); &#125; /** * * @return 有多少条边 */ public int EdgeLength() &#123; return numOfEdges; &#125; /** * * @param index 传入下标 * @return 返回对应的顶点 */ public String GetVertex(int index) &#123; return vertexList.get(index); &#125; /** * * @param v1 * @param v2 * @return 返回2个顶点的权值 */ public int GetWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 插入节点 * @param vertex */ public void InsertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * * @param v1 点1的下标，第几个顶点 * @param v2 点2的下标，第几个顶点 * @param weight 表示点1与点2是否相互连接 */ public void InsertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; //显示邻接矩阵图 public void ShowGraph() &#123; System.out.print(&quot; &quot;); for(int i=0;i&lt;VertexNum();i++) System.out.print(vertexList.get(i)+&quot; &quot;); System.out.println(); for(int j=0;j&lt;edges.length;j++) &#123; System.out.print(vertexList.get(j)); for(int k=0;k&lt;edges[0].length;k++) &#123; System.out.print(&quot; &quot;+edges[j][k]); &#125; System.out.println(); &#125; &#125; &#125; 测试类我们来实现这一张图： Graph graph = new Graph(5); String[] arr = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;; for(String i:arr) graph.InsertVertex(i); graph.InsertEdge(0, 1, 1); //将A与B建立连接 graph.InsertEdge(0, 2, 1); graph.InsertEdge(2, 3, 1); graph.InsertEdge(0, 4, 1); graph.InsertEdge(1, 2, 1); graph.InsertEdge(2, 4, 1); graph.ShowGraph(); 在图中有2个经典的遍历方法：深度优先与广度优先 DFS深度优先遍历深度优先：depth first search 利用递归的思想，每次搜索都选取得到的数据中的第一个，一直到最深处，再回溯，判断剩下的有没有被遍历，如果没有，接着深入遍历 这个和二叉树在某些程度上有相似性 我们根据上面这张图来进行深度优先遍历分析 我们先从顶点A开始，查找与A有所连接的顶点，选取第1个进行深度遍历， 进入B，查找与B连接的顶点，这个顶点之前没有遍历过，找到C；进入C遍历，C先发现D，对D进行打印输出后，发现D没有下一个连接，于是返回C顶点；C选取第二个E进行操作，打印E后，发现与E连接的之前都遍历过，于是返回C，返回B，返回A，结束 下面是分析图 为了实现这些操作，我们需要一个boolean数组，来存储顶点是否被遍历过 boolean[ ] isVisited = new boolean[ VertexNum()]; /** * * @param index 传入指定的index * 1. 打印出头顶点 * 2. 将头顶点isVisited设为true * 3. 遍历查找与头顶点相连的顶点且not visited * 4. 如果查找到，立马将找到的这个index传入进行递归 * * */ //deep first search, 深度优先遍历 public void DFS(int index) &#123; System.out.print(GetVertex(index)+&quot; &quot;); isVisited[index] = true; for(int j=0;j&lt;VertexNum();j++) if(edges[index][j]&gt;0 &amp;&amp; !isVisited[j]) DFS(j); &#125; BFS广度优先遍历广度优先：broad first search 直白点说，广度优先是横着走，横着遍历，继续拿上面的图举例 我们要先读取A顶点， 打印A，找出与A顶点相连的顶点，发现有B, C, E，将这些点标明isVisited， 把这些顶点存储到容器中（使用队列实现）；从队列中弹出B，打印B，查找与B相连的顶点，若此顶点没有被加入到队列中，压入队列，此时我们发现都在，弹出C， D与C相连且未在队列中， 把D压入队列；弹出E，没有满足条件的其他顶点；弹出D，同上；当队列为空，程序结束 /** * 广度优先使用队列完成 * 先入队列，isvisited设置为true * 进入循环，若队列为空，停止循环 * 循环中，先弹出一个，打印出来 * 根据这个顶点查找与其连接，且没有入队列的 * 如果发现，入队列，isVisited为true * 直到循环结束 * @param index 指向的顶点 */ //BFS 广度优先broad first search public void BFS(int index) &#123; queue.add(index); isVisited[index] = true; while(!queue.isEmpty()) &#123; index = queue.pop(); System.out.print(GetVertex(index)+&quot; &quot;); for(int j=0;j&lt;VertexNum();j++) &#123; if(edges[index][j] &gt;0 &amp;&amp; !isVisited[j]) &#123; queue.add(j); isVisited[j] = true; &#125; &#125; &#125; &#125; 总和测试类package Graphs; public class Graph_Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Graph graph = new Graph(5); String[] arr = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;; for(String i:arr) graph.InsertVertex(i); graph.InsertEdge(0, 1, 1); graph.InsertEdge(0, 2, 1); graph.InsertEdge(2, 3, 1); graph.InsertEdge(0, 4, 1); graph.InsertEdge(1, 2, 1); graph.InsertEdge(2, 4, 1); graph.ShowGraph(); System.out.println(&quot;深度优先&quot;); graph.DFS(0); graph.ClearVisit(); System.out.println(&quot;\\n广度优先&quot;); graph.BFS(0); &#125; &#125; 图类package Graphs; import java.util.ArrayList; import java.util.LinkedList; public class Graph &#123; private ArrayList&lt;String&gt; vertexList; LinkedList&lt;Integer&gt; queue; private int[][] edges; private int numOfEdges;//边的数目 boolean[] isVisited; /** * * @param n 传入顶点个数 */ Graph(int n)&#123; edges = new int[n][n]; //以二维邻接矩阵来构建图 vertexList = new ArrayList&lt;&gt;(n);//用于存储顶点信息 queue = new LinkedList&lt;&gt;(); isVisited= new boolean[n]; numOfEdges =0; &#125; /** * * @return 有多少个顶点 */ public int VertexNum() &#123; return vertexList.size(); &#125; /** * * @return 有多少条边 */ public int EdgeLength() &#123; return numOfEdges; &#125; /** * * @param index 传入下标 * @return 返回对应的顶点 */ public String GetVertex(int index) &#123; return vertexList.get(index); &#125; /** * * @param v1 * @param v2 * @return 返回2个顶点的权值 */ public int GetWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 插入节点 * @param vertex */ public void InsertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * * @param v1 点1的下标，第几个顶点 * @param v2 点2的下标，第几个顶点 * @param weight 表示点1与点2是否相互连接 */ public void InsertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; /** * * @param index 传入指定的index * 1. 打印出头顶点 * 2. 将头顶点isVisited设为true * 3. 遍历查找与头顶点相连的顶点且not visited * 4. 如果查找到，立马将找到的这个index传入进行递归 * * */ //deep first search, 深度优先遍历 public void DFS(int index) &#123; System.out.print(GetVertex(index)+&quot; &quot;); isVisited[index] = true; for(int j=0;j&lt;VertexNum();j++) if(edges[index][j]&gt;0 &amp;&amp; !isVisited[j]) DFS(j); &#125; /** * clear isVisited数组 */ //清空visited记录 public void ClearVisit() &#123; isVisited= new boolean[VertexNum()]; &#125; /** * 广度优先使用队列完成 * 先入队列，isvisited设置为true * 进入循环，若队列为空，停止循环 * 循环中，先弹出一个，打印出来 * 根据这个顶点查找与其连接，且没有入队列的 * 如果发现，入队列，isVisited为true * 直到循环结束 * @param index 指向的顶点 */ //BFS 广度优先broad first search public void BFS(int index) &#123; queue.add(index); isVisited[index] = true; while(!queue.isEmpty()) &#123; index = queue.pop(); System.out.print(GetVertex(index)+&quot; &quot;); for(int j=0;j&lt;VertexNum();j++) &#123; if(edges[index][j] &gt;0 &amp;&amp; !isVisited[j]) &#123; queue.add(j); isVisited[j] = true; &#125; &#125; &#125; &#125; //显示邻接矩阵图 public void ShowGraph() &#123; System.out.print(&quot; &quot;); for(int i=0;i&lt;VertexNum();i++) System.out.print(vertexList.get(i)+&quot; &quot;); System.out.println(); for(int j=0;j&lt;edges.length;j++) &#123; System.out.print(vertexList.get(j)); for(int k=0;k&lt;edges[0].length;k++) &#123; System.out.print(&quot; &quot;+edges[j][k]); &#125; System.out.println(); &#125; &#125; &#125; 效果 常用数据结构CRUD时间复杂度总结ArrayListAdd:O(n)添加时会根据指定的index下标去添加，找到下标后，添加然后移位，同样会花费O(n)的时间，有时Array容量不够，我们还需要扩大Array的容量，所以add最坏时间复杂度是O(n) Set:O(1) 与 Get:O(1)Get 与 Set 在进行时，都可以根据下标快速找到位置，所以时间复杂度为O(1) Remove:O(n)当删除时，由于是ArrayList，需要将后面的内容一个一个向前移动1格，时间复杂度为O(n) ArraySet Contain:O(n)contain方法用于判断是否存在此元素，由于是无序array，我们需要从头到尾进行遍历，所以为O(n) Add:O(n)由于是Set，我们在插入元素时，需要考虑插入的元素是否重复，所以要先调用contain方法判断，然后把元素插入到尾部；因为是array，当room满时，需要ensure capacity扩大容量，此时时间复杂度为O(n) Remove:O(n)和arrayList相比，虽然arraySet的remove方法只是将要删除的元素与最后一个进行替换，把最后一个删除，但是在寻找的过程中，时间复杂度依然是O(n) ArraySortedSet这个集合是ArraySet的升级版，当我们存入数据到集合中，我们要对其进行排序，升序或降序 Contain:O(logN)由于是有序的数组，我们可以使用二分查找(Binary Search)算法来查询是否存在，二分查找算法时间复杂度为O(logN) Add:O(n)虽然说在ArraySortedSet中，查找相同的时间为log(n)，但是当我们添加新的元素后，有可能破坏整个数组的order，所以add后还需要进行排序，可以用冒泡排序，从后往前比较，直到最佳，此时的时间复杂度为O(n)； 有些人可能会说冒泡排序时间复杂度不是O(n^2)吗？ 其实当我们添加新的元素后，除去新的元素，原数组依然是有序的，我们从后往前，这样最坏时间就是O(n); 为什么不用快排？ 注意，快排最优也仅仅是O(NlogN),在现在这种情境下时间复杂度远远大于冒泡排序 Remove:O(n)和上面的添加一样，查找时虽然为O(logN)，其最终的最坏时间复杂度依然为O(n),因为需要进行排序最终结果和Add相同：O(n) SingleLinkedList Add:O(n)add方法同样要添加到对应的下标，由于是链表，需要从head开头遍历到对应的下标，所以最坏时间复杂度为O(n) Remove:O(n)删除分为按下标删除与按内容删除，按index下标删除，需要从头遍历至对应下标，所以最坏时间复杂度与add一样O(n)；按内容删除由于要从头开始匹配相应的内容，最坏时间复杂度依然是O(n)，综上O(n) Get:O(n) 与 Set:O(n)为了获取指定下标元素，依然要从头遍历到尾部，所以Get与Set都是O(n) ArrayStackPush: 一般为O(1)但特殊为O(n)使用数组来模拟stack，一般入栈都是O(1),但当栈满时需要扩容ensure capacity,导致时间复杂度变为O(n) Pop: O(1)出栈，都是temp = array[count] = null; count –; return temp; 所以最坏时间复杂度仅仅是O(1) LinkedStackPop: O(1) 与 Push:O(1)stack的操作都是在头部进行，无需遍历，所以是O(1) LinkedQueuePop:O(1) 与 Push:O(1)用2个指针，一个指头，一个指尾，队列是先进先出，出队列pop时操作front指针，时间复杂度为O(1);入队列时操作尾部back指针,时间复杂度为O(1) Linked Setcontains:O(n)链式存储，在寻找对应结点时都需要从头到尾，时间复杂度都为O(n) add:O(n) 与 remove:O(n)由于查找重复元素时间复杂度为O(n)，导致add与remove也是O(n) BSTtree一般情况 特殊情况 add:一般O(logN), 最坏O(N)一般通过比较然后寻找最终的位置，这种比较是O(logN), 但是当整个树变为一条线时，我们要寻找对应的位置，需要遍历整个树才能找到，所以最坏为O(n) remove: 一般O(logN), 最坏O(N)remove的情况与add插入情况一样，当整个树变为一条线时，其最坏时间复杂度也会变为O(N) Disjoint Set并查集 介绍并查集是一种数据结构，其实现简单，仅仅需要几行代码与一个数组就可以实现； 创建一个数组，用于储存每个顶点的父结点，默认都是自己 union合并方法，用于将2个顶点合并在一起 find方法，用于寻找最终的根节点 克鲁斯卡尔算法中就运用到并查集的知识，用于寻找2个顶点之间是否构成回路 我们自动生成迷宫时，也会需要使用disjoint方法，当入口与出口构成回路时，我们就完成了迷宫的设计 实现构造函数private int s[]; public Disjoint1(int numElements) &#123; s = new int[numElements]; for(int i=0;i&lt;s.length;i++) s[i] = -1; //初始化默认每个点的根节点就是自己，即-1 &#125; 查//非递归版本 public int find(int x) &#123; int temp=x; while(s[temp]!=-1) temp = s[temp]; return temp; &#125; //递归版本 public int find(int x) &#123; if(s[x] &lt;0) return x; else &#123; return find(s[x]); &#125; &#125; 并public void union(int root1, int root2) &#123; if(s[root2]&lt;s[root1]) //root2 is depper s[root1] = root2; //make root2 new root else &#123; if(s[root1] == s[root2]) s[root1] --; //Update height if same s[root2] = root1; //make root1 new root &#125; &#125; 路径压缩对于路径压缩，我们是在find函数中进行修改，当我们寻找到一个顶点的根节点后，在递归时，我们把剩下的顶点的根节点都设为最后一个顶点的根节点，这样可以简化下次递归的深度 public int find(int x) &#123; if(s[x] &lt;0) return x; else &#123; return s[x] = find(s[x]); //path compression, decrease the running time &#125; &#125; 当然，这种方法也有个缺点，如下图 我们如果使用find(4),这样可以使整个树扁平化 但是如果我们使用find(3)，最后只能使包含3在内的之前的顶点扁平化 应用判断是否构成环路传入一个二维数组，包含这张图的信息 每个顶点对应的下标按照英文字母的顺序排列，从0开始 package DisjointSet; public class CircleJudge &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[][] a= &#123; &#123;0, 1&#125;, &#123;0, 2&#125;, &#123;0, 4&#125;, &#123;1, 2&#125;, &#123;2, 4&#125;, &#123;2, 3&#125;, &#125;; isCircle(a, 5); &#125; private static int[] p; /*查找root*/ private static int find(int x) &#123; if(p[x] &lt;0) return x; else &#123; return p[x] = find(p[x]); &#125; &#125; /*合并,前提是没构成环路*/ //构成环路返回true private static boolean union(int i, int j) &#123; int x=find(i); int y =find(j); if(x!=y) &#123; if(p[y] &lt; p[x]) p[x]= y; else &#123; p[y] =x; &#125; return false; &#125;else &#123; return true; &#125; &#125; public static void isCircle(int[][] a, int len) &#123; /*初始化*/ p = new int[len]; for(int i=0;i&lt;p.length;i++) p[i]=-1; boolean rst; for(int[] i:a) &#123; rst = union(i[0],i[1]); if(rst) &#123; System.out.println(&quot;These data include circle&quot;); break; &#125; &#125; &#125; &#125; Kruskal算法package algorithm; import java.util.Collections; import java.util.LinkedList; /** * Kruskar算法 * 1. 创建每条边的List * 2. 把边添加进List * 3. 对List排序 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路 * @author 23881 * */ public class KruskalAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;; // int[][] weight= &#123; // &#123;0,3,3,7&#125;, // &#123;3,0,2,4&#125;, // &#123;3,2,0,6&#125;, // &#123;7,4,6,0&#125; // &#125;; String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] weight= &#123; &#123;0,12,0,0,0,16,14&#125;, &#123;12,0,10,0,0,7,0&#125;, &#123;0,10,0,3,5,6,0&#125;, &#123;0,0,3,0,4,0,0&#125;, &#123;0,0,5,4,0,2,8&#125;, &#123;16,7,6,0,2,0,9&#125;, &#123;14,0,0,0,8,9,0&#125; &#125;; Kruskar(data, weight); &#125; public static void Kruskar(String[] data, int[][] weight) &#123; boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;Edge&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false&amp;&amp; isVisited[j][i] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); for(Edge&lt;String&gt; e:list) System.out.println(e.print(data)); System.out.println(); int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓, Disjoint Set int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; for(Edge&lt;String&gt; e:result) System.out.println(e.print(data)); &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; &#125; 算法：递归介绍递归是一种常见的算法，由递归书写的代码较为简洁，一般用于处理有规律的循环问题，与for类似。直白点说，递归就是函数自己调用自己；在使用递归时，注意留出口（递归循环结束），否则程序会无限递归下去，最终ERROR。当然因为递归表示比较简洁，理解起来也是算法的一大难点。 例子下面写2个关于递归的例子： 打印3！(3的阶乘) 从0到9报数 //计算阶乘 package DataStructure; public class FactorialWithRecursion &#123; public static void main(String[] args) &#123; System.out.println(factorial(3)); &#125; public static int factorial(int n) &#123; if (n == 1) &#123;//出口 return n; &#125; return n*factorial(n-1); &#125; &#125; 递归的本质还是栈，当要运行一道程序时，java虚拟机会在栈中开辟一道空间 下面用一张图来说明这几行代码 假如我们没有给出对应的出口，n==1,编译器会报错 从0到9报数 package DataStructure; public class RecursionDemo2 &#123; public static void main(String[] args) &#123; System.out.println(print(9)); &#125; public static int print(int num) &#123; if(num==0) &#123; return 0; &#125; System.out.println(print(num-1)); return num; &#125; &#125; 排列组合排列：上，下，左，右 很明显，上下左右的排列可以用递归来完成 需要2个容器，一个容器temp来存储暂时读取的字符，还有一个list用来存储最终结果 每次把字符存入temp时，要考虑temp中是否包含此字符，(用for遍历)如果有，跳过添加 当暂时存储的容器temp为4时，把此时temp中的字符串存入list，然后返回 返回后要将temp最后一个元素清除，例如：此时temp是“上下左右”，添加进list后，去除temp最后一个元素，temp就是“上下左”，由于此时for已循环，回到上一个递归：temp为“上下右” 暂时容器使用stringbuffer 最终容器使用arraylist package DataStructure; import java.util.ArrayList; public class DirectionRecursion &#123; public static void main(String[] args) &#123; char[] directions = &#123;&#39;上&#39;,&#39;下&#39;,&#39;左&#39;,&#39;右&#39;&#125;; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); test(list, directions, new StringBuffer()); Iterator&lt;String&gt; itr = list.iterator(); int count = 0; while(itr.hasNext()) &#123; System.out.println(itr.next()); count+=1; &#125; System.out.println(&quot;一共有&quot;+count+&quot;种可能&quot;); &#125; public static void test(ArrayList&lt;String&gt; list,char[] directions,StringBuffer temp) &#123; if(temp.length() == directions.length) &#123; list.add(temp.toString()); return; &#125; for(int i=0;i&lt;directions.length;i++) &#123; if(temp.toString().indexOf(directions[i])!=-1) continue; temp.append(directions[i]); test(list, directions, temp); temp.deleteCharAt(temp.length()-1); &#125; &#125; &#125; 利用递归解决迷宫问题思路问题：小球在迷宫中运动，怎样到达终点 使用二维数组先创建迷宫 创建一个boolean方法，接收map和初始位置i, j 数字1表示墙，数字2表示可以走的点，数字3表示不能走的点 当小球寻路时（下-&gt;右-&gt;左-&gt;上），我们需要用递归的方法： 先判断小球是否已经到达终点，到达终点，返回true 没有就进入寻路的递归中：我们假设下一步能走的通，即map[i] [j] =2； 先向下走得通，返回true，直到走不通，将走不通的点标为3，返回false（返回上一个位置）；向下继续走不通，就向右走，循环递归，直到走不通为止； 代码package DataStructure; public class MazeRecursionDemo &#123; public static void main(String[] args) &#123; // 构建地图 int[][] map = new int[10][10]; for (int a = 0; a &lt; map[0].length; a++) &#123; map[0][a] = 1; map[map.length - 1][a] = 1; &#125; for (int b = 0; b &lt; map.length; b++) &#123; map[b][0] = 1; map[b][map[0].length - 1] = 1; &#125; map[1][5] = 1; map[2][5] = 1; map[3][5] = 1; map[3][1] = 1; map[3][2] = 1; map[3][3] = 1; map[5][3] = 1; map[5][4] = 1; map[5][5] = 1; map[5][6] = 1; map[5][7] = 1; map[5][8] = 1; System.out.println(&quot;\\t地图&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; tryWay(map, 1,1); System.out.println(); System.out.println(&quot;\\t路线&quot;); for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; public static boolean tryWay(int[][] map, int i, int j) &#123; //如果到达终点，直接返回true，程序结束 if (map[8][8] == 2) &#123; return true; &#125; //没有到达终点 else &#123; //如果所在位置之前没有走过，之前走过标为2，也不能走 if(map[i][j] ==0) &#123; //假设能走通 map[i][j] = 2; //向下走得通 if (tryWay(map, i+1, j)) &#123; return true; &#125; //向右走得通 else if (tryWay(map, i, j+1)) &#123; return true; &#125; //向左走得通 else if (tryWay(map, i, j - 1)) &#123; return true; &#125; //向上走得通 else if (tryWay(map, i-1, j)) &#123; return true; &#125; //上下左右都走不通 else &#123; //表示这个点不能走，返回上一个节点 map[i][j] = 3; return false; &#125; &#125; //所在位置是墙，或不能走的位置，或已经走过的地方 else &#123; //map[i][j] =1或2或3 return false; //返回false，返回上一个节点位置 &#125; &#125; &#125; &#125; 迷宫最优解（目前）小球在迷宫中移动，其走的路径长短很大一部分与其设定的方向有关，当我们开始递归时，小球的方向就已经确定下来，所以为了找出小球按照哪种方向形式走才能达到最小路径，我们需要使用排列组合；通过“上下左右”的排列组合，得出所有方向，然后在程序中我们要小球按照我们给出的方向行走，最终统计步数，相比较得出最佳方向 “上下左右”的排列组合上文已经给出解法，下面我们要与前面的迷宫程序相结合 因为小球在迷宫中走的方向都是我们设定好的，所以在递归时我们要加上一个String direction for(int a=0;a&lt;4;a++) &#123; //由于一定要判断上下左右的方向，但是顺序不同，我用一个for循环来读取direction中的四个方向 switch (direction.charAt(a)) &#123; case &#39;上&#39;: //向上走得通 if (tryWay(map, i-1, j,direction)) &#123; return true; &#125; break; case &#39;下&#39;: //向下走得通 if (tryWay(map, i+1, j, direction)) &#123; return true; &#125; break; case &#39;左&#39;: //向左走得通 if (tryWay(map, i, j - 1, direction)) &#123; return true; &#125; break; case &#39;右&#39;: //向右走得通 if (tryWay(map, i, j+1, direction)) &#123; return true; &#125; break; default: break; &#125; &#125; 最终package DataStructure; import java.util.ArrayList; import java.util.Collection; import java.util.Collections; import java.util.HashMap; import java.util.Iterator; import java.util.Map.Entry; public class MazeRecursionDemo2 &#123; public static void main(String[] args) &#123; // 构建地图 int[][] map = new int[10][10]; InitMap(map); //地图初始化 System.out.println(&quot;\\t地图&quot;); PrintMap(map); //求出最短路径 char[] directions = &#123;&#39;上&#39;,&#39;下&#39;,&#39;左&#39;,&#39;右&#39;&#125;; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Search(list, directions, new StringBuffer()); //Map是用来储存此时的方向与小球运动步数的 HashMap&lt;String, Integer&gt; dic = new HashMap&lt;&gt;(); Iterator&lt;String&gt; itr = list.iterator(); while(itr.hasNext()) &#123; String move = itr.next(); //寻路 tryWay(map, 1,1,move); //统计方向与步数 dic.put(move, Count(map)); //完了要将map还原（初始化） InitMap(map); &#125; System.out.println(); System.out.println(&quot;所有方向可能性与步数&quot;); //集合的打印 for(Entry&lt;String, Integer&gt; i : dic.entrySet()) &#123; System.out.println(&quot;\\t&quot;+i.getKey()+&quot;----&quot;+i.getValue()); &#125; //在集合中比较大小 Collection&lt;Integer&gt; values = dic.values(); int smallest = Collections.min(values); System.out.println(); System.out.println(&quot;最优的路径----步数：&quot;+smallest); for(Entry&lt;String, Integer&gt; i : dic.entrySet()) &#123; if(i.getValue() == smallest) &#123; System.out.println(&quot;\\t&quot;+i.getKey()); tryWay(map, 1,1,i.getKey()); PrintMap(map); InitMap(map); &#125; &#125; &#125; //打印地图 public static void PrintMap(int[][] map) &#123; for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; System.out.print(map[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; //初始化地图 public static void InitMap(int[][] map) &#123; for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; map[i][j] =0; &#125; &#125; for (int a = 0; a &lt; map[0].length; a++) &#123; map[0][a] = 1; map[map.length - 1][a] = 1; &#125; for (int b = 0; b &lt; map.length; b++) &#123; map[b][0] = 1; map[b][map[0].length - 1] = 1; &#125; map[1][5] = 1; map[2][5] = 1; map[3][5] = 1; map[3][1] = 1; map[3][2] = 1; map[3][3] = 1; map[5][3] = 1; map[5][4] = 1; map[5][5] = 1; map[5][6] = 1; map[5][7] = 1; map[5][8] = 1; &#125; //统计小球走的路径距离 public static int Count(int[][] map) &#123; int cnt=0; for (int i = 0; i &lt; map.length; i++) &#123; for (int j = 0; j &lt; map[0].length; j++) &#123; if(map[i][j] ==2 ||map[i][j] ==3) &#123; cnt++; &#125; &#125; &#125; return cnt; &#125; //使用递归改变方向（上下左右的排列组合） public static void Search(ArrayList&lt;String&gt; list,char[] directions,StringBuffer sb) &#123; if(sb.length() == directions.length) &#123; list.add(sb.toString()); return; &#125; for(int i=0;i&lt;directions.length;i++) &#123; if(sb.toString().indexOf(directions[i])!=-1) continue; sb.append(directions[i]); Search(list, directions, sb); sb.deleteCharAt(sb.length()-1); &#125; &#125; //使用递归寻找出口 public static boolean tryWay(int[][] map, int i, int j, String direction) &#123; //如果到达终点，直接返回true，程序结束 if (map[8][8] == 2) &#123; return true; &#125; //没有到达终点 else &#123; //如果所在位置之前没有走过，之前走过标为2，也不能走 if(map[i][j] ==0) &#123; //假设能走通 map[i][j] = 2; for(int a=0;a&lt;4;a++) &#123; switch (direction.charAt(a)) &#123; case &#39;上&#39;: //向上走得通 if (tryWay(map, i-1, j,direction)) &#123; return true; &#125; break; case &#39;下&#39;: //向下走得通 if (tryWay(map, i+1, j, direction)) &#123; return true; &#125; break; case &#39;左&#39;: //向左走得通 if (tryWay(map, i, j - 1, direction)) &#123; return true; &#125; break; case &#39;右&#39;: //向右走得通 if (tryWay(map, i, j+1, direction)) &#123; return true; &#125; break; default: break; &#125; &#125; //上下左右都走不通 //表示这个点不能走，返回上一个节点 map[i][j] = 3; return false; &#125; //所在位置是墙，或不能走的位置，或已经走过的地方 else &#123; //map[i][j] =1或2或3 return false; //返回false，返回上一个节点位置 &#125; &#125; &#125; &#125; 八皇后问题题目：需要在8*8的棋盘上摆棋子，每行摆一个，每个棋子不能在同一列或同一对角线上 需要用到回溯思想，比如第4行的棋子不能放在和第3行棋子的同一列上，为了避免这样，第4行的棋子在第四行上一个一个试，假如都不可以，回到第3行，更改第3行的棋子位置，再尝试第4行，戒指第5行，不行就往回 程序package DataStructure; public class EightGueenDemo &#123; //定义一个max表示一共有多少个皇后 int max =8; //定义一个一维数组，数组下标表示第几行，下标对应的数表示第几列 int[] array =new int[max]; int count=0; public static void main(String[] args) &#123; EightGueenDemo queen = new EightGueenDemo(); queen.check(0); System.out.printf(&quot;一共有%d种可能&quot;,queen.count); &#125; //打印数组 public void print() &#123; for(int i=0;i&lt;array.length;i++) &#123; System.out.print(array[i]+&quot; &quot;); &#125; System.out.println(); &#125; //判断是否安全(冲突) //n表示第n个皇后 public boolean safe(int n) &#123; for(int i=0;i&lt;n;i++) &#123; //表示在同一列或同一斜线 if(array[i] ==array[n] || Math.abs(n-i)==Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; //编写方法，放置第n个皇后 public void check(int n) &#123; if(n==max) &#123; print(); count++; return; &#125; //一共要放8个皇后，8个循环递归， for(int i=0;i&lt;max;i++) &#123; //先把该皇后放在第n行第i列 array[n] =i; //是否冲突 if(safe(n)) &#123; //如果不冲突，接着放第n+1个皇后，递归 check(n+1); &#125; //如果冲突，i++,将皇后在第n行向后移动一位，直到不冲突 &#125; &#125; &#125; 算法：排序算法最优有一句谚语：“All roads lead to Rome.” 面对一个编程问题时，我们有多种方法来实现； 但是怎样才能判断哪种方法才是最优的呢？ 我们运行程序，当然希望程序越快，占内存越小；但是速度与空间，就像杠杆中的力臂与力，两者必须做出取舍。如果选择速度快，即时间复杂度小，程序所占内存空间的大小就会增加；而希望程序占内存小，程序运行的速度也会随之受影响。 当然，现如今大家考虑最优一般是从速度（时间复杂度）的角度出发。 时间频度时间频度，一个算法中的语句执行的次数称为时间频度，记作T(n) 随着程序规模的变大，时间频度的常数项、低次项、系数可以忽略 例子同样是计算100以内数的和，我们有2种实现方法 int total =0; //1， for循环相加 int end=100; for(int i=1;i&lt;=end;i++)&#123; total += i; &#125; //2，利用等差数列公式 total =(1+end)*end /2; 第一种方法的时间频度：T(n) = n+1 //因为进入循环+判断 第二种方法的时间频度：T(n) = 1 //直接计算得出结果 时间复杂度时间复杂度，也叫大O时间复杂度，表示方法是O(n) 由于程序规模的变大，时间频度有些地方可以忽略，从而产生了时间复杂度 例如，T(n) = n^2 +7n+6 ; T(n) = 3n^2 +2n+2 两者虽然时间频度不同，但是时间复杂度确实一样，都是O(n^2) 常见的时间复杂度 阶 例子 常数阶 O(1) 12 对数阶 O(logn) 5log2n+20 平方阶(双层for循环) O(n^2) 3n^2+2n+1 线性阶 O(n) 2n+3 线性对数阶 O(nlogn) 2n+3nlog2n+19 立方阶(三层for循环) O(n^3) 6n^3+2n^2+3n+4 指数阶(要尽量避免) O(2^n) 2^n+3 k次方阶 O(n^k) n^k 时间复杂度排序，由小变大：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(n^k) &lt; O(2^n) 冒泡排序（Bubble Sorting）用2个指针比较2个数，从左往右，如果第1个大于第2个，两个数交换位置 因为排序的数字是一个一个累加的，所以称之为冒泡排序 将指针从左往右遍历，需要一次for循环 至多遍历4次，才能达到最终的顺序，还需要for循环 第1次遍历完后，数组最后一个元素可以不用比较了， 所以for循环大小-1，也就是说： 第一次 —- array.length -1 第二次 —- array.length -2 第三次 —- array.length -3 第四次 —- array.length -4 所以： package Sorting; import java.util.Arrays; public class BubbleSorting &#123; public static void main(String[] args) &#123; int[] array = &#123;3, 9, -1, 10, -2&#125;; int tmp =0; for(int i=array.length-1; i&gt;0; i--) &#123; for(int j=0;j&lt;i;j++) &#123; if(array[j] &gt; array[j+1]) &#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] =tmp; &#125; &#125; &#125; System.out.println(Arrays.toString(array)); &#125; &#125; 冒泡排序优化 假设给出的数组原来就是有序的，或仅仅经过2次就正序了，我们可以直接跳出循环，中止程序 package Sorting; import java.util.Arrays; public class BubbleSorting &#123; public static void main(String[] args) &#123; // int[] array = &#123;3, 9, -1, 10, -2&#125;; int[] array = &#123;3,2,6,4,5&#125;; int tmp =0; boolean flag=false; //flag判断是否进行了排序交换 for(int i=array.length-1; i&gt;0; i--) &#123; for(int j=0;j&lt; i;j++) &#123; if(array[j] &gt; array[j+1]) &#123; tmp = array[j]; array[j] = array[j+1]; array[j+1] =tmp; flag = true; &#125; &#125; System.out.println(&quot;第&quot;+(array.length-i)+&quot;次遍历&quot;); System.out.println(Arrays.toString(array)); if(!flag) &#123; break; &#125;else &#123; flag = false; //用于判断下一次有没有交换，如果没有，表示数据已正序 &#125; &#125; &#125; &#125; 第1次遍历在交换顺序，第2次遍历判断是否正序 因为有2个嵌套式的循环，冒泡排序的时间复杂度是n^2 选择排序（Select Sorting）选择排序和冒泡排序很像，但是两者还是有所区别 在选择排序中，我们要选择最小的数据，并把最小的数据放到整个数组最前面 当我们遍历数组查找最小元素时，我们仅仅记下最小元素下标，只有当前数组遍历结束时，数组才会发生交换，效率相比于冒泡排序（每次遍历都要相互交换）大大提高。 int[] array = &#123;101,34,119,1&#125;; //第一轮将最小的移到最前面 1, 34, 119, 101 //第二轮将剩下的最小的移到前面 1, 34, 119, 101 //第三轮将剩下的最小的移到前面 1，34，101，119 从上我们可以看出，每次循环遍历后，初始位置都会向后挪1位（因为最小的已经在前面了） 我们依次比较剩下的数，所以需要array.length-1次才能将数从小到大依次移到前面 package Sorting; import java.util.Arrays; public class SelectionSorting &#123; public static void main(String[] args) &#123; int[] array = &#123;101,34,119,1&#125;; for(int i=0;i&lt;array.length-1;i++) &#123; int smallest=i; for(int j=i;j&lt;array.length;j++) &#123; if(array[j]&lt; array[smallest]) &#123; smallest = j;//我们仅仅记下最小元素下标 &#125; &#125; //结束遍历后才能发生交换 if(i!=smallest) &#123; int temp = array[i]; array[i] = array[smallest]; array[smallest] = temp; &#125; System.out.println(&quot;第&quot;+(i+1)+&quot;轮循环：&quot;+Arrays.toString(array)); &#125; &#125; &#125; 插入排序（Insert Sorting） 第1轮：我们从第2个数开始，把第2个数和前面的数进行比较，从右往左，如果第2个数小于第1个数，两者交换位置 第2轮：我们从第3个数开始，把第3个数和前面的数进行比较（0，1），如果第3个数小于第2个数，两者交换，如果交换后，第1个数比交换后的第2个数大，继续交换，直至到最后 …… 第n轮：从第n+1个数开始，把第n+1个数和前面的数(n个数)进行比较，找个合适的地方插入（这就是插入排序） 一共有array.length-1轮 package Sorting; import java.util.Arrays; public class InsertSorting &#123; public static void main(String[] args) &#123; int[] array = &#123; 93, 54, 77, 31, 44, 226, 55 &#125;; int temp; //换位法 for (int i = 1; i &lt; array.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125;else &#123; break; &#125; &#125; //移位法 // temp = array[i]; // int j =i; // while(j&gt;0 &amp;&amp; temp&lt;array[j-1]) &#123; // array[j] = array[j - 1]; // j--; // &#125; // // if (j != i) &#123; // array[j] = temp; // &#125; System.out.println(&quot;第&quot; + i + &quot;轮：&quot; + Arrays.toString(array)); &#125; &#125; &#125; 希尔排序（Shell Sorting）希尔排序是由希尔所发现的，所以命名为Shell Sorting. 希尔排序本质上还是插入排序Insert Sorting, 但是希尔排序运行效率相比上面大大提升。 第一轮： 排序前要先给数据分组，让数组的长度/2，即array.length /2, 得出的是组中数据的间隔。我们在分好的组内进行插入排序，间距此时是array.length 除以2。第1组插入排序进行完后，移入第2组，依次进行，直到最后一组。 第二轮： 总体和上面一样，但是每组数据的间隔是之前的一半，(array.length/2)/2 … 直到最后一轮，步数为1，普通的插入排序，但是遍历次数减少 package Sorting; import java.util.Arrays; public class ShellSorting &#123; public static void main(String[] args) &#123; int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;; int length = array.length; int temp; //步长 for(int step = length/2;step &gt;0; step /=2) &#123; //插入算法循环次数 for(int i=step;i&lt;length;i++) &#123; //控制插入算法的比较和交换 //移位法 temp = array[i]; int j =i; if(array[j] &lt; array[j-step]) &#123; while(j&gt;=step &amp;&amp; temp&lt;array[j-step]) &#123; array[j] = array[j - step]; j-=step; &#125; &#125; array[j] = temp; /** * 换位法 for(int j=i;j&gt;=step;j-=step) &#123; if(array[j]&lt;array[j-step]) &#123; temp = array[j]; array[j] = array[j-step]; array[j-step] = temp; &#125; else break; &#125; */ &#125; System.out.println(Arrays.toString(array)); &#125; &#125; &#125; 快速排序（Quick Sorting）快速排序是一种非常经典的排序算法，它的运行效率非常高，当然快排属于空间换时间的一类，因为要使用递归。 For very small arrays (N ≤ 20), quicksort does not perform as well as insertion sort 注意，快排在数字很多的时候才会展现其有时，当数据很少，例如小于20时，快排并不比插入排序好多少 基本思路： 选取数组最中间的数为基数（以这个数为基准），用2个指针分别从最左边和最右边读取数据，将小于基数的数放在左边，大于基数的数放在右边。最后排完，小于的都在左侧，大的都在右侧。我们继续进行递归，由于此时左侧和右侧的指针都指向基数，为了分别进行左排序递归和右排序递归，左侧指针右移1格，右指针左移1格。 图解： （哎，图片不清晰） package Sorting; import java.util.Arrays; public class QuickSorting2 &#123; public static void main(String[] args) &#123; // int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;; int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;; QuickSort(array, 0, array.length-1); System.out.println(Arrays.toString(array)); &#125; public static void QuickSort(int[] array, int left, int right) &#123; int l =left; int r =right; int temp; int pivot = array[(left+right)/2]; while(l&lt;r) &#123; //左边往右走 while(array[l]&lt;pivot) &#123; l+=1; &#125; //右边往左走 while(array[r]&gt;pivot) &#123; r -=1; &#125; if(l&gt;=r) &#123; break; &#125; temp =array[l]; array[l]=array[r]; array[r] = temp; //交换后发现array[l] == pivot的值 r--;前移 if(array[l] == pivot) &#123; r -=1; &#125; //交换后发现array[r] == pivot的值 l++;前移 if(array[r] == pivot) &#123; l +=1; &#125; &#125; //递归 if(left&lt;r) &#123; QuickSort(array, left, r-1); &#125; if(right&gt;l) &#123; QuickSort(array, l+1, right); &#125; &#125; &#125; 以第一个数为基准的快速排序 package Sorting; import java.util.Arrays; public class QuickSorting3 &#123; public static void main(String[] args) &#123; int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;; Sort(array, 0, array.length-1); System.out.println(Arrays.toString(array)); &#125; public static void Sort(int[] array, int left, int right) &#123; int l = left; int r = right; int pivot = array[left]; //以第一个数为基准 while(true) &#123; while(array[r] &gt;= pivot&amp;&amp;l&lt;r) &#123; r-=1; &#125; if(l&lt;r) &#123; array[l] =array[r]; l+=1; &#125; while(array[l] &lt;= pivot&amp;&amp;l&lt;r) &#123; l +=1; &#125; if(l&lt;r) &#123; array[r] = array[l]; r -=1; &#125; if(l==r) &#123; array[l] = pivot; break; &#125; &#125; if(left&lt;r) &#123; Sort(array, left, r-1); &#125; if(right &gt; l) &#123; Sort(array, l+1, right); &#125; &#125; &#125; 关于Pivot我们也可以根据数组中位数来定，pivot选好对程序的复杂度有直观影响 就像Mark 的 Data Structure And Algorithm Analysis In Java书中写的 Although the algorithm as described works no matter which element is chosen as the pivot, some choices are obviously better than others. The median of a group of N numbers is the [*N/*2]th largest number. The best choice of pivot would be the median of the array 这里贴出Mark的源码 package Sorting; import java.util.Arrays; public class QuickSorting4 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;; quicksort(array); System.out.println(Arrays.toString(array)); &#125; public static void quicksort(int[] a) &#123; quicksort(a, 0, a.length-1); &#125; private static void swapReference(int[] a, int n, int m) &#123; int temp = a[n]; a[n] = a[m]; a[m] = temp; &#125; private static int median3(int[] a, int left, int right) &#123; int center =(left+right)/2; if(a[center] &lt; a[left]) swapReference(a, left, center); if(a[right] &lt; a[left]) swapReference(a, left, right); if(a[right]&lt;a[center]) swapReference(a, center, right); swapReference(a, center, right-1); return a[right-1]; &#125; private static final int CUTOFF =10; private static void quicksort(int[] a, int left, int right) &#123; if(left + CUTOFF &lt;= right) &#123; int pivot = median3(a, left, right); int i = left; int j = right-1; while(true) &#123; while(a[i] &lt; pivot) &#123; i++; &#125; while(a[j]&gt;pivot) &#123; j--; &#125; if(i&lt;j) swapReference(a, i, j); else &#123; break; &#125; &#125; swapReference(a, i, right-1); quicksort(a, left, i-1); quicksort(a, i+1, right); &#125;else &#123; InsertSorting.insertsort(a, left, right); &#125; &#125; &#125; 归并排序（Merge Sorting）归并排序和上面的快速排序思想上类似，都用到了经典的分治算法(divide and conquer),即先将复杂的问题划分divide成小的问题然后递归求解，然后再conquer（把各个划分阶段的答案修补在一起） Divide Conquer 为了方便操作，我们传进去的数组会被复制，输出的是一个新的数组，这个数组就是排序好的数组 Divide分的时候要采用递归，每次分2份，直到数组每个元素都被分别分在1个数组中 当递归完后，回溯时从最后一个数组开始，即一个一个元素的数组，返回上一层，将此时的数组赋给left或right，接着调用Conquer，把2个数组排序放入一个新的数组，然后再返回，依次进行，直到全部排序完成 package Sorting; import java.util.Arrays; public class MergeSorting &#123; public static void main(String[] args) &#123; // int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;; int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;; MergeSort(array); System.out.println(Arrays.toString(array)); &#125; public static void MergeSort(int[] arr)&#123; int[] temp = new int[arr.length]; Divide(arr, temp, 0, arr.length-1); &#125; private static void Divide(int[] arr, int[] temp, int left, int right)&#123; int pivot = (left+right)/2; if(left&lt;right)&#123; Divide(arr, temp, left, pivot); Divide(arr, temp, pivot+1, right); Conquer(arr, temp, left, pivot+1, right); &#125; &#125; private static void Conquer(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd)&#123; int nums = rightEnd - leftPos +1; int leftEnd = rightPos -1; int cur = leftPos; while(leftPos&lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123; if(arr[leftPos].compareTo(arr[rightPos])&lt;0) temp[cur++] = arr[leftPos++]; if(arr[leftPos].compareTo(arr[rightPos])&gt;0) temp[cur++] = arr[rightPos++]; else&#123; temp[cur++] = arr[leftPos++]; temp[cur++] = arr[rightPos++]; &#125; &#125; while(leftPos&lt;=leftEnd)&#123; temp[cur++] = arr[leftPos++]; &#125; while(rightPos &lt;= rightEnd)&#123; temp[cur++] = arr[rightPos++]; &#125; for(int i=0;i&lt;nums;i++, rightEnd--) arr[rightEnd] = temp[rightEnd]; &#125; 堆排序（Heap Sort）前面在二叉树时讲了，这里就只贴部分代码 package Sorting; import java.util.Arrays; public class HeapSorting2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Integer[] arr = &#123; 35, 10, 25, 15, 30, 40, 20, 50, 45 &#125;; HeapSorting(arr); System.out.println(Arrays.toString(arr)); &#125; /** * internal method for heapsort * @param i the index of an item in the heap * @return the index of the left child */ private static int leftChild(int i) &#123; return 2*i +1; &#125; /** * Internal method for heapsort that is used in deleteMax and buildHeap * @param &lt;AnyType&gt; anyType is a generic type * @param a an array of comparable items * @param i the position from which to precolate down * @param n the logic size of the binary heap */ private static &lt;AnyType extends Comparable &lt;? super AnyType&gt;&gt; void precDown(AnyType[] a, int i, int n) &#123; int child; AnyType temp; for(temp =a[i]; leftChild(i) &lt; n;i=child) &#123; child = leftChild(i); //找出三个中最大的 if(child != n-1 &amp;&amp; a[child].compareTo(a[child+1])&lt;0) //判断左边小于右边 child++; if(temp.compareTo(a[child])&lt;0) //判断父结点是否小于子节点 a[i] =a[child]; else &#123; break; &#125; &#125; a[i] =temp; &#125; /** * * @param &lt;AnyType&gt; * @param a an array of Comparable items * @param b the top item of the heap * @param c the bottom item of the heap */ private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void SwapReference (AnyType[] a, int b, int c) &#123; AnyType temp = a[b]; a[b] = a[c]; a[c] = temp; &#125; /** * Standard heapsort * @param &lt;AnyType&gt; * @param a an array of Comparable items */ public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void HeapSorting(AnyType[] a) &#123; for(int i=a.length/2; i &gt;=0 ;i--) &#123; /*Build Heap*/ precDown(a, i, a.length); &#125; for(int i=a.length-1; i&gt;0;i--) &#123; SwapReference(a, 0, i); /*Delete the Max*/ precDown(a, 0, i); &#125; &#125; &#125; 基数排序（Radix Sorting）基数排序是特殊的桶排序 步骤： 先将数组按个位排序分类，分好后一个一个放入原数组 再把数组按照十位排序分类，同上 直到分到原数组中最大数的位数，例如最大数是3789，我们最后就要按照千位来排序 由小到大，这样依次我们就完成对数组的排序 package Sorting; import java.util.Arrays; public class RedixSorting &#123; public static void main(String[] args) &#123; int[] array = &#123;77,26,93,17,54,107,31,44,55,20 &#125;; RadixSort(array); System.out.println(Arrays.toString(array)); &#125; public static void RadixSort(int[] array) &#123; //找出最大的一位 int Max =0; for(int i=0;i&lt;array.length;i++) &#123; if(array[Max] &lt;array[i]) &#123; Max =i; &#125; &#125; //得出最大一位的个数 int count=0; int temp =array[Max]; while(temp&gt;0) &#123; temp /= 10; count++; &#125; for(int j=0;j&lt;count;j++) &#123; busket(array, pow(10,j)); &#125; &#125; //计算一个数的几次方 public static int pow(int num, int exp) &#123; if(exp==0) &#123; return 1; &#125; for(int i=0;i&lt;exp-1;i++) &#123; num *= num; &#125; return num; &#125; public static void busket(int[] array, int digit) &#123; //创建一个桶用来记录数据 int[][] bucket = new int[10][array.length]; //创建一个数组来记录每个桶里面元素的个数 int[] itemNum = new int[10]; for(int i=0;i&lt;array.length;i++) &#123; int no = array[i]/digit%10; //哪一个桶 bucket[no][itemNum[no]] = array[i] +10; itemNum[no] +=1; &#125; int index=0; for(int j=0;j&lt;10;j++) &#123; for(int k=0;k&lt;bucket.length;k++) &#123; if(bucket[j][k] !=0) &#123; array[index] = bucket[j][k]-10; bucket[j][k] =0; index++; &#125; else &#123; break; &#125; &#125; itemNum[j] =0; &#125; index =0; &#125; &#125; 排序算法的时间复杂度比较 排序法 平均时间 最差情况 冒泡 O(n^2) O(n^2) 交换 O(n^2) O(n^2) 选择 O(n^2) O(n^2) 插入 O(n^2) O(n^2) 基数 O(logR B) O(logR B) Shell O(nlogn) O(n^s) 1&lt;s&lt;2 快排 O(nlogn) O(n^2) 归并 O(nlogn) O(nlogn) 堆 O(nlogn) O(nlogn) 术语： 稳定：两个数据在排序后任然保持之前的相对前后位置 时间复杂度：算法运行所消耗的时间 测试程序 package Sorting; import java.text.SimpleDateFormat; import java.util.Date; public class TestSortingTime &#123; public static void main(String[] args) &#123; int[] array = new int[80000]; Init(array); System.out.println(&quot;BubbleSorting&quot;); PrintTime(&quot;Start: &quot;); BubbleSorting(array); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;SelectionSorting&quot;); PrintTime(&quot;Start: &quot;); SelectionSorting(array); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;InsertSorting&quot;); PrintTime(&quot;Start: &quot;); InsertSorting(array); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;ShellSorting&quot;); PrintTime(&quot;Start: &quot;); ShellSorting(array); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;QuickSorting&quot;); PrintTime(&quot;Start: &quot;); QuickSort(array, 0, array.length-1); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;QuickSorting2&quot;); PrintTime(&quot;Start: &quot;); QuickSort2(array, 0, array.length-1); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;MergeSorting&quot;); PrintTime(&quot;Start: &quot;); MergeSort(array); PrintTime(&quot;End: &quot;); System.out.println(); Init(array); System.out.println(&quot;RedixSorting&quot;); PrintTime(&quot;Start: &quot;); RadixSort(array); PrintTime(&quot;End: &quot;); &#125; public static void Init(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = (int) (Math.random() * 80000); &#125; &#125; public static void PrintTime(String words) &#123; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;); String time = sdf.format(date1); System.out.println(words + time); &#125; public static void BubbleSorting(int[] array) &#123; int tmp = 0; boolean flag = false; // flag判断是否进行了排序交换 for (int i = array.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; tmp = array[j]; array[j] = array[j + 1]; array[j + 1] = tmp; flag = true; &#125; &#125; if (!flag) &#123; break; &#125; else &#123; flag = false; // 用于判断下一次有没有交换，如果没有，表示数据已正序 &#125; &#125; &#125; public static void SelectionSorting(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int smallest = i; for (int j = i; j &lt; array.length; j++) &#123; if (array[j] &lt; array[smallest]) &#123; smallest = j; &#125; &#125; if (i != smallest) &#123; int temp = array[i]; array[i] = array[smallest]; array[smallest] = temp; &#125; &#125; &#125; public static void InsertSorting(int[] array) &#123; int temp; for (int i = 1; i &lt; array.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125;else &#123; break; &#125; &#125; &#125; &#125; public static void ShellSorting(int[] array) &#123; int length = array.length; int temp; for(int step = length/2;step &gt;0; step /=2) &#123; for(int i=step;i&lt;length;i++) &#123; temp = array[i]; int j =i; if(array[j] &lt; array[j-step]) &#123; while(j&gt;=step &amp;&amp; temp&lt;array[j-step]) &#123; array[j] = array[j - step]; j-=step; &#125; &#125; if (j != i) &#123; array[j] = temp; &#125; // for(int j=i;j&gt;=step;j-=step) &#123; // if(array[j]&lt;array[j-step]) &#123; // temp = array[j]; // array[j] = array[j-step]; // array[j-step] = temp; // &#125; // else // break; // &#125; &#125; &#125; &#125; public static void QuickSort(int[] array, int left, int right) &#123; int l =left; int r =right; int temp; int pivot = array[(left+right)/2]; while(l&lt;r) &#123; //左边往右走 while(array[l]&lt;pivot) &#123; l+=1; &#125; //右边往左走 while(array[r]&gt;pivot) &#123; r -=1; &#125; if(l&gt;=r) &#123; break; &#125; temp =array[l]; array[l]=array[r]; array[r] = temp; //不进行下面的操作程序会卡死 //交换后发现array[l] == pivot的值 r--;前移 if(array[l] == pivot) &#123; r -=1; &#125; //交换后发现array[r] == pivot的值 l++;前移 if(array[r] == pivot) &#123; l +=1; &#125; &#125; if(left&lt;r) &#123; QuickSort(array, left, r-1); &#125; if(right&gt;l) &#123; QuickSort(array, l+1, right); &#125; &#125; public static void QuickSort2(int[] array, int left, int right) &#123; int l = left; int r = right; int pivot = array[left]; while(true) &#123; while(array[r] &gt;= pivot&amp;&amp;l&lt;r) &#123; r-=1; &#125; if(l&lt;r) &#123; array[l] =array[r]; l+=1; &#125; while(array[l] &lt;= pivot&amp;&amp;l&lt;r) &#123; l +=1; &#125; if(l&lt;r) &#123; array[r] = array[l]; r -=1; &#125; if(l==r) &#123; array[l] = pivot; break; &#125; &#125; if(left&lt;r) &#123; QuickSort2(array, left, r-1); &#125; if(right &gt; l) &#123; QuickSort2(array, l+1, right); &#125; &#125; //归并排序 public static void MergeSort(int[] arr) &#123; int[] arr2 = Divide(arr); for(int i=0;i&lt;arr2.length;i++) &#123; arr[i]=arr2[i]; &#125; &#125; public static int[] Divide(int[] arr) &#123; int pivot = (arr.length)/2; if(pivot&gt;=1) &#123; int[] left = new int[pivot]; int[] right = new int[arr.length-pivot]; for(int i=0;i&lt;left.length;i++) &#123; left[i] = arr[i]; &#125; for(int j=0;j&lt;right.length;j++) &#123; right[j]=arr[pivot+j]; &#125; left = Divide(left); right = Divide(right); return Conquer(left, right); &#125; return arr; &#125; public static int[] Conquer(int[] arr1, int[] arr2) &#123; int[] temp = new int[arr1.length+arr2.length]; int cur =0; int left =0; int right =0; while(true) &#123; if(arr1[left]&lt;arr2[right]) &#123; temp[cur] = arr1[left]; cur++; left++; &#125; else if(arr1[left] &gt; arr2[right]) &#123; temp[cur] = arr2[right]; cur++; right++; &#125; else &#123; temp[cur] =arr1[left]; cur++; left++; temp[cur] = arr2[right]; cur++; right++; &#125; if(left&gt;=arr1.length) &#123; for(int i=right;i&lt;arr2.length;i++) &#123; temp[cur] = arr2[i]; cur++; &#125; break; &#125; else if(right&gt;=arr2.length)&#123; for(int i=left;i&lt;arr1.length;i++) &#123; temp[cur] = arr1[i]; cur++; &#125; break; &#125; &#125; return temp; &#125; public static void RadixSort(int[] array) &#123; //找出最大的一位 int Max =0; for(int i=0;i&lt;array.length;i++) &#123; if(array[Max] &lt;array[i]) &#123; Max =i; &#125; &#125; //得出最大一位的个数 int count=0; int temp =array[Max]; while(temp&gt;0) &#123; temp /= 10; count++; &#125; for(int j=0;j&lt;count;j++) &#123; busket(array, pow(10,j)); &#125; &#125; //计算一个数的几次方 public static int pow(int num, int exp) &#123; if(exp==0) &#123; return 1; &#125; for(int i=0;i&lt;exp-1;i++) &#123; num *= num; &#125; return num; &#125; public static void busket(int[] array, int digit) &#123; //创建一个桶用来记录数据 int[][] bucket = new int[10][array.length]; //创建一个数组来记录每个桶里面元素的个数 int[] itemNum = new int[10]; for(int i=0;i&lt;array.length;i++) &#123; int no = array[i]/digit%10; //哪一个桶 bucket[no][itemNum[no]] = array[i] +10; itemNum[no] +=1; &#125; int index=0; for(int j=0;j&lt;10;j++) &#123; for(int k=0;k&lt;bucket.length;k++) &#123; if(bucket[j][k] !=0) &#123; array[index] = bucket[j][k] -10; bucket[j][k] =0; index++; &#125; else &#123; break; &#125; &#125; itemNum[j] =0; &#125; index =0; &#125; &#125; ​ 运行结果 查找算法二分查找二分查找的条件是必须在有序数组中 3种查询方法 把数组复制再查询 public static boolean search(int[] array, int num) &#123; int index = array.length/2; if(array.length &gt;=1)&#123; if(array[index] &gt; num) &#123; int[] left = Arrays.copyOfRange(array,0,index); return search(left, num); &#125; else if(array[index] &lt; num) &#123; int[] right = Arrays.copyOfRange(array, index+1, array.length); return search(right, num); &#125; else if(array[index] == num) &#123; return true; &#125; &#125; return false; &#125; 数组不复制，对下标进行操作 System.out.println(search(array, 31, 0, array.length-1)); public static boolean search(int[] array, int num, int left, int right) &#123; int index = (left+right)/2; if(left&gt;right) &#123; return false; &#125; print(array, left, right); if(array[index] &gt; num) &#123; return search(array, num, left, index-1); &#125; else if(array[index] &lt; num) &#123; return search(array, num, index+1, right); &#125; else &#123; return true; &#125; &#125; 非递归法 public static boolean search(int[] array, int num) &#123; int left =0; int right = array.length-1; while(left &lt;= right) &#123; int mid = (left+right)/2; if(array[mid] == num) &#123; return true; &#125; else if(array[mid] &gt; num) &#123; right = mid -1; &#125; else &#123; left = mid+1; &#125; &#125; return false; &#125; 插值查找相比于二分查找，插值查找改变了查找的基数，假如差值大，基数就大，差值小，跨度就小。可以说插值查找就是二分查找的改进。 package Search; public class InsertSearching &#123; public static void main(String[] args) &#123; int[] array = &#123;17, 20, 26, 31, 44,44, 54, 55, 77, 93&#125;; System.out.println(search(array, 1, 0, array.length-1)); &#125; //递归版本 public static boolean search(int[] array, int num, int left, int right) &#123; int index = left+(right-left)*(num-array[left])/(array[right]-array[left]); if(left&gt;right || index&lt;0) &#123; return false; &#125; if(array[index] &gt; num) &#123; return search(array, num, left, index-1); &#125; else if(array[index] &lt; num) &#123; return search(array, num, index+1, right); &#125; else &#123; return true; &#125; &#125; &#125; 程序员必会十大算法1. 二分查找算法介绍二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图 这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N) 代码实现二分查找有2种实现方法：递归版和非递归版 非递归版 //非递归版本 public static int search(int[] array, int num) &#123; int left =0; //left表示左侧下标 int right = array.length-1; //right表示右侧下标 while(left &lt;= right) &#123; //结束的条件是左边大于右边 int mid = (left+right)/2; //我们假设中间的数是目标 if(array[mid] == num) &#123; // 判断，是 return mid; //返回下标 &#125; else if(array[mid] &gt; num) &#123; //判断发现中间的数比目标数大 right = mid -1; //把中间的数的下标设置为右边， 减1是因为mid已经判断过了，比num大 &#125; else &#123; //若小，则设置为左边 left = mid+1;//加1的原因和上面类似 &#125; &#125; return -1; //找完后发现没有找到，返回-1 &#125; 递归版本 具体步骤和上面非递归版本类似，推荐非递归版本 //递归版本 public static boolean search(int[] array, int num, int left, int right) &#123; int index = (left+right)/2; if(left&gt;right) &#123; return -1; &#125; print(array, left, right); if(array[index] &gt; num) &#123; return search(array, num, left, index-1); &#125; else if(array[index] &lt; num) &#123; return search(array, num, index+1, right); &#125; else &#123; return index; &#125; &#125; 2. 分治算法介绍分治算法，蕴含分而治之的思想，Divide and Conquer. 我们把难的问题逐个逐个拆分，拆分为小的问题，然后对于这个小的问题我们要给出解决办法，最后一步一步返回过去，将难的问题给解决，使用分治算法时，我们还利用了递归的思想，从拆分到组合 代码实现我们举汉诺塔的例子来讲分治算法 故事大家也都知道 大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 64个盘看似很多，我们把这64个简化为3个 3个盘，我们先把上面两个盘想办法从第1个柱子移到第2个柱子 为了按照大小的顺序移动，先把第1个盘从第1个柱子移到第3个柱子，第2个盘从第1个柱子移到第2个柱子 接着把盘从第3个柱子移到第2个柱子 然后，把仅存在第1个柱子的盘移到第3个柱子 最后想办法把第2个柱子上的盘移到第3个柱子 先把第2个柱子上的移到第1个柱子 再把最后一个移到第3个柱子 最后一步 把盘从第1个柱子移到第3个柱子 假设有n个盘，3个柱A, B, C 把n-1个盘从A到B 最后1个从A到C 再把n-1个盘从B移到C 落实到代码 package algorithm; public class HanoiTower &#123; static int count=0; public static void main(String[] args) &#123; // TODO Auto-generated method stub move(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;); System.out.println(count); &#125; public static void move(int num, char a, char b, char c) &#123; if(num==1) &#123; //只有1个盘，从A移动到C System.out.println(a+&quot;-&gt;&quot;+c); count++; &#125; else &#123; //把n-1个盘，从A移动到B move(num-1, a, c, b);//由于实参和形参的不同，我们可以改变实参以达到变换的目的 System.out.println(a+&quot;-&gt;&quot;+c); count++; //再把剩下的从B移动到C move(num-1,b,a,c); &#125; &#125; &#125; 3. 动态规划算法介绍和上面的分治算法有点类似，都是把复杂或大的问题拆解为小的问题，然后求解 不同在于，动态规划算法每一步和上一步之间有联系，所以动态规划算法适用于重叠的子问题求解 动态规划算法通常用于求解（最大值和最小值），在应用动态规划之前要分析能否把大问题拆解为小问题，然后每个小问题都是最优解。 动态规划算法从上往下分析问题，从下往上解决问题，先解决最小的问题，再解决最大问题。 常见的利用动态规划算法求解的莫过于背包问题（01背包问题） 去商店买东西，背包有固定的容量，我们每个物品有且只能装入1次，最后我们要挑选出价值最高的物品组合。 为了获取每个子问题的最优解，我们用二维数组来解决背包问题 列表示背包容量 行表示对应的商品 第1列我们也设置为0 用双重for循环，从左往右，从上往下 当然，由于我们第1行和第1列都设置为0，我们从第2列和第2行开始bag[1][1] 从左往右，判断背包容量是否可以装入吉他，不行读取上面1格的值，然后向后，发现2kg可以装入吉他，把吉他装入，设置为$200， 走到电脑这一行，1kg无法放下，读取上面1格的值，向后，还是不行，继续向后，直到能装下，4kg，和上一个做对比，看哪个最后的值大，把大的放入 最后一行是书， 与上文一样，直到bag容量为3kg时，我们先装入1本书，还剩余2kg，我们选取没加这本书的时候的最佳值，也就是书所在上一行，剩余容量所在的位置的值， 就是$200 + $100, 然后我们比较和上一行的大小 0 kg 1 kg 2 kg 3 kg 4 kg $0 $0 $0 $0 $0 吉他 $0 $0 $200 $200 $200 电脑 $0 $0 $200 $200 $300 书 $0 $100 $200 $200+$100 $300 代码实现我们除了要知道背包能存入的最大值，还应该知道存入的是哪些物品，所以我们还需要一个二维数组用来表示存了哪些物品 int[][] path=new int[n+1][m+1]; 存入path所在的位置为1， 没有就是默认的0 打印 1 kg 2 kg 3 kg 4 kg 0 0 0 0 0 吉他 0 0 1 1 1 电脑 0 0 0 0 1 书 0 1 0 1 0 打印从右下角开始向上读，如果此时的标记为1，打印这个下标对应商品的下标，横坐标减去这个商品对应的容量 //为了显示装入的物品有哪些 int i=path.length-1; int j=path[0].length-1; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(path[i][j]==1) &#123; System.out.printf(&quot;把%s放入背包\\n&quot;,obj[i-1]); j -= w[i-1]; &#125; i--; &#125; 最后 package algorithm; public class Dynamic_Programming_Bag2 &#123; public static void main(String[] args) &#123; String[] obj = &#123;&quot;Guitar&quot;,&quot;Computer&quot;,&quot;Book&quot;&#125;; int[] v= &#123;200,300,100&#125;; int[] w= &#123;2,4,1&#125;; int m =4;//背包的容量 int n = w.length;//物品的个数 //背包 int[][] bag =new int[n+1][m+1]; //存储数组 int[][] path=new int[n+1][m+1]; for(int i=0;i&lt;bag.length;i++) bag[i][0]=0;//第一列设置为0 for(int i=0;i&lt;bag[0].length;i++) bag[0][i]=0;//第一行设置为0 for(int i=1;i&lt;bag.length;i++) &#123; for(int j=1;j&lt;bag[0].length;j++) &#123; if(w[i-1]&gt;j) &#123; //容量不满足，直接继承上面一个 bag[i][j] = bag[i-1][j]; &#125;else &#123; //容量满足，和上面一个对比，选取最佳的value //装入i-1个商品，到剩余空间j-w[i]的最大值 // bag[i][j] = Math.max(bag[i-1][j], v[i-1]+bag[i-1][j-w[i-1]]); if(bag[i-1][j]&lt;v[i-1]+bag[i-1][j-w[i-1]]) &#123; bag[i][j] = v[i-1]+bag[i-1][j-w[i-1]]; //把当前情况记录到path path[i][j]=1; &#125;else &#123; bag[i][j] = bag[i-1][j]; &#125; &#125; &#125; &#125; //打印背包的Table //i表示行 //j表示列 for(int i=0;i&lt;bag.length;i++) &#123; for(int j=0;j&lt;bag[0].length;j++) &#123; System.out.printf(bag[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; //为了显示装入的物品有哪些 int i=path.length-1; int j=path[0].length-1; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(path[i][j]==1) &#123; System.out.printf(&quot;把%s放入背包\\n&quot;,obj[i-1]); j -= w[i-1]; &#125; i--; &#125; &#125; &#125; 4. 贪婪算法介绍贪婪算法，又称贪心算法，Greedy Algorithm。 在解决问题时，每次都选择最好的情况，用这种方法得出最后的解，注意：虽然贪婪算法每次都选最好的，但是最后的结果并不一定是最佳的 广播集合覆盖问题（贪心算法的应用） 我们要构建广播站，每个广播站覆盖的地区不一样，有些有交叉的地方，我们要用哪些广播站去覆盖全部地区。 如图 地区： 北京、上海、天津、广州、深圳、成都、杭州、大连 电台 覆盖数 地区 K1 3 北京、上海、天津 K2 3 广州、北京、深圳 K3 3 成都、上海、杭州 K4 2 上海、天津 K5 2 杭州、大连 从电台里面选，哪些电台组合在一起就覆盖了全部地区？ 首先，我们将每个电台与其覆盖的地区放入HashMap中， Key是电台名称， Value是储存此电台覆盖地区的HashSet。然后我们还要创建一个HashSet用来储存所有地区名称， 一个ArrayList储存最后的结果 我们构建一个循环，每次从循环找出地区数覆盖最多的电台，将这个电台加入到ArrayList中，然后从所有地区中清除这些地区，接着循环，当地区集合大小为0时停止。 这个看代码比较好理解 代码实现package algorithm; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub HashMap&lt;String, HashSet&lt;String&gt;&gt; radios = new HashMap&lt;&gt;(); HashSet&lt;String&gt; k1 = new HashSet&lt;&gt;(); k1.add(&quot;北京&quot;); k1.add(&quot;上海&quot;); k1.add(&quot;天津&quot;); HashSet&lt;String&gt; k2 = new HashSet&lt;&gt;(); k2.add(&quot;广州&quot;); k2.add(&quot;北京&quot;); k2.add(&quot;深圳&quot;); HashSet&lt;String&gt; k3 = new HashSet&lt;&gt;(); k3.add(&quot;成都&quot;); k3.add(&quot;上海&quot;); k3.add(&quot;杭州&quot;); HashSet&lt;String&gt; k4 = new HashSet&lt;&gt;(); k4.add(&quot;上海&quot;); k4.add(&quot;天津&quot;); HashSet&lt;String&gt; k5 = new HashSet&lt;&gt;(); k5.add(&quot;杭州&quot;); k5.add(&quot;大连&quot;); radios.put(&quot;k1&quot;, k1); radios.put(&quot;k2&quot;, k2); radios.put(&quot;k3&quot;, k3); radios.put(&quot;k4&quot;, k4); radios.put(&quot;k5&quot;, k5); HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;(); allAreas.addAll(k1); allAreas.addAll(k2); allAreas.addAll(k3); allAreas.addAll(k4); allAreas.addAll(k5); ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); String MaxKey = null; while(!allAreas.isEmpty()) &#123; for(String key:radios.keySet()) &#123; HashSet&lt;String&gt; temp = radios.get(key); temp.retainAll(allAreas); //选取交集 //必须交集大于0 或者 交集的大小大于最大的大小 if( temp.size() &gt;0 &amp;&amp; (MaxKey == null || temp.size() &gt; radios.get(MaxKey).size())) &#123; MaxKey = key; //才能赋值 &#125; &#125; //当最大赋值不为NULL时，把答案添加进去，移除对应的地区 if(MaxKey != null) &#123; result.add(MaxKey); allAreas.removeAll(radios.get(MaxKey)); &#125; &#125; System.out.println(result); &#125; &#125; 5. KMP算法介绍KMP算法是常见的匹配字符串的算法，起初由名字里含有K, M, P的3个人所创建。讨论KMP算法之前我们要先了解暴力匹配字符串算法 暴力匹配算法为什么叫暴力匹配算法？这个方法虽然也是算法，也能帮我们解决问题，但是它的运行效率是比较低的。 找出‘FFD’所匹配的字符串的下标 第一行字符串假设为s1 第二行是s2 在While循环中，用s2的下标向s1的下标进行匹配，若所指下标不匹配，s2向后挪动1格 如此一直到s1上的FFD与s2上的FFD相互匹配，此时返回下标，当然这个下标应该要减去s2的长度 暴力匹配代码实现package algorithm; public class ViolentMatching &#123; public static void main(String[] args) &#123; //暴力匹配算法 System.out.println(matching(&quot;ABCDBCEFFDHFCD&quot;,&quot;FFD&quot;)); &#125; public static int matching(String str1, String str2) &#123; int i=0; int j=0; char[] s1 =str1.toCharArray(); char[] s2 =str2.toCharArray(); while(i&lt;s1.length &amp;&amp; j&lt;s2.length) &#123; if(s1[i] == s2[j]) &#123; //相匹配，两下标各向后移动1 i++; j++; &#125; else &#123; //发现不匹配，s2的下标从头开始， s1的下标应该减去刚才匹配的长度然后+1 i= i-j+1; j=0; &#125; &#125; //最后找到返回下标 if(j==s2.length) return i-j; else &#123; return -1; &#125; &#125; &#125; 在暴力匹配当中，s2每次只往后移动1格，有些之前匹配过的还要再匹配，一旦字符串较长时，匹配所需要的时间就会增加很多，所以我们需要用KMP算法来进行优化 String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;; String str2 =&quot;ABCDABD&quot;; KMP在实现匹配之前要根据s2的前后缀最大公共元素的长度来建立一个匹配池 A B C D A B D 0 0 0 0 1 2 0 字串 前缀 后缀 最大公共长度 A 空 空 0 AB A B 0 ABC A, AB BC, C 0 ABCD A,AB,ABC BCD, CD, D 0 ABCDA A,AB,ABC,ABCD BCDA, CDA, DA, A 1 ABCDAB A, AB, ABC, ABCD, ABCDA BCDAB, CDAB, DAB, AB, B 2 ABCDABD A, AB, ABC, ABCD, ABCDA, ABCDAB BCDABD, CDABD, DABD, ABD, BD, D 0 有了匹配表后，我们要对之前暴力匹配的算法进行更新 //若字符匹配不相等 //KMP算法核心 while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123; j = map[j-1]; &#125; //失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 KMP代码实现package algorithm; public class KMPAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;; String str2 =&quot;ABCDABD&quot;; System.out.println(KMP(str1, str2, MatchMap(str2))); &#125; /** * 构建字符匹配表 * @param dest 传入字符串 * @return 返回匹配后的数组 */ public static int[] MatchMap(String dest) &#123; int[] map = new int[dest.length()]; map[0]=0; for(int i=1, j=0; i&lt;dest.length();i++) &#123; //KMP算法核心 while(j &gt;0 &amp;&amp; dest.charAt(i)!=dest.charAt(j)) &#123; j = map[j-1]; &#125; //部分匹配值+1 if(dest.charAt(i)==dest.charAt(j)) &#123; j++; &#125; map[i] =j; &#125; return map; &#125; /** * * @param st1 被匹配的长字符串 * @param st2 拿来匹配的字符串 * @param map 字符匹配表 * @return 返回-1 或对应匹配的位置 */ public static int KMP(String st1, String st2, int[] map) &#123; for(int i=0, j=0;i&lt;st1.length();i++) &#123; //若字符匹配不相等 //KMP算法核心 while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123; j = map[j-1]; &#125; //字符匹配相等 if(st1.charAt(i)==st2.charAt(j)) &#123; j++; &#125; if(j &gt;= st2.length()) return i-j+1; &#125; return -1; &#125; &#125; 6. Prim算法介绍Prim算法用于解决修路最短路径问题，有7个村庄，要用路把它们连接，问怎么修路使总路程最短，且路可以到达每个村庄 最小生成树问题 这个问题要利用图的知识来求解 需要构建二维数组（邻接矩阵）来表示顶点间的关系 既然每个顶点只能访问一次，需要一个boolean 数组，来储存该顶点是否被访问过 最终边（路）的条数应该为顶点数-1 为了知道是哪2个顶点之间相互连接，我们要将顶点的数据（顶点是哪2个，边的权值是多少）存起来 图 //使用静态内部类的形式来构建 private static class Graph&#123; public int vertex; public char[] data; int[][] weight; Graph(char[] d, int[][] w)&#123; vertex = d.length; data = d; weight = w; &#125; &#125; 二维数组 int [][] weight= &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; boolean数组 boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 Prim算法的核心 //编写Prim算法，得到最小生成树 /** * * @param v 从图的第几个顶点开始找 */ public void Prim(int v) &#123; boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 isVisited[v] = true; //默认设置从第v个顶点开始 /**用 h1和h2 记录2个顶点的下标*/ int h1=-1; int h2=-1; int max=getMax(); // getMax是一个函数，用于获取此矩阵中的最大值，方便后面做比较 int count=0; //用于统计总路径长度 HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); //储存最后的结果 for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个 int minWeight = max; //双重循环 for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有 if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight //比目前最大的数要小 &amp;&amp; graph.weight[i][j] != 0) &#123; //且不为0 minWeight = graph.weight[i][j]; //将最小的换为此时的权重 h1=i; h2=j; //标记这2个点 &#125; &#125; &#125; isVisited[h2] = true; //第二个点设为已访问，之后会从这一行开始访问 result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]); count += graph.weight[h1][h2]; &#125; System.out.println(); for(Entry&lt;String, Integer&gt; rst:result.entrySet()) System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue()); System.out.println(&quot;Min Path: &quot;+count); &#125; 代码实现package algorithm; import java.util.Arrays; import java.util.HashMap; import java.util.Map.Entry; public class PrimAlgorithm &#123; public static void main(String[] args) &#123; char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;; //邻接矩阵的关系用二维数组来表示 int [][] weight= &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; MinTree tree = new MinTree(); tree.createGraph(new Graph(data, weight)); tree.showGraph(); tree.Prim(0); &#125; private static class MinTree&#123; private Graph graph; //创建图的邻接矩阵 public void createGraph(Graph g) &#123; graph = g; &#125; //打印图 public void showGraph() &#123; for(int[] w:graph.weight) System.out.println(Arrays.toString(w)); &#125; //编写Prim算法，得到最小生成树 /** * * @param v 从图的第几个顶点开始找 */ public void Prim(int v) &#123; boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 isVisited[v] = true; //默认设置从第v个顶点开始 /**用 h1和h2 记录2个顶点的下标*/ int h1=-1; int h2=-1; int max=getMax(); int count=0; HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个 int minWeight = max; //双重循环 for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有 if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight &amp;&amp; graph.weight[i][j] != 0) &#123; minWeight = graph.weight[i][j]; h1=i; h2=j; &#125; &#125; &#125; isVisited[h2] = true; //设置成访问，之后会从这一行开始访问 result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]); count += graph.weight[h1][h2]; &#125; System.out.println(); for(Entry&lt;String, Integer&gt; rst:result.entrySet()) System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue()); System.out.println(&quot;Min Path: &quot;+count); &#125; private int getMax() &#123; int max=graph.weight[0][0]; for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; if(graph.weight[i][j]&gt;max) max = graph.weight[i][j]; &#125; &#125; return max; &#125; &#125; private static class Graph&#123; public int vertex; public char[] data; int[][] weight; Graph(char[] d, int[][] w)&#123; vertex = d.length; data = d; weight = w; &#125; &#125; &#125; 优化上面的代码时间复杂度很高，（n^3）， 一般的Prim算法时间复杂度仅（n^2），下面贴出更改后的代码 package algorithm; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.LinkedList; import java.util.Map.Entry; public class PrimAlgorithm2 &#123; private static int INF=Integer.MAX_VALUE; public static void main(String[] args) &#123; // TODO Auto-generated method stub char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;; //不相邻的顶点，用INF表示 int [][] map= &#123; &#123;0,5,7,INF,INF,INF,2&#125;, &#123;5,0,INF,9,INF,INF,3&#125;, &#123;7,INF,0,INF,8,INF,INF&#125;, &#123;INF,9,INF,0,INF,4,INF&#125;, &#123;INF,INF,8,INF,0,5,4&#125;, &#123;INF,INF,INF,4,5,0,6&#125;, &#123;2,3,INF,INF,4,6,0&#125; &#125;; System.out.println(&quot;Start&quot;); Prim(1, map, data); &#125; //输入起始顶点，邻接矩阵，顶点信息 public static void Prim(int start, int[][] map, char[] data) &#123; //用于存储最终的各种信息 HashMap&lt;String, Integer&gt; paths = new HashMap&lt;&gt;(); //存储整个data长度 int num = data.length; //存放前顶点 int[] pre =new int[num]; //权重 int[] weights = new int[num]; //初始化 for(int i=0;i&lt;weights.length;i++) &#123; weights[i] = map[start][i]; //默认权重以start为基准 //与start顶点相连 if(weights[i] !=INF) pre[i] =start; //把前节点设为start &#125; //start自身权重为0 weights[start] =0; //start前结点为-1，即不存在 pre[start] =-1; //主体程序 for(int i=0;i&lt; num;i++) &#123; //start顶点前面已经初始化过了 if(i == start) continue; //设置2 个下标，用来记录最短边的顶点 int j=0; int k=0; //最小长度 int min = INF; //从左往右对weights遍历， 找出最小边 while(j &lt; num) &#123; //权重最小且不为0 if(weights[j]!=0 &amp;&amp;weights[j] &lt; min) &#123; min = weights[j]; k = j; //赋值 &#125; j++; &#125; //把最小边相连的一个顶点设为0 weights[k] =0; //重置权重（比较重要） for(int n=0;n&lt;num;n++) &#123; //权重不为0， 且新的两顶点之间权重小于目前的 if(weights[n]!=0 &amp;&amp; map[k][n] &lt; weights[n]) &#123; //更新权重和前节点 pre[n] = k; weights[n] = map[k][n]; &#125; &#125; &#125; //最小生成树信息 for(int i=0;i&lt;num;i++) &#123; if(pre[i] !=-1) &#123; paths.put(data[pre[i]]+&quot;-&quot;+data[i], map[pre[i]][i]); &#125; &#125; //打印信息 int count =0; for(Entry&lt;String, Integer&gt; p:paths.entrySet()) &#123; count += p.getValue(); System.out.println(p.getKey()+&quot; : &quot;+p.getValue()); &#125; //打印最终长度 System.out.println(&quot;Least : &quot;+count); &#125; &#125; 网友的另一种解法，使用优先队列 这里摘取网友的解法 1) Initialize keys of all vertices as infinite and parent of every vertex as -1. 2) Create an empty priority_queue pq. Every item of pq is a pair (weight, vertex). Weight (or key) is used used as first item of pair as first item is by default used to compare two pairs. 3) Initialize all vertices as not part of MST yet. We use boolean array inMST[] for this purpose. This array is required to make sure that an already considered vertex is not included in pq again. This is where Ptim&#39;s implementation differs from Dijkstra. In Dijkstr&#39;s algorithm, we didn&#39;t need this array as distances always increase. We require this array here because key value of a processed vertex may decrease if not checked. 4) Insert source vertex into pq and make its key as 0. 5) While either pq doesn&#39;t become empty a) Extract minimum key vertex from pq. Let the extracted vertex be u. b) Include u in MST using inMST[u] = true. c) Loop through all adjacent of u and do following for every vertex v. // If weight of edge (u,v) is smaller than // key of v and v is not already in MST If inMST[v] = false &amp;&amp; key[v] &gt; weight(u, v) (i) Update key of v, i.e., do key[v] = weight(u, v) (ii) Insert v into the pq (iv) parent[v] = u 6) Print MST edges using parent array. 进一步优化Prim算法进一步优化：以二叉堆或者堆Heap的形式来寻找最小值，就像这样 for(int i=queue.size()/2; i &gt;=0 ;i--) &#123; /*Build Heap*/ BuildHeap(i, queue.size(), queue); &#125; 由于我们寻找min时，使用堆来寻找，时间复杂度为O(logN), // Java program for Prim&#39;s MST for // adjacency list representation of graph import java.util.LinkedList; import java.util.TreeSet; import java.util.Comparator; public class prims &#123; class node1 &#123; // Stores destination vertex in adjacency list int dest; // Stores weight of a vertex in the adjacency list int weight; // Constructor node1(int a, int b) &#123; dest = a; weight = b; &#125; &#125; static class Graph &#123; // Number of vertices in the graph int V; // List of adjacent nodes of a given vertex LinkedList&lt;node1&gt;[] adj; // Constructor Graph(int e) &#123; V = e; adj = new LinkedList[V]; for (int o = 0; o &lt; V; o++) adj[o] = new LinkedList&lt;&gt;(); &#125; &#125; // class to represent a node in PriorityQueue // Stores a vertex and its corresponding // key value class node &#123; int vertex; int key; &#125; // Comparator class created for PriorityQueue // returns 1 if node0.key &gt; node1.key // returns 0 if node0.key &lt; node1.key and // returns -1 otherwise class comparator implements Comparator&lt;node&gt; &#123; @Override public int compare(node node0, node node1) &#123; return node0.key - node1.key; &#125; &#125; // method to add an edge // between two vertices void addEdge(Graph graph, int src, int dest, int weight) &#123; node1 node0 = new node1(dest, weight); node1 node = new node1(src, weight); graph.adj[src].addLast(node0); graph.adj[dest].addLast(node); &#125; // method used to find the mst void prims_mst(Graph graph) &#123; // Whether a vertex is in PriorityQueue or not Boolean[] mstset = new Boolean[graph.V]; node[] e = new node[graph.V]; // Stores the parents of a vertex int[] parent = new int[graph.V]; for (int o = 0; o &lt; graph.V; o++) e[o] = new node(); for (int o = 0; o &lt; graph.V; o++) &#123; // Initialize to false mstset[o] = false; // Initialize key values to infinity e[o].key = Integer.MAX_VALUE; e[o].vertex = o; parent[o] = -1; &#125; // Include the source vertex in mstset mstset[0] = true; // Set key value to 0 // so that it is extracted first // out of PriorityQueue e[0].key = 0; // Use TreeSet instead of PriorityQueue as the remove function of the PQ is O(n) in java. TreeSet&lt;node&gt; queue = new TreeSet&lt;node&gt;(new comparator()); for (int o = 0; o &lt; graph.V; o++) queue.add(e[o]); // Loops until the queue is not empty while (!queue.isEmpty()) &#123; // Extracts a node with min key value node node0 = queue.pollFirst(); // Include that node into mstset mstset[node0.vertex] = true; // For all adjacent vertex of the extracted vertex V for (node1 iterator : graph.adj[node0.vertex]) &#123; // If V is in queue if (mstset[iterator.dest] == false) &#123; // If the key value of the adjacent vertex is // more than the extracted key // update the key value of adjacent vertex // to update first remove and add the updated vertex if (e[iterator.dest].key &gt; iterator.weight) &#123; queue.remove(e[iterator.dest]); e[iterator.dest].key = iterator.weight; queue.add(e[iterator.dest]); parent[iterator.dest] = node0.vertex; &#125; &#125; &#125; &#125; // Prints the vertex pair of mst for (int o = 1; o &lt; graph.V; o++) System.out.println(parent[o] + &quot; &quot; + &quot;-&quot; + &quot; &quot; + o); &#125; public static void main(String[] args) &#123; int V = 9; Graph graph = new Graph(V); prims e = new prims(); e.addEdge(graph, 0, 1, 4); e.addEdge(graph, 0, 7, 8); e.addEdge(graph, 1, 2, 8); e.addEdge(graph, 1, 7, 11); e.addEdge(graph, 2, 3, 7); e.addEdge(graph, 2, 8, 2); e.addEdge(graph, 2, 5, 4); e.addEdge(graph, 3, 4, 9); e.addEdge(graph, 3, 5, 14); e.addEdge(graph, 4, 5, 10); e.addEdge(graph, 5, 6, 2); e.addEdge(graph, 6, 7, 1); e.addEdge(graph, 6, 8, 6); e.addEdge(graph, 7, 8, 7); // Method invoked e.prims_mst(graph); &#125; &#125; // This code is contributed by Vikash Kumar Dubey Time Complexity: The time complexity of the above code/algorithm looks O(V^2) as there are two nested while loops. If we take a closer look, we can observe that the statements in inner loop are executed O(V+E) times (similar to BFS). The inner loop has decreaseKey() operation which takes O(LogV) time. So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV) (For a connected graph, V = O(E)) Prim迷宫生成算法Wiki ‘s Explanation Randomized Prim’s algorithmAn animation of generating a 30 by 20 maze using Prim’s algorithm. This algorithm is a randomized version of Prim’s algorithm. Start with a grid full of walls. Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list. While there are walls in the list: Pick a random wall from the list. If only one of the two cells that the wall divides is visited, then: Make the wall a passage and mark the unvisited cell as part of the maze. Add the neighboring walls of the cell to the wall list. Remove the wall from the list. Note that simply running classical Prim’s on a graph with random edge weights would create mazes stylistically identical to Kruskal’s, because they are both minimal spanning tree algorithms. Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight. 开始让整个图充满墙 我们假设所有的墙为0， 所有可以走的点为1，开始时就会生成这样一张图 选择一个点作为起始点，把临墙加入列表 //墙类 private static class wall&#123; int row; //墙所在的行 int column; //墙所在的列 int a_r; //连接墙一边的行 int a_c;//连接墙一边的列 int b_r;//连接墙另外一边的行 int b_c;//连接墙另外一边的列 wall(int r, int c, int ar, int ac, int br, int bc)&#123; row =r; column =c; a_r = ar; a_c =ac; b_r =br; b_c =bc; &#125; &#125; 选取一个点为起始点，我们选取(1,1)这个点， //获取临墙的方法 private static LinkedList&lt;wall&gt; GetNext(int r, int c, boolean[][] isVisited)&#123; LinkedList&lt;wall&gt; list = new LinkedList&lt;&gt;(); //r 是点所在的行 //c 是点所在的列 //这里要考虑到每种顶点周围墙的情况(我们的迷宫是封闭式的，即边界不能被打破) if(c&lt;isVisited[0].length-2) list.push(new wall(r, c+1, r, c, r, c+2)); if(c&gt;1) list.push(new wall(r, c-1, r, c, r, c-2)); if(r&lt;isVisited.length-2) list.push(new wall(r+1,c, r, c, r+2, c)); if(r&gt;1) list.push(new wall(r-1,c, r, c, r-2, c)); return list; &#125; 当列表中还有墙时，随机从中选取一个墙 如果这个墙只有一个单元格被访问过 从队列中删除这堵墙，让与这堵墙相连的另一边的点的其他墙加入到队列， 墙的两边都被访问过 直接删除这个墙 isVisited[start_r][start_c] = true; LinkedList&lt;wall&gt; list = GetNext(start_c, start_r, isVisited); int index=0; while(!list.isEmpty()) &#123; index = (int)(list.size()*Math.random()); wall w = list.get(index); if(!isVisited[w.b_r][w.b_c]) &#123; list.remove(index); map[w.row][w.column] =1; isVisited[w.b_r][w.b_c] = true; list.addAll(GetNext(w.b_r, w.b_c, isVisited)); &#125;else if(isVisited[w.a_r][w.a_c] &amp;&amp; isVisited[w.b_r][w.b_c]) &#123; list.remove(index); &#125; &#125; 最终代码 package algorithm; import java.util.Arrays; import java.util.LinkedList; public class PrimMazeCreating &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Prim(11,11,1,1); &#125; public static int[][] Prim(int r, int c, int start_r, int start_c) &#123; //init map and isVisited int[][] map = new int[r][c]; boolean[][] isVisited = new boolean[r][c]; for(int i=1;i&lt;map.length;i+=2) &#123; for(int j=1;j&lt;map[0].length;j+=2) &#123; map[i][j]=1; &#125; &#125; isVisited[start_r][start_c] = true; LinkedList&lt;wall&gt; list = GetNext(start_c, start_r, isVisited); int index=0; while(!list.isEmpty()) &#123; index = (int)(list.size()*Math.random()); wall w = list.get(index); if(!isVisited[w.b_r][w.b_c]) &#123; list.remove(index); map[w.row][w.column] =1; isVisited[w.b_r][w.b_c] = true; list.addAll(GetNext(w.b_r, w.b_c, isVisited)); &#125;else if(isVisited[w.a_r][w.a_c] &amp;&amp; isVisited[w.b_r][w.b_c]) &#123; list.remove(index); &#125; &#125; // for(int[] n:map) &#123; // System.out.println(Arrays.toString(n)); // &#125; return map; &#125; private static LinkedList&lt;wall&gt; GetNext(int r, int c, boolean[][] isVisited)&#123; LinkedList&lt;wall&gt; list = new LinkedList&lt;&gt;(); if(c&lt;isVisited[0].length-2) list.push(new wall(r, c+1, r, c, r, c+2)); if(c&gt;1) list.push(new wall(r, c-1, r, c, r, c-2)); if(r&lt;isVisited.length-2) list.push(new wall(r+1,c, r, c, r+2, c)); if(r&gt;1) list.push(new wall(r-1,c, r, c, r-2, c)); return list; &#125; private static class wall&#123; int row; int column; int a_r; int a_c; int b_r; int b_c; wall(int r, int c, int ar, int ac, int br, int bc)&#123; row =r; column =c; a_r = ar; a_c =ac; b_r =br; b_c =bc; &#125; &#125; &#125; 把迷宫用可视化表示后的结果 7. Kruskal算法介绍克鲁斯卡尔算法和上面的Prim算法功能都一样，是找出最短总路径；但是Kruskal算法用另外一种方式来解决这个问题 创建每条边的List 把边添加进List 对List排序 从头到尾读取List， 判断边的两个顶点是否形成回路（Disjoint Set并查集） 为了将顶点间的边进行排序，我们需要创建一个Edge类且实现comparable接口 //Edge也是一个静态内部类 private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; 把所有可能加入list并排序 boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); 克鲁斯卡尔算法的精髓（并查集） int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓 int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; 代码实现package algorithm; import java.util.Collections; import java.util.LinkedList; /** * Kruskar算法 * 1. 创建每条边的List * 2. 把边添加进List * 3. 对List排序 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路 * @author 23881 * */ public class KruskalAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;; // int[][] weight= &#123; // &#123;0,3,3,7&#125;, // &#123;3,0,2,4&#125;, // &#123;3,2,0,6&#125;, // &#123;7,4,6,0&#125; // &#125;; String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] weight= &#123; &#123;0,12,0,0,0,16,14&#125;, &#123;12,0,10,0,0,7,0&#125;, &#123;0,10,0,3,5,6,0&#125;, &#123;0,0,3,0,4,0,0&#125;, &#123;0,0,5,4,0,2,8&#125;, &#123;16,7,6,0,2,0,9&#125;, &#123;14,0,0,0,8,9,0&#125; &#125;; Kruskar(data, weight); &#125; public static void Kruskar(String[] data, int[][] weight) &#123; boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;Edge&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); for(Edge&lt;String&gt; e:list) System.out.println(e.print(data)); System.out.println(); int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓 int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; for(Edge&lt;String&gt; e:result) System.out.println(e.print(data)); &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; &#125; 8. Dijkstra算法介绍Dijkstra算法是解决某个顶点到其他顶点的最小路径问题，（邮差问题） 有A, B,C,D,E,F,G七个村庄，此时派出6个邮差从某点出发给另外几个村庄送信，怎样才能让每个邮差最快到达指定的村庄？ 村庄连接问题，需要用图与广度优先的知识进行求解 构建一个Graph类，这个类用于存储，每个顶点的前访问顶点， PreNode[ ]， 这个和Disjoint Set很相似，同时我们还在这个Graph类里面存储每个顶点的访问情况与到指定顶点的最短距离 private static class Graph&#123; private boolean[] isVisited; //存储是否被访问 private int[] PreNode; //前结点集合 private int[] Dis; //存储到每个顶点的最短距离 private final static int infinity = Integer.MAX_VALUE; //常量 public Graph(int len)&#123; //初始化变量 isVisited = new boolean[len]; PreNode = new int[len]; Dis = new int[len]; //假设每个顶点的前一个顶点都是他们自己 for(int i=0;i&lt;len;i++) &#123; PreNode[i] = -1; Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷 &#125; &#125; //展示最短距离 public void ShowDis() &#123; System.out.println(Arrays.toString(Dis)); &#125; //展示前顶点 public void ShowPreNode() &#123; System.out.println(Arrays.toString(PreNode)); &#125; //展示访问的情况 public void ShowVisited() &#123; System.out.println(Arrays.toString(isVisited)); &#125; //获取某个顶点到目标的最短距离 public int GetDis(int n) &#123; return Dis[n]; &#125; //设置某顶点到目标的最短距离 public void SetDis(int n, int m) &#123; Dis[n] =m; &#125; //获取前访问顶点 public int GetPreNode(int n) &#123; return PreNode[n]; &#125; //设置前访问顶点 public void SetPreNode(int n, int m) &#123; PreNode[n] =m; &#125; //获取顶点的访问状态 public boolean GetVisited(int n) &#123; return isVisited[n]; &#125; //设置顶点的访问状态 public void SetVisited(int n, boolean rst) &#123; isVisited[n] = rst; &#125; &#125; Dijkstra 算法精髓 首先我们要从一个顶点开始，获得与这个顶点连接的顶点 （考虑到之后可能会使用广度优先，我们这里用LinkedList来存储顶点数据） Graph graph = new Graph(matrix[0].length); //初始化一个Graph类 graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列 int[] ContainList = new int[matrix[0].length]; //存储顶点是否在队列中 （用于减少时间复杂度） //把第一个顶点压入队列 list.push(index); ContainList[index] = 1; //0 表示不在队列中， 1 表示在队列中 //暂时变量 int dis=0; int temp =0; //结束的条件就是队列为空 while(!list.isEmpty()) &#123; temp = list.pop(); //从队列中pop一个元素 ContainList[temp] =0; //寻找与此元素相连的顶点 for(int i=0;i&lt;matrix[temp].length;i++) &#123; //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点 if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123; //获取此时的路径长度 dis = matrix[temp][i]+graph.GetDis(temp); //如果这个长度小于已有的长度 if(dis&lt;graph.GetDis(i)) &#123; //对原顶点的长度进行替换 graph.SetPreNode(i, temp); //修改preNode graph.SetDis(i, dis); //能够被压入队列的条件：没被访问过且不在队列中 if(!graph.GetVisited(i) &amp;&amp; ContainList[i]==0) &#123; list.push(i); ContainList[i] =1; &#125; &#125; &#125; &#125; //一个顶点完成遍历后，将其设置为已访问 graph.SetVisited(temp, true); &#125; //打印最终结果 graph.ShowDis(); 最终 代码实现package algorithm; import java.util.Arrays; import java.util.LinkedList; public class DijkstraAlgorithm2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] matrix = &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; Dijkstra(matrix, 0); &#125; /*结束条件：队列为空 * 判断条件：not preNode * 改变Dis与Pre条件 * 小于已有距离 * 压入条件 * not visited 且 不在队列中 * * 遍历完一个点后，将此点改为isvisited * */ //index is the start vertex, matrix is the adjacent matrix(graph) public static void Dijkstra(int[][] matrix, int index) &#123; Graph graph = new Graph(matrix[0].length); //初始化一个Graph类 graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列 int[] ContainList = new int[matrix[0].length]; //把第一个顶点压入队列 list.push(index); ContainList[index] = 1; //暂时变量 int dis=0; int temp =0; //结束的条件就是队列为空 while(!list.isEmpty()) &#123; temp = list.pop(); //从队列中pop一个元素 ContainList[temp] =0; //寻找与此元素相连的顶点 for(int i=0;i&lt;matrix[temp].length;i++) &#123; //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点 if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123; //获取此时的路径长度 dis = matrix[temp][i]+graph.GetDis(temp); //如果这个长度小于已有的长度 if(dis&lt;graph.GetDis(i)) &#123; //对原顶点的长度进行替换 graph.SetPreNode(i, temp); //修改preNode graph.SetDis(i, dis); //能够被压入队列的条件：没被访问过且不在队列中 if(!graph.GetVisited(i) &amp;&amp; ContainList[i]==0) &#123; list.push(i); ContainList[i] =1; &#125; &#125; &#125; &#125; //一个顶点完成遍历后，将其设置为已访问 graph.SetVisited(temp, true); &#125; graph.ShowDis(); &#125; private static class Graph&#123; private boolean[] isVisited; //存储是否被访问 private int[] PreNode; //前结点集合 private int[] Dis; //存储到每个顶点的最短距离 private final static int infinity = Integer.MAX_VALUE; //常量 public Graph(int len)&#123; //初始化变量 isVisited = new boolean[len]; PreNode = new int[len]; Dis = new int[len]; //假设每个顶点的前一个顶点都是他们自己 for(int i=0;i&lt;len;i++) &#123; PreNode[i] = -1; Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷 &#125; &#125; //展示最短距离 public void ShowDis() &#123; System.out.println(Arrays.toString(Dis)); &#125; //展示前顶点 public void ShowPreNode() &#123; System.out.println(Arrays.toString(PreNode)); &#125; //展示访问的情况 public void ShowVisited() &#123; System.out.println(Arrays.toString(isVisited)); &#125; //获取某个顶点到目标的最短距离 public int GetDis(int n) &#123; return Dis[n]; &#125; //设置某顶点到目标的最短距离 public void SetDis(int n, int m) &#123; Dis[n] =m; &#125; //获取前访问顶点 public int GetPreNode(int n) &#123; return PreNode[n]; &#125; //设置前访问顶点 public void SetPreNode(int n, int m) &#123; PreNode[n] =m; &#125; //获取顶点的访问状态 public boolean GetVisited(int n) &#123; return isVisited[n]; &#125; //设置顶点的访问状态 public void SetVisited(int n, boolean rst) &#123; isVisited[n] = rst; &#125; &#125; &#125; 9. Floyd算法介绍Floyd算法解决的问题和上面Dijkstra算法解决的问题一样；Floyd算法更容易理解，但是它的运行效率没有Dijkstra算法高 Floyd算法使用3个for循环进行嵌套 代码实现package algorithm; import java.util.Arrays; public class FloydAlgorithm &#123; public static void main(String[] args) &#123; int N=255; //N表示两个顶点间不相连 String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] matrix = &#123; &#123;0,5,7,N,N,N,2&#125;, &#123;5,0,N,9,N,N,3&#125;, &#123;7,N,0,N,8,N,N&#125;, &#123;N,9,N,0,N,4,N&#125;, &#123;N,N,8,N,0,5,4&#125;, &#123;N,N,N,4,5,0,6&#125;, &#123;2,3,N,N,4,6,0&#125; &#125;; Floyd(data, matrix); &#125; public static &lt;E&gt; void Floyd(E[] d, int[][] m ) &#123; Graph&lt;E&gt; graph = new Graph&lt;&gt;(d, m); // graph.showGraph(); graph.start(); graph.showGraph(); &#125; private static class Graph&lt;E&gt;&#123; private E[] data; private int[][] matrix; Graph(E[] d, int[][] m)&#123; data = d; matrix = new int[data.length][data.length]; for(int i=0;i&lt;data.length;i++) &#123; for(int j=0;j&lt;data.length;j++) &#123; matrix[i][j] = m[i][j]; &#125; &#125; &#125; public void showGraph() &#123; for(int[] m:matrix) System.out.println(Arrays.toString(m)); System.out.println(); for(int[] m:rst) System.out.println(Arrays.toString(m)); System.out.println(); &#125; public void start() &#123; int len=0; //对中间顶点遍历，k是中间顶点的下标 for(int k=0;k&lt;data.length;k++) &#123; //从i顶点出发 for(int i=0;i&lt;data.length;i++) &#123; for(int j=0;j&lt;data.length;j++) &#123; len = matrix[i][k] + matrix[k][j]; //从i出发，经过k，到达j的距离 if(len &lt; matrix[i][j]) &#123; matrix[i][j] = len; &#125; &#125; &#125; &#125; &#125; &#125; &#125; 10. 马踏棋盘算法介绍马踏棋盘问题，也称骑士周游问题，在国际象棋中，马只能走日，从某点出发，怎样才能走完棋盘上每个点，要求不重复？ 马踏棋盘是典型的回溯问题，和迷宫问题属于同一类别 我们要考虑马的移动条件，找出下个能走的点 public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123; ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;(); int X = curPoint.x; //表示列 int Y = curPoint.y; //表示行 if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X-2, Y-1)); if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X-1, Y-2)); if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X+1, Y-2)); if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X+2, Y-1)); if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) ps.add(new Point(X-2, Y+1)); if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row) ps.add(new Point(X-1, Y+2)); if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row) ps.add(new Point(X+1, Y+2)); if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row) ps.add(new Point(X+2, Y+1)); return ps; &#125; 马在棋盘上走，遇到不能走的点要回溯，回溯需要递归的知识 private static void Run(int x, int y, int step) &#123; ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数) isVisited[y][x] = true; ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y)); sort(ps); while(!ps.isEmpty())&#123; Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点 if(!isVisited[p.y][p.x]) Run(p.x, p.y, step+1); &#125; //发现走不了，而且还没走完棋盘上每个点，将此点标为未访问，回溯 if(step &lt; row*coloumn &amp;&amp; ! finish) &#123; ChessBoard[y][x] = 0; isVisited[y][x] = false; &#125;else &#123; //走完，标为结束 finish = true; &#125; &#125; *1. 创建一个二维数组，作为棋盘 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中 *3. 遍历ArrayList中的所有位置，看看哪个可以走通 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0 代码实现package algorithm; import java.awt.Point; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; /** * 马踏棋盘算法 * @author 23881 *1. 创建一个二维数组，作为棋盘 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中 *3. 遍历ArrayList中的所有位置，看看哪个可以走通 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0 */ public class ChessHorseAlgorithm &#123; private static int coloumn;//列 private static int row; //行 private static int[][] ChessBoard; private static boolean[][] isVisited; private static boolean finish = false; public static void main(String[] args) &#123; // TODO Auto-generated method stub Start(8, 8, 2, 1); &#125; /** * * @param c 棋盘的列数 * @param r 棋盘的行数 * @param x 马位于第x列 * @param y 马位于第y行 * @param step 步数 * */ public static void Start(int c, int r, int x, int y) &#123; coloumn = c; row = r; ChessBoard = new int[row][coloumn]; isVisited = new boolean[row][coloumn]; Run(x, y, 1); for(int[] cb: ChessBoard) System.out.println(Arrays.toString(cb)); &#125; private static void Run(int x, int y, int step) &#123; ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数) isVisited[y][x] = true; ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y)); sort(ps); while(!ps.isEmpty())&#123; Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点 if(!isVisited[p.y][p.x]) Run(p.x, p.y, step+1); &#125; if(step &lt; row*coloumn &amp;&amp; ! finish) &#123; ChessBoard[y][x] = 0; isVisited[y][x] = false; &#125;else &#123; finish = true; &#125; &#125; public static void sort(ArrayList&lt;Point&gt; ps) &#123; ps.sort(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point arg0, Point arg1) &#123; // TODO Auto-generated method stub return GetNext(arg0).size() - GetNext(arg1).size(); &#125; &#125;); &#125; public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123; ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;(); int X = curPoint.x; //表示列 int Y = curPoint.y; //表示行 if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X-2, Y-1)); if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X-1, Y-2)); if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X+1, Y-2)); if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X+2, Y-1)); if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) ps.add(new Point(X-2, Y+1)); if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row) ps.add(new Point(X-1, Y+2)); if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row) ps.add(new Point(X+1, Y+2)); if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row) ps.add(new Point(X+2, Y+1)); return ps; &#125; &#125; 算法补充A* 算法原理A搜索算法和Dijkestra算法类似，A算法也是使用一个优先队列（优先队列会自我构建二叉min堆），我们每次poll一个元素，这个元素都是priority最小的，当然这个priority是根据我们存入队列中的数据得来的，比如我们往优先队列中存入node节点，这个node节点要实现comparable接口，这样priority queue在添加时会自动排序 在A*算法中，我们要准备2个队列（open_list与close_list）,open_list用于存储可能的节点，而close_list用于存储已经走过且走得通的节点 node节点判断大小的依据是预期代价（G_cost）和实际代价（H_cost）,G_cost可以是此时节点到终点的距离（为了方便计算，我们只取三角形的两边），H_cost可以是从起点到目前节点走过的距离；根据他们代价总和（F=G+H）， 我们就能选取最小代价的点 具体思路 a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。 b. 把这个节点移到 close list 。 c. 对当前方格的 4个相邻方格的每一个方格？ ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。 ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。 d. 停止，当你 ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者 ◆ 查找终点失败，并且 open list 是空的，此时没有路径。 3. 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。 代码实现package algorithm; import java.util.Arrays; import java.util.Comparator; import java.util.PriorityQueue; import modifier.StaticStudy; public class AstarAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[][] map = &#123; &#123;1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,0,0,0,0,1&#125;, &#123;1,0,0,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,1&#125;, &#123;1,0,0,0,1,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1&#125; &#125;; // int[][] map = PrimMazeCreating.Prim(11, 11, 1, 1); for(int[] a:map) &#123; System.out.println(Arrays.toString(a)); &#125; System.out.println(); // A_Star(map, 1, 1, map.length-2, map[0].length-2); A_Star(map, 2, 2, 2, 6); for(int[] a:map) &#123; System.out.println(Arrays.toString(a)); &#125; &#125; private static class Node implements Comparable&lt;Node&gt;&#123; Node parent; int row; int column; int G_cost; int H_cost; Node(int r, int c, int g, int h, Node p)&#123; row = r; column =c; G_cost = g; H_cost =h; parent =p; &#125; @Override public int compareTo(Node b) &#123; // TODO Auto-generated method stub return this.G_cost+this.H_cost-b.G_cost-b.H_cost; &#125; @Override public boolean equals(Object obj) &#123; // TODO Auto-generated method stub Node temp = (Node) obj; return temp.row == this.row &amp;&amp; temp.column == this.column; &#125; &#125; public static void A_Star(int[][] map, int begin_r, int begin_c,int end_r, int end_c) &#123; PriorityQueue&lt;Node&gt; open_list = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Node&gt; close_list = new PriorityQueue&lt;&gt;(); int[][] Node_Status = new int[map.length][map[0].length]; /** * 0 means the node is neigher in open_list nor in close_list * 1 means the node is in open_list * 2 means the node is in close_list * */ int temp_g = Get_G(begin_r, begin_c, end_r, end_c); int temp_h = 0; open_list.add(new Node(begin_r, begin_c, temp_g, temp_h, null)); Node_Status[begin_r][begin_c] = 1; /** * a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。 b. 把这个节点移到 close list 。 c. 对当前方格的 4个相邻方格的每一个方格？ ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。 ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。 d. 停止，当你 ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者 ◆ 查找终点失败，并且 open list 是空的，此时没有路径。 3. 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。 */ final int wall =1; while(!open_list.isEmpty()) &#123; Node temp = open_list.poll(); close_list.add(temp); // push the node into close_list if(temp.row == end_r&amp;&amp; temp.column == end_c) break; Node_Status[temp.row][temp.column] = 2; // update the status of this node int parent_h = temp.H_cost; //◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作 if(map[temp.row-1][temp.column]!=wall &amp;&amp; Node_Status[temp.row-1][temp.column] ==0) &#123; //◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值 Node nn = new Node(temp.row-1, temp.column, Get_G(temp.row-1, temp.column, end_r, end_c), parent_h+1, temp); // if(Node_Status[temp.row-1][temp.column] ==0) open_list.add(nn); map[temp.row-1][temp.column] =3; &#125; if(map[temp.row+1][temp.column]!=wall &amp;&amp; Node_Status[temp.row+1][temp.column] ==0) &#123; Node nn = new Node(temp.row+1, temp.column, Get_G(temp.row+1, temp.column, end_r, end_c), parent_h+1, temp); // if(Node_Status[temp.row+1][temp.column] ==0) open_list.add(nn); map[temp.row+1][temp.column] =3; &#125; if(map[temp.row][temp.column-1]!=wall &amp;&amp; Node_Status[temp.row][temp.column-1] ==0) &#123; Node nn = new Node(temp.row, temp.column-1, Get_G(temp.row, temp.column-1, end_r, end_c), parent_h+1, temp); // if(Node_Status[temp.row][temp.column-1] ==0) open_list.add(nn); map[temp.row][temp.column-1] =3; &#125; if(map[temp.row][temp.column+1]!=wall &amp;&amp; Node_Status[temp.row][temp.column+1] ==0) &#123; Node nn = new Node(temp.row, temp.column+1, Get_G(temp.row, temp.column+1, end_r, end_c), parent_h+1, temp); // if(Node_Status[temp.row][temp.column+1] ==0) open_list.add(nn); map[temp.row][temp.column+1]=3; &#125; &#125; Object[] arr = close_list.toArray(); Node p =null; for(int i=0;i&lt;arr.length;i++) &#123; Node temp =(Node)arr[i]; if(temp.row == end_r &amp;&amp; temp.column == end_c) &#123; p = temp; break; &#125; &#125; while(p != null) &#123; map[p.row][p.column] =2; p = p.parent; &#125; &#125; private static int Get_G(int begin_r, int begin_c,int end_r, int end_c) &#123; return Math.abs(end_r-begin_r)+Math.abs(end_c-begin_c); &#125; &#125; Beam Search (集束算法)分支界定算法（Branch and Bound）Buchberger算法期望-最大算法（EM-Training）LLL算法最大流量算法（Maximum flow）PID 算法参考资料尚硅谷数据结构与算法：https://www.bilibili.com/video/BV1E4411H73v?p=56&amp;spm_id_from=pageDriver 菜鸟教程：https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png 参考书：Data Structure And Algorithm Analysis In Java TM, Third Edition, Mark Allen Weiss, PEARSON A* 算法： https://zhuanlan.zhihu.com/p/225466669","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"程序员必会十大算法","slug":"程序员必会十大算法","date":"2021-05-16T17:53:05.000Z","updated":"2021-07-23T07:21:20.399Z","comments":true,"path":"程序员必会十大算法/","link":"","permalink":"http://xiongy-rhit.github.io/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/","excerpt":"1. 二分查找算法介绍二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图 这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N)","text":"1. 二分查找算法介绍二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图 这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N) 代码实现二分查找有2种实现方法：递归版和非递归版 非递归版 //非递归版本 public static int search(int[] array, int num) &#123; int left =0; //left表示左侧下标 int right = array.length-1; //right表示右侧下标 while(left &lt;= right) &#123; //结束的条件是左边大于右边 int mid = (left+right)/2; //我们假设中间的数是目标 if(array[mid] == num) &#123; // 判断，是 return mid; //返回下标 &#125; else if(array[mid] &gt; num) &#123; //判断发现中间的数比目标数大 right = mid -1; //把中间的数的下标设置为右边， 减1是因为mid已经判断过了，比num大 &#125; else &#123; //若小，则设置为左边 left = mid+1;//加1的原因和上面类似 &#125; &#125; return -1; //找完后发现没有找到，返回-1 &#125; 递归版本 具体步骤和上面非递归版本类似，推荐非递归版本 //递归版本 public static boolean search(int[] array, int num, int left, int right) &#123; int index = (left+right)/2; if(left&gt;right) &#123; return -1; &#125; print(array, left, right); if(array[index] &gt; num) &#123; return search(array, num, left, index-1); &#125; else if(array[index] &lt; num) &#123; return search(array, num, index+1, right); &#125; else &#123; return index; &#125; &#125; 2. 分治算法介绍分治算法，蕴含分而治之的思想，Divide and Conquer. 我们把难的问题逐个逐个拆分，拆分为小的问题，然后对于这个小的问题我们要给出解决办法，最后一步一步返回过去，将难的问题给解决，使用分治算法时，我们还利用了递归的思想，从拆分到组合 代码实现我们举汉诺塔的例子来讲分治算法 故事大家也都知道 大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 64个盘看似很多，我们把这64个简化为3个 3个盘，我们先把上面两个盘想办法从第1个柱子移到第2个柱子 为了按照大小的顺序移动，先把第1个盘从第1个柱子移到第3个柱子，第2个盘从第1个柱子移到第2个柱子 接着把盘从第3个柱子移到第2个柱子 然后，把仅存在第1个柱子的盘移到第3个柱子 最后想办法把第2个柱子上的盘移到第3个柱子 先把第2个柱子上的移到第1个柱子 再把最后一个移到第3个柱子 最后一步 把盘从第1个柱子移到第3个柱子 假设有n个盘，3个柱A, B, C 把n-1个盘从A到B 最后1个从A到C 再把n-1个盘从B移到C 落实到代码 package algorithm; public class HanoiTower &#123; static int count=0; public static void main(String[] args) &#123; // TODO Auto-generated method stub move(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;); System.out.println(count); &#125; public static void move(int num, char a, char b, char c) &#123; if(num==1) &#123; //只有1个盘，从A移动到C System.out.println(a+&quot;-&gt;&quot;+c); count++; &#125; else &#123; //把n-1个盘，从A移动到B move(num-1, a, c, b);//由于实参和形参的不同，我们可以改变实参以达到变换的目的 System.out.println(a+&quot;-&gt;&quot;+c); count++; //再把剩下的从B移动到C move(num-1,b,a,c); &#125; &#125; &#125; 3. 动态规划算法介绍和上面的分治算法有点类似，都是把复杂或大的问题拆解为小的问题，然后求解 不同在于，动态规划算法每一步和上一步之间有联系，所以动态规划算法适用于重叠的子问题求解 常见的利用动态规划算法求解的莫过于背包问题（01背包问题） 去商店买东西，背包有固定的容量，我们每个物品有且只能装入1次，最后我们要挑选出价值最高的物品组合。 为了获取每个子问题的最优解，我们用二维数组来解决背包问题 列表示背包容量 行表示对应的商品 第1列我们也设置为0 用双重for循环，从左往右，从上往下 当然，由于我们第1行和第1列都设置为0，我们从第2列和第2行开始bag[1][1] 从左往右，判断背包容量是否可以装入吉他，不行读取上面1格的值，然后向后，发现2kg可以装入吉他，把吉他装入，设置为$200， 走到电脑这一行，1kg无法放下，读取上面1格的值，向后，还是不行，继续向后，直到能装下，4kg，和上一个做对比，看哪个最后的值大，把大的放入 最后一行是书， 与上文一样，直到bag容量为3kg时，我们先装入1本书，还剩余2kg，我们选取没加这本书的时候的最佳值，也就是书所在上一行，剩余容量所在的位置的值， 就是$200 + $100, 然后我们比较和上一行的大小 0 kg 1 kg 2 kg 3 kg 4 kg $0 $0 $0 $0 $0 吉他 $0 $0 $200 $200 $200 电脑 $0 $0 $200 $200 $300 书 $0 $100 $200 $200+$100 $300 代码实现我们除了要知道背包能存入的最大值，还应该知道存入的是哪些物品，所以我们还需要一个二维数组用来表示存了哪些物品 int[][] path=new int[n+1][m+1]; 存入path所在的位置为1， 没有就是默认的0 打印 1 kg 2 kg 3 kg 4 kg 0 0 0 0 0 吉他 0 0 1 1 1 电脑 0 0 0 0 1 书 0 1 0 1 0 打印从右下角开始向上读，如果此时的标记为1，打印这个下标对应商品的下标，横坐标减去这个商品对应的容量 //为了显示装入的物品有哪些 int i=path.length-1; int j=path[0].length-1; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(path[i][j]==1) &#123; System.out.printf(&quot;把%s放入背包\\n&quot;,obj[i-1]); j -= w[i-1]; &#125; i--; &#125; 最后 package algorithm; public class Dynamic_Programming_Bag2 &#123; public static void main(String[] args) &#123; String[] obj = &#123;&quot;Guitar&quot;,&quot;Computer&quot;,&quot;Book&quot;&#125;; int[] v= &#123;200,300,100&#125;; int[] w= &#123;2,4,1&#125;; int m =4;//背包的容量 int n = w.length;//物品的个数 //背包 int[][] bag =new int[n+1][m+1]; //存储数组 int[][] path=new int[n+1][m+1]; for(int i=0;i&lt;bag.length;i++) bag[i][0]=0;//第一列设置为0 for(int i=0;i&lt;bag[0].length;i++) bag[0][i]=0;//第一行设置为0 for(int i=1;i&lt;bag.length;i++) &#123; for(int j=1;j&lt;bag[0].length;j++) &#123; if(w[i-1]&gt;j) &#123; //容量不满足，直接继承上面一个 bag[i][j] = bag[i-1][j]; &#125;else &#123; //容量满足，和上面一个对比，选取最佳的value //装入i-1个商品，到剩余空间j-w[i]的最大值 // bag[i][j] = Math.max(bag[i-1][j], v[i-1]+bag[i-1][j-w[i-1]]); if(bag[i-1][j]&lt;v[i-1]+bag[i-1][j-w[i-1]]) &#123; bag[i][j] = v[i-1]+bag[i-1][j-w[i-1]]; //把当前情况记录到path path[i][j]=1; &#125;else &#123; bag[i][j] = bag[i-1][j]; &#125; &#125; &#125; &#125; //打印背包的Table //i表示行 //j表示列 for(int i=0;i&lt;bag.length;i++) &#123; for(int j=0;j&lt;bag[0].length;j++) &#123; System.out.printf(bag[i][j]+&quot;\\t&quot;); &#125; System.out.println(); &#125; //为了显示装入的物品有哪些 int i=path.length-1; int j=path[0].length-1; while(i&gt;0 &amp;&amp; j&gt;0) &#123; if(path[i][j]==1) &#123; System.out.printf(&quot;把%s放入背包\\n&quot;,obj[i-1]); j -= w[i-1]; &#125; i--; &#125; &#125; &#125; 4. 贪婪算法介绍贪婪算法，又称贪心算法，Greedy Algorithm。 在解决问题时，每次都选择最好的情况，用这种方法得出最后的解，注意：虽然贪婪算法每次都选最好的，但是最后的结果并不一定是最佳的 广播集合覆盖问题（贪心算法的应用） 我们要构建广播站，每个广播站覆盖的地区不一样，有些有交叉的地方，我们要用哪些广播站去覆盖全部地区。 如图 地区： 北京、上海、天津、广州、深圳、成都、杭州、大连 电台 覆盖数 地区 K1 3 北京、上海、天津 K2 3 广州、北京、深圳 K3 3 成都、上海、杭州 K4 2 上海、天津 K5 2 杭州、大连 从电台里面选，哪些电台组合在一起就覆盖了全部地区？ 首先，我们将每个电台与其覆盖的地区放入HashMap中， Key是电台名称， Value是储存此电台覆盖地区的HashSet。然后我们还要创建一个HashSet用来储存所有地区名称， 一个ArrayList储存最后的结果 我们构建一个循环，每次从循环找出地区数覆盖最多的电台，将这个电台加入到ArrayList中，然后从所有地区中清除这些地区，接着循环，当地区集合大小为0时停止。 这个看代码比较好理解 代码实现package algorithm; import java.util.ArrayList; import java.util.HashMap; import java.util.HashSet; public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub HashMap&lt;String, HashSet&lt;String&gt;&gt; radios = new HashMap&lt;&gt;(); HashSet&lt;String&gt; k1 = new HashSet&lt;&gt;(); k1.add(&quot;北京&quot;); k1.add(&quot;上海&quot;); k1.add(&quot;天津&quot;); HashSet&lt;String&gt; k2 = new HashSet&lt;&gt;(); k2.add(&quot;广州&quot;); k2.add(&quot;北京&quot;); k2.add(&quot;深圳&quot;); HashSet&lt;String&gt; k3 = new HashSet&lt;&gt;(); k3.add(&quot;成都&quot;); k3.add(&quot;上海&quot;); k3.add(&quot;杭州&quot;); HashSet&lt;String&gt; k4 = new HashSet&lt;&gt;(); k4.add(&quot;上海&quot;); k4.add(&quot;天津&quot;); HashSet&lt;String&gt; k5 = new HashSet&lt;&gt;(); k5.add(&quot;杭州&quot;); k5.add(&quot;大连&quot;); radios.put(&quot;k1&quot;, k1); radios.put(&quot;k2&quot;, k2); radios.put(&quot;k3&quot;, k3); radios.put(&quot;k4&quot;, k4); radios.put(&quot;k5&quot;, k5); HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;(); allAreas.addAll(k1); allAreas.addAll(k2); allAreas.addAll(k3); allAreas.addAll(k4); allAreas.addAll(k5); ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); String MaxKey = null; while(!allAreas.isEmpty()) &#123; for(String key:radios.keySet()) &#123; HashSet&lt;String&gt; temp = radios.get(key); temp.retainAll(allAreas); //选取交集 //必须交集大于0 或者 交集的大小大于最大的大小 if( temp.size() &gt;0 &amp;&amp; (MaxKey == null || temp.size() &gt; radios.get(MaxKey).size())) &#123; MaxKey = key; //才能赋值 &#125; &#125; //当最大赋值不为NULL时，把答案添加进去，移除对应的地区 if(MaxKey != null) &#123; result.add(MaxKey); allAreas.removeAll(radios.get(MaxKey)); &#125; &#125; System.out.println(result); &#125; &#125; 5. KMP算法介绍KMP算法是常见的匹配字符串的算法，起初由名字里含有K, M, P的3个人所创建。讨论KMP算法之前我们要先了解暴力匹配字符串算法 暴力匹配算法为什么叫暴力匹配算法？这个方法虽然也是算法，也能帮我们解决问题，但是它的运行效率是比较低的。 找出‘FFD’所匹配的字符串的下标 第一行字符串假设为s1 第二行是s2 在While循环中，用s2的下标向s1的下标进行匹配，若所指下标不匹配，s2向后挪动1格 如此一直到s1上的FFD与s2上的FFD相互匹配，此时返回下标，当然这个下标应该要减去s2的长度 暴力匹配代码实现package algorithm; public class ViolentMatching &#123; public static void main(String[] args) &#123; //暴力匹配算法 System.out.println(matching(&quot;ABCDBCEFFDHFCD&quot;,&quot;FFD&quot;)); &#125; public static int matching(String str1, String str2) &#123; int i=0; int j=0; char[] s1 =str1.toCharArray(); char[] s2 =str2.toCharArray(); while(i&lt;s1.length &amp;&amp; j&lt;s2.length) &#123; if(s1[i] == s2[j]) &#123; //相匹配，两下标各向后移动1 i++; j++; &#125; else &#123; //发现不匹配，s2的下标从头开始， s1的下标应该减去刚才匹配的长度然后+1 i= i-j+1; j=0; &#125; &#125; //最后找到返回下标 if(j==s2.length) return i-j; else &#123; return -1; &#125; &#125; &#125; 在暴力匹配当中，s2每次只往后移动1格，有些之前匹配过的还要再匹配，一旦字符串较长时，匹配所需要的时间就会增加很多，所以我们需要用KMP算法来进行优化 String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;; String str2 =&quot;ABCDABD&quot;; KMP在实现匹配之前要根据s2的前后缀最大公共元素的长度来建立一个匹配池 A B C D A B D 0 0 0 0 1 2 0 字串 前缀 后缀 最大公共长度 A 空 空 0 AB A B 0 ABC A, AB BC, C 0 ABCD A,AB,ABC BCD, CD, D 0 ABCDA A,AB,ABC,ABCD BCDA, CDA, DA, A 1 ABCDAB A, AB, ABC, ABCD, ABCDA BCDAB, CDAB, DAB, AB, B 2 ABCDABD A, AB, ABC, ABCD, ABCDA, ABCDAB BCDABD, CDABD, DABD, ABD, BD, D 0 有了匹配表后，我们要对之前暴力匹配的算法进行更新 //若字符匹配不相等 //KMP算法核心 while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123; j = map[j-1]; &#125; //失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 KMP代码实现package algorithm; public class KMPAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;; String str2 =&quot;ABCDABD&quot;; System.out.println(KMP(str1, str2, MatchMap(str2))); &#125; /** * 构建字符匹配表 * @param dest 传入字符串 * @return 返回匹配后的数组 */ public static int[] MatchMap(String dest) &#123; int[] map = new int[dest.length()]; map[0]=0; for(int i=1, j=0; i&lt;dest.length();i++) &#123; //KMP算法核心 while(j &gt;0 &amp;&amp; dest.charAt(i)!=dest.charAt(j)) &#123; j = map[j-1]; &#125; //部分匹配值+1 if(dest.charAt(i)==dest.charAt(j)) &#123; j++; &#125; map[i] =j; &#125; return map; &#125; /** * * @param st1 被匹配的长字符串 * @param st2 拿来匹配的字符串 * @param map 字符匹配表 * @return 返回-1 或对应匹配的位置 */ public static int KMP(String st1, String st2, int[] map) &#123; for(int i=0, j=0;i&lt;st1.length();i++) &#123; //若字符匹配不相等 //KMP算法核心 while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123; j = map[j-1]; &#125; //字符匹配相等 if(st1.charAt(i)==st2.charAt(j)) &#123; j++; &#125; if(j &gt;= st2.length()) return i-j+1; &#125; return -1; &#125; &#125; 6. Prim算法介绍Prim算法用于解决修路最短路径问题，有7个村庄，要用路把它们连接，问怎么修路使总路程最短，且路可以到达每个村庄 最小生成树问题 这个问题要利用图的知识来求解 需要构建二维数组（邻接矩阵）来表示顶点间的关系 既然每个顶点只能访问一次，需要一个boolean 数组，来储存该顶点是否被访问过 最终边（路）的条数应该为顶点数-1 为了知道是哪2个顶点之间相互连接，我们要将顶点的数据（顶点是哪2个，边的权值是多少）存起来 图 //使用静态内部类的形式来构建 private static class Graph&#123; public int vertex; public char[] data; int[][] weight; Graph(char[] d, int[][] w)&#123; vertex = d.length; data = d; weight = w; &#125; &#125; 二维数组 int [][] weight= &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; boolean数组 boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 Prim算法的核心 //编写Prim算法，得到最小生成树 /** * * @param v 从图的第几个顶点开始找 */ public void Prim(int v) &#123; boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 isVisited[v] = true; //默认设置从第v个顶点开始 /**用 h1和h2 记录2个顶点的下标*/ int h1=-1; int h2=-1; int max=getMax(); // getMax是一个函数，用于获取此矩阵中的最大值，方便后面做比较 int count=0; //用于统计总路径长度 HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); //储存最后的结果 for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个 int minWeight = max; //双重循环 for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有 if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight //比目前最大的数要小 &amp;&amp; graph.weight[i][j] != 0) &#123; //且不为0 minWeight = graph.weight[i][j]; //将最小的换为此时的权重 h1=i; h2=j; //标记这2个点 &#125; &#125; &#125; isVisited[h2] = true; //第二个点设为已访问，之后会从这一行开始访问 result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]); count += graph.weight[h1][h2]; &#125; System.out.println(); for(Entry&lt;String, Integer&gt; rst:result.entrySet()) System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue()); System.out.println(&quot;Min Path: &quot;+count); &#125; 代码实现package algorithm; import java.util.Arrays; import java.util.HashMap; import java.util.Map.Entry; public class PrimAlgorithm &#123; public static void main(String[] args) &#123; char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;; //邻接矩阵的关系用二维数组来表示 int [][] weight= &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; MinTree tree = new MinTree(); tree.createGraph(new Graph(data, weight)); tree.showGraph(); tree.Prim(0); &#125; private static class MinTree&#123; private Graph graph; //创建图的邻接矩阵 public void createGraph(Graph g) &#123; graph = g; &#125; //打印图 public void showGraph() &#123; for(int[] w:graph.weight) System.out.println(Arrays.toString(w)); &#125; //编写Prim算法，得到最小生成树 /** * * @param v 从图的第几个顶点开始找 */ public void Prim(int v) &#123; boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过 isVisited[v] = true; //默认设置从第v个顶点开始 /**用 h1和h2 记录2个顶点的下标*/ int h1=-1; int h2=-1; int max=getMax(); int count=0; HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个 int minWeight = max; //双重循环 for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有 if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight &amp;&amp; graph.weight[i][j] != 0) &#123; minWeight = graph.weight[i][j]; h1=i; h2=j; &#125; &#125; &#125; isVisited[h2] = true; //设置成访问，之后会从这一行开始访问 result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]); count += graph.weight[h1][h2]; &#125; System.out.println(); for(Entry&lt;String, Integer&gt; rst:result.entrySet()) System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue()); System.out.println(&quot;Min Path: &quot;+count); &#125; private int getMax() &#123; int max=graph.weight[0][0]; for(int i=0;i&lt;graph.vertex;i++) &#123; for(int j=0;j&lt;graph.vertex;j++) &#123; if(graph.weight[i][j]&gt;max) max = graph.weight[i][j]; &#125; &#125; return max; &#125; &#125; private static class Graph&#123; public int vertex; public char[] data; int[][] weight; Graph(char[] d, int[][] w)&#123; vertex = d.length; data = d; weight = w; &#125; &#125; &#125; 优化上面的代码是自学写的，时间复杂度很高，（n^3）， 一般的Prim算法时间复杂度仅（n^2），下面贴出更改后的代码 package algorithm; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.LinkedList; import java.util.Map.Entry; public class PrimAlgorithm2 &#123; private static int INF=Integer.MAX_VALUE; public static void main(String[] args) &#123; // TODO Auto-generated method stub char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;; //不相邻的顶点，用INF表示 int [][] map= &#123; &#123;0,5,7,INF,INF,INF,2&#125;, &#123;5,0,INF,9,INF,INF,3&#125;, &#123;7,INF,0,INF,8,INF,INF&#125;, &#123;INF,9,INF,0,INF,4,INF&#125;, &#123;INF,INF,8,INF,0,5,4&#125;, &#123;INF,INF,INF,4,5,0,6&#125;, &#123;2,3,INF,INF,4,6,0&#125; &#125;; System.out.println(&quot;Start&quot;); Prim(1, map, data); &#125; //输入起始顶点，邻接矩阵，顶点信息 public static void Prim(int start, int[][] map, char[] data) &#123; //用于存储最终的各种信息 HashMap&lt;String, Integer&gt; paths = new HashMap&lt;&gt;(); //存储整个data长度 int num = data.length; //存放前顶点 int[] pre =new int[num]; //权重 int[] weights = new int[num]; //初始化 for(int i=0;i&lt;weights.length;i++) &#123; weights[i] = map[start][i]; //默认权重以start为基准 //与start顶点相连 if(weights[i] !=INF) pre[i] =start; //把前节点设为start &#125; //start自身权重为0 weights[start] =0; //start前结点为-1，即不存在 pre[start] =-1; //主体程序 for(int i=0;i&lt; num;i++) &#123; //start顶点前面已经初始化过了 if(i == start) continue; //设置2 个下标，用来记录最短边的顶点 int j=0; int k=0; //最小长度 int min = INF; //从左往右对weights遍历， 找出最小边 while(j &lt; num) &#123; //权重最小且不为0 if(weights[j]!=0 &amp;&amp;weights[j] &lt; min) &#123; min = weights[j]; k = j; //赋值 &#125; j++; &#125; //把最小边相连的一个顶点设为0 weights[k] =0; //重置权重（比较重要） for(int n=0;n&lt;num;n++) &#123; //权重不为0， 且新的两顶点之间权重小于目前的 if(weights[n]!=0 &amp;&amp; map[k][n] &lt; weights[n]) &#123; //更新权重和前节点 pre[n] = k; weights[n] = map[k][n]; &#125; &#125; &#125; //最小生成树信息 for(int i=0;i&lt;num;i++) &#123; if(pre[i] !=-1) &#123; paths.put(data[pre[i]]+&quot;-&quot;+data[i], map[pre[i]][i]); &#125; &#125; //打印信息 int count =0; for(Entry&lt;String, Integer&gt; p:paths.entrySet()) &#123; count += p.getValue(); System.out.println(p.getKey()+&quot; : &quot;+p.getValue()); &#125; //打印最终长度 System.out.println(&quot;Least : &quot;+count); &#125; &#125; 7. Kruskal算法介绍克鲁斯卡尔算法和上面的Prim算法功能都一样，是找出最短总路径；但是Kruskal算法用另外一种方式来解决这个问题 创建每条边的List 把边添加进List 对List排序 从头到尾读取List， 判断边的两个顶点是否形成回路 为了将顶点间的边进行排序，我们需要创建一个Edge类且实现comparable接口 //Edge也是一个静态内部类 private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; 把所有可能加入list并排序 boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); 克鲁斯卡尔算法的精髓 int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓 int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; 代码实现package algorithm; import java.util.Collections; import java.util.LinkedList; /** * Kruskar算法 * 1. 创建每条边的List * 2. 把边添加进List * 3. 对List排序 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路 * @author 23881 * */ public class KruskalAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;; // int[][] weight= &#123; // &#123;0,3,3,7&#125;, // &#123;3,0,2,4&#125;, // &#123;3,2,0,6&#125;, // &#123;7,4,6,0&#125; // &#125;; String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] weight= &#123; &#123;0,12,0,0,0,16,14&#125;, &#123;12,0,10,0,0,7,0&#125;, &#123;0,10,0,3,5,6,0&#125;, &#123;0,0,3,0,4,0,0&#125;, &#123;0,0,5,4,0,2,8&#125;, &#123;16,7,6,0,2,0,9&#125;, &#123;14,0,0,0,8,9,0&#125; &#125;; Kruskar(data, weight); &#125; public static void Kruskar(String[] data, int[][] weight) &#123; boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;Edge&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false&amp;&amp; isVisited[j][i] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); for(Edge&lt;String&gt; e:list) System.out.println(e.print(data)); System.out.println(); int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓, Disjoint Set int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; for(Edge&lt;String&gt; e:result) System.out.println(e.print(data)); &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; &#125; 8. Dijkstra算法介绍Dijkstra算法是解决某个顶点到其他顶点的最小路径问题，（邮差问题） 有A, B,C,D,E,F,G七个村庄，此时派出6个邮差从某点出发给另外几个村庄送信，怎样才能让每个邮差最快到达指定的村庄？ 村庄连接问题，需要用图与广度优先的知识进行求解 构建一个Graph类，这个类用于存储，每个顶点的前访问顶点， PreNode[ ]， 这个和Disjoint Set很相似，同时我们还在这个Graph类里面存储每个顶点的访问情况与到指定顶点的最短距离 private static class Graph&#123; private boolean[] isVisited; //存储是否被访问 private int[] PreNode; //前结点集合 private int[] Dis; //存储到每个顶点的最短距离 private final static int infinity = Integer.MAX_VALUE; //常量 public Graph(int len)&#123; //初始化变量 isVisited = new boolean[len]; PreNode = new int[len]; Dis = new int[len]; //假设每个顶点的前一个顶点都是他们自己 for(int i=0;i&lt;len;i++) &#123; PreNode[i] = -1; Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷 &#125; &#125; //展示最短距离 public void ShowDis() &#123; System.out.println(Arrays.toString(Dis)); &#125; //展示前顶点 public void ShowPreNode() &#123; System.out.println(Arrays.toString(PreNode)); &#125; //展示访问的情况 public void ShowVisited() &#123; System.out.println(Arrays.toString(isVisited)); &#125; //获取某个顶点到目标的最短距离 public int GetDis(int n) &#123; return Dis[n]; &#125; //设置某顶点到目标的最短距离 public void SetDis(int n, int m) &#123; Dis[n] =m; &#125; //获取前访问顶点 public int GetPreNode(int n) &#123; return PreNode[n]; &#125; //设置前访问顶点 public void SetPreNode(int n, int m) &#123; PreNode[n] =m; &#125; //获取顶点的访问状态 public boolean GetVisited(int n) &#123; return isVisited[n]; &#125; //设置顶点的访问状态 public void SetVisited(int n, boolean rst) &#123; isVisited[n] = rst; &#125; &#125; Dijkstra 算法精髓 首先我们要从一个顶点开始，获得与这个顶点连接的顶点 （考虑到之后可能会使用广度优先，我们这里用LinkedList来存储顶点数据） Graph graph = new Graph(matrix[0].length); //初始化一个Graph类 graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列 //把第一个顶点压入队列 list.push(index); //暂时变量 int dis=0; int temp =0; //结束的条件就是队列为空 while(!list.isEmpty()) &#123; temp = list.pop(); //从队列中pop一个元素 //寻找与此元素相连的顶点 for(int i=0;i&lt;matrix[temp].length;i++) &#123; //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点 if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123; //获取此时的路径长度 dis = matrix[temp][i]+graph.GetDis(temp); //如果这个长度小于已有的长度 if(dis&lt;graph.GetDis(i)) &#123; //对原顶点的长度进行替换 graph.SetPreNode(i, temp); //修改preNode graph.SetDis(i, dis); //能够被压入队列的条件：没被访问过且不在队列中 if(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123; list.push(i); &#125; &#125; &#125; &#125; //一个顶点完成遍历后，将其设置为已访问 graph.SetVisited(temp, true); &#125; 最终 代码实现package algorithm; import java.util.Arrays; import java.util.LinkedList; public class DijkstraAlgorithm2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] matrix = &#123; &#123;0,5,7,0,0,0,2&#125;, &#123;5,0,0,9,0,0,3&#125;, &#123;7,0,0,0,8,0,0&#125;, &#123;0,9,0,0,0,4,0&#125;, &#123;0,0,8,0,0,5,4&#125;, &#123;0,0,0,4,5,0,6&#125;, &#123;2,3,0,0,4,6,0&#125; &#125;; Dijkstra(matrix, 0); &#125; /*结束条件：队列为空 * 判断条件：not preNode * 改变Dis与Pre条件 * 小于已有距离 * 压入条件 * not visited 且 不在队列中 * * 遍历完一个点后，将此点改为isvisited * */ public static void Dijkstra(int[][] matrix, int index) &#123; Graph graph = new Graph(matrix[0].length); graph.SetDis(index, 0); LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.push(index); graph.SetVisited(index, true); int dis=0; int temp =0; while(!list.isEmpty()) &#123; temp = list.pop(); for(int i=0;i&lt;matrix[temp].length;i++) &#123; if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123; dis = matrix[temp][i]+graph.GetDis(temp); if(dis&lt;graph.GetDis(i)) &#123; graph.SetPreNode(i, temp); graph.SetDis(i, dis); if(!graph.GetVisited(i) &amp;&amp; !list.contains(i)) &#123; list.push(i); &#125; &#125; &#125; &#125; graph.SetVisited(temp, true); &#125; System.out.println(&quot;Final Distence&quot;); graph.ShowDis(); System.out.println(&quot;\\nFinal Pre-Node&quot;); graph.ShowPreNode(); System.out.println(&quot;\\nAdjacent Matrix&quot;); for(int[] i:matrix) &#123; System.out.println(Arrays.toString(i)); &#125; &#125; private static class Graph&#123; private boolean[] isVisited; private int[] PreNode; private int[] Dis; private final static int infinity = Integer.MAX_VALUE; public Graph(int len)&#123; isVisited = new boolean[len]; PreNode = new int[len]; Dis = new int[len]; for(int i=0;i&lt;len;i++) &#123; PreNode[i] = -1; Dis[i] = infinity; &#125; &#125; public void ShowDis() &#123; System.out.println(Arrays.toString(Dis)); &#125; public void ShowPreNode() &#123; System.out.println(Arrays.toString(PreNode)); &#125; public int GetDis(int n) &#123; return Dis[n]; &#125; public void SetDis(int n, int m) &#123; Dis[n] =m; &#125; public int GetPreNode(int n) &#123; return PreNode[n]; &#125; public void SetPreNode(int n, int m) &#123; PreNode[n] =m; &#125; public boolean GetVisited(int n) &#123; return isVisited[n]; &#125; public void SetVisited(int n, boolean rst) &#123; isVisited[n] = rst; &#125; &#125; &#125; 9. Floyd算法介绍Floyd算法解决的问题和上面Dijkstra算法解决的问题一样；Floyd算法更容易理解，但是它的运行效率没有Dijkstra算法高 Floyd算法使用3个for循环进行嵌套 代码实现package algorithm; import java.util.Arrays; public class FloydAlgorithm &#123; public static void main(String[] args) &#123; int N=255; //N表示两个顶点间不相连 String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] matrix = &#123; &#123;0,5,7,N,N,N,2&#125;, &#123;5,0,N,9,N,N,3&#125;, &#123;7,N,0,N,8,N,N&#125;, &#123;N,9,N,0,N,4,N&#125;, &#123;N,N,8,N,0,5,4&#125;, &#123;N,N,N,4,5,0,6&#125;, &#123;2,3,N,N,4,6,0&#125; &#125;; Floyd(data, matrix); &#125; public static &lt;E&gt; void Floyd(E[] d, int[][] m ) &#123; Graph&lt;E&gt; graph = new Graph&lt;&gt;(d, m); // graph.showGraph(); graph.start(); graph.showGraph(); &#125; private static class Graph&lt;E&gt;&#123; private E[] data; private int[][] matrix; Graph(E[] d, int[][] m)&#123; data = d; matrix = new int[data.length][data.length]; for(int i=0;i&lt;data.length;i++) &#123; for(int j=0;j&lt;data.length;j++) &#123; matrix[i][j] = m[i][j]; &#125; &#125; &#125; public void showGraph() &#123; for(int[] m:matrix) System.out.println(Arrays.toString(m)); System.out.println(); for(int[] m:rst) System.out.println(Arrays.toString(m)); System.out.println(); &#125; public void start() &#123; int len=0; //对中间顶点遍历，k是中间顶点的下标 for(int k=0;k&lt;data.length;k++) &#123; //从i顶点出发 for(int i=0;i&lt;data.length;i++) &#123; for(int j=0;j&lt;data.length;j++) &#123; len = matrix[i][k] + matrix[k][j]; //从i出发，经过k，到达j的距离 if(len &lt; matrix[i][j]) &#123; matrix[i][j] = len; &#125; &#125; &#125; &#125; &#125; &#125; &#125; 10. 马踏棋盘算法介绍马踏棋盘问题，也称骑士周游问题，在国际象棋中，马只能走日，从某点出发，怎样才能走完棋盘上每个点，要求不重复？ 马踏棋盘是典型的回溯问题，和迷宫问题属于同一类别 我们要考虑马的移动条件，找出下个能走的点 public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123; ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;(); int X = curPoint.x; //表示列 int Y = curPoint.y; //表示行 if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X-2, Y-1)); if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X-1, Y-2)); if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X+1, Y-2)); if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X+2, Y-1)); if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) ps.add(new Point(X-2, Y+1)); if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row) ps.add(new Point(X-1, Y+2)); if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row) ps.add(new Point(X+1, Y+2)); if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row) ps.add(new Point(X+2, Y+1)); return ps; &#125; 马在棋盘上走，遇到不能走的点要回溯，回溯需要递归的知识 private static void Run(int x, int y, int step) &#123; ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数) isVisited[y][x] = true; ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y)); sort(ps); while(!ps.isEmpty())&#123; Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点 if(!isVisited[p.y][p.x]) Run(p.x, p.y, step+1); &#125; //发现走不了，而且还没走完棋盘上每个点，将此点标为未访问，回溯 if(step &lt; row*coloumn &amp;&amp; ! finish) &#123; ChessBoard[y][x] = 0; isVisited[y][x] = false; &#125;else &#123; //走完，标为结束 finish = true; &#125; &#125; *1. 创建一个二维数组，作为棋盘 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中 *3. 遍历ArrayList中的所有位置，看看哪个可以走通 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0 代码实现package algorithm; import java.awt.Point; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; /** * 马踏棋盘算法 * @author 23881 *1. 创建一个二维数组，作为棋盘 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中 *3. 遍历ArrayList中的所有位置，看看哪个可以走通 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0 */ public class ChessHorseAlgorithm &#123; private static int coloumn;//列 private static int row; //行 private static int[][] ChessBoard; private static boolean[][] isVisited; private static boolean finish = false; public static void main(String[] args) &#123; // TODO Auto-generated method stub Start(8, 8, 2, 1); &#125; /** * * @param c 棋盘的列数 * @param r 棋盘的行数 * @param x 马位于第x列 * @param y 马位于第y行 * @param step 步数 * */ public static void Start(int c, int r, int x, int y) &#123; coloumn = c; row = r; ChessBoard = new int[row][coloumn]; isVisited = new boolean[row][coloumn]; Run(x, y, 1); for(int[] cb: ChessBoard) System.out.println(Arrays.toString(cb)); &#125; private static void Run(int x, int y, int step) &#123; ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数) isVisited[y][x] = true; ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y)); sort(ps); while(!ps.isEmpty())&#123; Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点 if(!isVisited[p.y][p.x]) Run(p.x, p.y, step+1); &#125; if(step &lt; row*coloumn &amp;&amp; ! finish) &#123; ChessBoard[y][x] = 0; isVisited[y][x] = false; &#125;else &#123; finish = true; &#125; &#125; public static void sort(ArrayList&lt;Point&gt; ps) &#123; ps.sort(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point arg0, Point arg1) &#123; // TODO Auto-generated method stub return GetNext(arg0).size() - GetNext(arg1).size(); &#125; &#125;); &#125; public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123; ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;(); int X = curPoint.x; //表示列 int Y = curPoint.y; //表示行 if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X-2, Y-1)); if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X-1, Y-2)); if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0) ps.add(new Point(X+1, Y-2)); if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0) ps.add(new Point(X+2, Y-1)); if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) ps.add(new Point(X-2, Y+1)); if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row) ps.add(new Point(X-1, Y+2)); if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row) ps.add(new Point(X+1, Y+2)); if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row) ps.add(new Point(X+2, Y+1)); return ps; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"部分排序算法可视化","slug":"部分排序算法可视化","date":"2021-04-26T13:44:26.000Z","updated":"2021-07-23T07:20:35.119Z","comments":true,"path":"部分排序算法可视化/","link":"","permalink":"http://xiongy-rhit.github.io/%E9%83%A8%E5%88%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/","excerpt":"程序介绍最近复习排序算法闲着无聊，做了一个可视化小程序，这个程序支持部分排序算法，当然有兴趣可以自己扩展 我将冒泡排序，选择排序，插入排序，希尔排序，快速排序做了可视化，展示一下最终效果 感兴趣可以看看我原来写的排序算法的链接（归并排序，桶排序） https://blog.csdn.net/peterbearXY/article/details/114648428","text":"程序介绍最近复习排序算法闲着无聊，做了一个可视化小程序，这个程序支持部分排序算法，当然有兴趣可以自己扩展 我将冒泡排序，选择排序，插入排序，希尔排序，快速排序做了可视化，展示一下最终效果 感兴趣可以看看我原来写的排序算法的链接（归并排序，桶排序） https://blog.csdn.net/peterbearXY/article/details/114648428 程序描述点击相应的按钮可以让下面的图像进行更新，点击重置可以使所有数回到原有位置 我们可以通过看相应的图像变化了解排序算法的过程，这里强烈推荐看选择排序，这个最明显 我这里放一串示例代码，全部可以到下面的链接中下载 https://download.csdn.net/download/peterbearXY/18116736 示例代码选择排序：排序部分（利用线程）+演示部分 //排序部分 package SelectSorting; import java.awt.Panel; public class SelectAlgorithm extends Thread&#123; private int[] arr; private Panel p; public SelectAlgorithm(int[] arr, Panel p) &#123; this.arr = arr; this.p = p; &#125; @Override public void run() &#123; // TODO Auto-generated method stub for(int i=0;i&lt;arr.length-1;i++) &#123; int smallest =i; for(int j=i;j&lt;arr.length;j++) &#123; if(arr[j] &lt; arr[smallest]) smallest = j; &#125; if(i != smallest) &#123; int temp = arr[i]; arr[i] = arr[smallest]; arr[smallest] = temp; p.repaint(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; //展示部分 package SelectSorting; import java.awt.Graphics; import java.awt.Panel; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Arrays; import javax.swing.JButton; import javax.swing.JFrame; public class SelectDrawing extends JFrame&#123; private MyPanel panel; public static void main(String[] args) &#123; // TODO Auto-generated method stub new SelectDrawing(); &#125; public SelectDrawing() &#123; // TODO Auto-generated constructor stub int[] arr = &#123;6,3,7,1&#125;; panel = new MyPanel(); panel.InitData(arr); this.add(panel); this.setSize(800, 600); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setVisible(true); &#125; &#125; class MyPanel extends Panel&#123; private int[] arr; private int[] originArr; private JButton start; private JButton reset; public int[] getArr() &#123; return arr; &#125; public void InitData(int[] arr) &#123; this.arr = arr; this.originArr = Arrays.copyOf(arr, arr.length); start = new JButton(); start.setText(&quot;开始&quot;); start.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; // TODO Auto-generated method stub StartToSort(); &#125; &#125;); start.setVisible(true); reset = new JButton(); reset.setText(&quot;重置&quot;); reset.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub ReSetArr(); &#125; &#125;); this.add(start); this.add(reset); &#125; //重置 private void ReSetArr() &#123; // TODO Auto-generated method stub arr = Arrays.copyOf(originArr, originArr.length); this.repaint(); &#125; //开始排序 private void StartToSort() &#123; // TODO Auto-generated method stub SelectAlgorithm sort = new SelectAlgorithm(arr, this); sort.start(); &#125; //绘制图像 private void InitRects(Graphics g) &#123; int x=100; int y=500; int preY =0; for(int i:arr) &#123; y -= i*50 - preY; g.drawRect(x, y, 20, i*50); x+=20; preY = i*50; &#125; &#125; @Override public void paint(Graphics g) &#123; // TODO Auto-generated method stub super.paint(g); InitRects(g); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"}]},{"title":"Disjoint Set并查集","slug":"DisjointSet","date":"2021-04-20T17:49:24.000Z","updated":"2021-07-23T05:52:22.734Z","comments":true,"path":"DisjointSet/","link":"","permalink":"http://xiongy-rhit.github.io/DisjointSet/","excerpt":"介绍并查集是一种数据结构，其实现简单，仅仅需要几行代码与一个数组就可以实现； 创建一个数组，用于储存每个顶点的父结点，默认都是自己 union合并方法，用于将2个顶点合并在一起 find方法，用于寻找最终的根节点 克鲁斯卡尔算法中就运用到并查集的知识，用于寻找2个顶点之间是否构成回路 我们自动生成迷宫时，也会需要使用disjoint方法，当入口与出口构成回路时，我们就完成了迷宫的设计","text":"介绍并查集是一种数据结构，其实现简单，仅仅需要几行代码与一个数组就可以实现； 创建一个数组，用于储存每个顶点的父结点，默认都是自己 union合并方法，用于将2个顶点合并在一起 find方法，用于寻找最终的根节点 克鲁斯卡尔算法中就运用到并查集的知识，用于寻找2个顶点之间是否构成回路 我们自动生成迷宫时，也会需要使用disjoint方法，当入口与出口构成回路时，我们就完成了迷宫的设计 实现构造函数private int s[]; public Disjoint1(int numElements) &#123; s = new int[numElements]; for(int i=0;i&lt;s.length;i++) s[i] = -1; //初始化默认每个点的根节点就是自己，即-1 &#125; 查//非递归版本 public int find(int x) &#123; int temp=x; while(s[temp]!=-1) temp = s[temp]; return temp; &#125; //递归版本 public int find(int x) &#123; if(s[x] &lt;0) return x; else &#123; return find(s[x]); &#125; &#125; 并public void union(int root1, int root2) &#123; if(s[root2]&lt;s[root1]) //root2 is depper s[root1] = root2; //make root2 new root else &#123; if(s[root1] == s[root2]) s[root1] --; //Update height if same s[root2] = root1; //make root1 new root &#125; &#125; 路径压缩对于路径压缩，我们是在find函数中进行修改，当我们寻找到一个顶点的根节点后，在递归时，我们把剩下的顶点的根节点都设为最后一个顶点的根节点，这样可以简化下次递归的深度 public int find(int x) &#123; if(s[x] &lt;0) return x; else &#123; return s[x] = find(s[x]); //path compression, decrease the running time &#125; &#125; 当然，这种方法也有个缺点，如下图 我们如果使用find(4),这样可以使整个树扁平化 但是如果我们使用find(3)，最后只能使包含3在内的之前的顶点扁平化 应用判断是否构成环路传入一个二维数组，包含这张图的信息 每个顶点对应的下标按照英文字母的顺序排列，从0开始 package DisjointSet; public class CircleJudge &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[][] a= &#123; &#123;0, 1&#125;, &#123;0, 2&#125;, &#123;0, 4&#125;, &#123;1, 2&#125;, &#123;2, 4&#125;, &#123;2, 3&#125;, &#125;; isCircle(a, 5); &#125; private static int[] p; /*查找root*/ private static int find(int x) &#123; if(p[x] &lt;0) return x; else &#123; return p[x] = find(p[x]); &#125; &#125; /*合并,前提是没构成环路*/ //构成环路返回true private static boolean union(int i, int j) &#123; int x=find(i); int y =find(j); if(x!=y) &#123; if(p[y] &lt; p[x]) p[x]= y; else &#123; p[y] =x; &#125; return false; &#125;else &#123; return true; &#125; &#125; public static void isCircle(int[][] a, int len) &#123; /*初始化*/ p = new int[len]; for(int i=0;i&lt;p.length;i++) p[i]=-1; boolean rst; for(int[] i:a) &#123; rst = union(i[0],i[1]); if(rst) &#123; System.out.println(&quot;These data include circle&quot;); break; &#125; &#125; &#125; &#125; Kruskal算法package algorithm; import java.util.Collections; import java.util.LinkedList; /** * Kruskar算法 * 1. 创建每条边的List * 2. 把边添加进List * 3. 对List排序 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路 * @author 23881 * */ public class KruskalAlgorithm &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;; // int[][] weight= &#123; // &#123;0,3,3,7&#125;, // &#123;3,0,2,4&#125;, // &#123;3,2,0,6&#125;, // &#123;7,4,6,0&#125; // &#125;; String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;; int[][] weight= &#123; &#123;0,12,0,0,0,16,14&#125;, &#123;12,0,10,0,0,7,0&#125;, &#123;0,10,0,3,5,6,0&#125;, &#123;0,0,3,0,4,0,0&#125;, &#123;0,0,5,4,0,2,8&#125;, &#123;16,7,6,0,2,0,9&#125;, &#123;14,0,0,0,8,9,0&#125; &#125;; Kruskar(data, weight); &#125; public static void Kruskar(String[] data, int[][] weight) &#123; boolean[][] isVisited = new boolean[data.length][data.length]; LinkedList&lt;Edge&lt;String&gt;&gt; list = new LinkedList&lt;&gt;(); LinkedList&lt;Edge&lt;String&gt;&gt; result = new LinkedList&lt;&gt;(); for(int i=0;i&lt;weight.length;i++) &#123; for(int j=0;j&lt;weight.length;j++) &#123; if(isVisited[i][j] == false&amp;&amp; isVisited[j][i] == false &amp;&amp; weight[i][j] != 0) &#123; list.add(new Edge&lt;String&gt;(i, j, weight[i][j])); isVisited[i][j] = true; isVisited[j][i] = true; &#125; &#125; &#125; Collections.sort(list); for(Edge&lt;String&gt; e:list) System.out.println(e.print(data)); System.out.println(); int[] ends = new int[data.length]; for(Edge&lt;String&gt; e:list) &#123; if(result.size() == data.length-1) break; //克鲁斯卡尔算法精髓, Disjoint Set int m = GetEnd(ends, e.x); int n = GetEnd(ends, e.y); //判断终点是否是一样的，即是否形成回路 if(m !=n) &#123; ends[m]=n; result.add(e); &#125; &#125; for(Edge&lt;String&gt; e:result) System.out.println(e.print(data)); &#125; /** * 获取对应下标的终点 * @param ends * @param i * @return */ private static int GetEnd(int[] ends, int i) &#123; while(ends[i] !=0) i = ends[i]; return i; &#125; private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123; public int x; public int y; public int weight; Edge(int a, int b, int w)&#123; x = a; y = b; weight = w; &#125; public String print(E[] data) &#123; return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight; &#125; @Override public int compareTo(Edge&lt;String&gt; e) &#123; // TODO Auto-generated method stub return weight -e.weight; &#125; &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Comparable 与 Iterable 接口","slug":"Comparator And Iterator","date":"2021-03-23T04:00:00.000Z","updated":"2021-07-23T07:19:59.367Z","comments":true,"path":"Comparator And Iterator/","link":"","permalink":"http://xiongy-rhit.github.io/Comparator%20And%20Iterator/","excerpt":"Comparable介绍Interface Comparable 如果一个类实现Comparable接口，其必须实现CompareTo方法，调用此方法的对象将与里面的o对象进行比较 例如： x.CompareTo(T y) x和y进行比较，如果相等返回0；若x&gt;y，返回1；若x&lt;y，返回-1；当然，CompareTo方法的实现由我们自己定义 实现此接口的对象拥有自然顺序（natural ordering） 对象之间可以使用CompareTo(T o)来进行比较 如果对储存此对象的集合调用sort方法，Collections工具类会根据CompareTo方法排序：Collections.sort(list2);","text":"Comparable介绍Interface Comparable 如果一个类实现Comparable接口，其必须实现CompareTo方法，调用此方法的对象将与里面的o对象进行比较 例如： x.CompareTo(T y) x和y进行比较，如果相等返回0；若x&gt;y，返回1；若x&lt;y，返回-1；当然，CompareTo方法的实现由我们自己定义 实现此接口的对象拥有自然顺序（natural ordering） 对象之间可以使用CompareTo(T o)来进行比较 如果对储存此对象的集合调用sort方法，Collections工具类会根据CompareTo方法排序：Collections.sort(list2); //节点实现Comparable接口 class Node implements Comparable&lt;Node&gt; &#123; private int num; Node(int num)&#123; this.num = num; &#125; @Override public int compareTo(Node arg0) &#123; // TODO Auto-generated method stub int num2 = arg0.num; return num - num2; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; //在主程序中调用 public class NaturalOrderTest &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(66); list.add(33); list.add(66); list.add(68); list.add(23); list.add(78); LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;(); for(Integer i:list) &#123; list2.add(new Node(i)); &#125; Node node = new Node(23); Collections.sort(list2); System.out.println(list2); &#125; &#125; 集合调用进行排序假如我们需要对一组集合中的对象进行2种不同的排序方法 Collections.sort(…)有2种形式 // Collections指集合工具类 Sort by the natural order: Collections.sort(todoList); todoList里面的对象必须是Comparable的 Collections.sort(list2); Sort according to a specified order Collections.sort(list2, ComparatorClass); ComparatorClass是一个类，实现了Comparator接口 Comparator也是一个接口 Interface Comparator 要实现compare(T o1, T o2)方法，返回值是int，与Comparable类似 o1是前一个元素， o2是后一个元素 针对第2中形式(Comparator)，我写了一个例子 //实现Comparator接口 class ComparatorClass implements Comparator&lt;Node&gt;&#123; @Override public int compare(Node arg0, Node arg1) &#123; // TODO Auto-generated method stub return arg1.num-arg0.num; //进行逆序排列 &#125; &#125; //原来实现Comparable接口的类 class Node implements Comparable&lt;Node&gt; &#123; int num; Node(int num)&#123; this.num = num; &#125; @Override public int compareTo(Node arg0) &#123; // TODO Auto-generated method stub int num2 = arg0.num; return num - num2; &#125; @Override public String toString() &#123; return num+&quot;&quot;; &#125; &#125; //测试类 public class NaturalOrderTest &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(66); list.add(33); list.add(66); list.add(68); list.add(23); list.add(78); LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;(); for(Integer i:list) &#123; list2.add(new Node(i)); &#125; //进行排序 Collections.sort(list2, new ComparatorClass()); System.out.println(list2); &#125; &#125; 有了Comparator接口的实现类，我们可以对已有的集合中的元素(元素属性足够多)进行各种指定的排序，如 Collections.sort(list, new BigToSmallComparator()); //从大到小 Collections.sort(list, new LftToRtComparator());//从左到右 Collections.sort(list, new TopToBotComparator());//从上到下 Comparator 和Comparable总结Comparable interface for objects that can be compared control classes’ natural ordering 实现方法：int compareTo(T o1); Comparator still an interface for objects but used to defined the rule use Comparator to sort objects in an order other than their natural ordering 实现方法：int compare(T o1, T o2); Iterable介绍 Iterable也是一个接口 实现这个接口，必须实现其Iterator方法，返回一个迭代器 class MyList implements Iterable&lt;MyList&gt;&#123; @Override public Iterator iterator() &#123; // TODO Auto-generated method stub return null; &#125; &#125; 同时，实现了iterable接口的集合都可以进行for-each-loop（增强for），当然还要返回有效的iterator() 所以同时我们也要实现iterator接口（一般使用内部类来实现此接口） 实现Iterator接口 boolean hasNext() E next() void remove() 使用内部类来实现 外部类实现Iterable接口，内部类实现Iterator接口 为什么要用内部类？ 引用Data Structure and Algorithm Analysis in Java的原话 The inner class is useful in a situation in which each inner class object is associated with exactly one instance of an outer class object. In such a case, the inner class object can never exist without having an outer class object with which to be associated. 翻译过来就是：当一个类需要使用另一个类里面的元素时，同时要保证被引用的类的元素是私有的，此时我们就可以使用内部类；在这种情况下，如果没有外部类，内部类就无法存在。 Iterator和Iterable总结Iterator与Iterable两个接口缺一不可 Iterator接口让实现Iterable的对象返回一个迭代器对象 Iterable为Iterator的使用创造条件 实现Iterable接口后，集合就可以进行for-each循环 Iterable is an interface specification for a class that is equipped with an Iterator Iterator is an interface specification for a class that can generate iterative elements Each Collection class needs an associated Iterator class Iterator may access inside of collection Iterator provides elements one at a time.","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"}]},{"title":"java入门","slug":"java入门","date":"2020-12-09T05:00:00.000Z","updated":"2021-07-23T07:18:44.489Z","comments":true,"path":"java入门/","link":"","permalink":"http://xiongy-rhit.github.io/java%E5%85%A5%E9%97%A8/","excerpt":"作者：Yao Xiong 引言学习一门编程语言不是一件难事，在本书的前言我要郑重强调一下这件事。学习如逆水行舟，不进则退；只要大家坚持，相信最后定会有所收获。本书作为一本入门的工具书，会侧重讲解JAVA的基础知识，旨在引导读者进入JAVA的学习大门。 什么是JAVAJAVA是一种面向对象的高阶编程语言，在JAVA中有句老话：万物皆对象。对于java的介绍我引用百科的一些解释。（Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 [2] 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等）","text":"作者：Yao Xiong 引言学习一门编程语言不是一件难事，在本书的前言我要郑重强调一下这件事。学习如逆水行舟，不进则退；只要大家坚持，相信最后定会有所收获。本书作为一本入门的工具书，会侧重讲解JAVA的基础知识，旨在引导读者进入JAVA的学习大门。 什么是JAVAJAVA是一种面向对象的高阶编程语言，在JAVA中有句老话：万物皆对象。对于java的介绍我引用百科的一些解释。（Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 [2] 。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等） 第一个JAVA程序由于JAVA是一门面向对象的语言，在运行程序时我们需要单独建立一个类对象，在此类对象的main()函数中运行。废话不多说，直接上代码 public class hello_world &#123; public static void main(String[] args) &#123; //这样我们就创立好了第一个程序的框架 //在main函数里面，我们就可以书写一些需要的指令 &#125; &#125; 作为编程界的惯例，第一个程序当然是在console里面打印”Hello World” public class hello_world &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125; System.out.println() 是一条将程序中的数据打印在控制台，也就是console中的指令 在System.out.println后面有一对括号，在这个里面我们要传入想要打印在console中的内容，即函数的参数 因为要将”hello world“转化为计算机能看懂的语言，所以我们需要在”hello world”外加上双引号，将其转化为字符串类型 这样计算机就能读懂我们的语言，从而输出我们的指令。 结果 JAVA的数据类型当我们运行JAVA程序时，我们会进行一系列的数学计算，此时拥有存贮数据的变量就尤为重要。在JAVA中为了拥有存储数据的变量，我们往往需要在内存中开辟一道空间，例如： //在编辑器中的代码变量 int x =5; int y =6; //在内存中存储的变量数据， 变量名称我们可以自定义 JAVA的数据类型可以分为2大类 内置数据类型 引用数据类型 内置数据类型Java 的内置数据类型一共有8种，8种中又可以分为4种。 整型: byte, short, int, long 浮点型: float, double 字符型: char 布尔型: boolean 整型整型顾名思义，它是用来存储整数的 虽然byte, short, int和long都属于整型，但它们之间还是各有差异因为各自的取值不同。 数据类型 数据范围 数据大小(bit /位) 默认值 byte -128~127 (-2^7 ~(2^7)-1) 1 byte= 8 bits 0 short -32768~32767 (-2^15 ~(2^15)-1) 2 bytes = 16 bits 0 int -2^31 ~ (2^31)-1 4 bytes = 32 bits 0 long -2^63 ~(2^63)-1 8 bytes = 64 bits 0L 一般情况下，我们使用int类型来定义整数，因为int的范围足以满足我们日常的需求 byte a =100; short b = 10000; int c = 100000; long d =10000000; 浮点型与整型恰好相反，浮点型是用来存储小数的。浮点型分为float和double，两者的区别在于精度。 数据类型 数据范围 数据大小(bit /位) 默认值 float (单精度浮点型) 1.4·10^-45 ~ 3.4·10^38 4 bytes = 32 bits 0.0f double(双精度浮点型) 4.9·10^-324 ~ 1.7·10^308 8 bytes = 64 bits 0.0d 虽然说浮点数可以表示小数，但是浮点数不能表示精确的数，例如货币。如果需要表示精确的数，需要借助其他java类例如Big Decimal来实现。例子： 1.40* 165 = 231 但是 计算机给出的计算是230.999999999997 通常浮点数在未声明的前提下都是double类型, float f1 = 234.5f; double d1 = 123.4; 字符型char类型是一个单一的16位Unicode字符， 表示字符时用单引号。char的范围是0~65535,大小为16 bits 数据类型 数据范围 数据大小(bit /位) 默认值 char(字符) 0~65535 2 bytes = 16 bits ‘u0000’ 对char变量赋值既可以使用数字，也可以使用字符,char可以存储任何字符 public class test &#123; public static void main(String[] args) &#123; char a =65; char b =&#39;A&#39;; System.out.println(a); System.out.println(b); &#125; &#125; 结果 布尔型布尔类型指true和false，boolean数据只表示1位信息，可作为标志flag来记录true或false 数据类型 数据范围 数据大小(bit /位) 默认值 boolean true / false 1 bit false 引用数据类型 数组 类与对象 字符串 下面有一张图来表示引用类型数据 这张图上p1,p2,p3,p4作为类对象，当他们被创建时，他们实际上时作为指针指向一些数据 在本节引用类型暂时提一下，在后面的章节中会详细解释这些 基础类型转换在运行程序时，我们有时需要将不同类型的数据转化为同一类型 类型转换又可分为自动类型转换与强制类型转换 自动类型转换自动转换条件是转换前数据类型的位数低于转换后数据类型的位数 转化过程中可能会有精度损失 byte , short , char 可自动转化为int int 可转化为 long long 可转化为 float float 可转化为 double public class test &#123; public static void main(String[] args) &#123; char a =65; int b = a; System.out.println(a); System.out.println(b); &#125; &#125; 结果 强制类型转换如果被转化数据类型位数大于要转化的数据类型的位数，此时需要用到强制类型转换，注意Boolean类型不能被强制转换 强制转换格式 public class test &#123; public static void main(String[] args) &#123; char a =&#39;A&#39;; byte b = (byte)a; //强制将char类型转化为byte类型 //其实将这些数据打印出来，也暗含了一层数据转换 System.out.println(a); System.out.println(b); &#125; &#125; 结果 JAVA符号既然JAVA作为一门计算机编程语言，它一定能像计算器一样为我们做一些运算，所以在本章我们将讲解JAVA的运算符号。 算数运算符运算优先级和现实生活中一样，括号( ) &gt; * 或 % 或 / &gt; + 或 - 符号 含义 例子 = 赋值 int i =5; 把5赋值给i + 加号 int i = (5+6); - 减号 int j = (6-1); * 乘号 int k = (7*8); / 取整 int a = (7/8); / 除号 double c = 7.0 /8; % 取余 int b = (7%8); // 转义字符 写注释用的 public class test &#123; public static void main(String[] args) &#123; int i = 5+6; int j = 6-1; int k = 7*8; int a = 9 / 8; double b = 9.0 / 8; //如果想用除法获得小数，必须要用double类型的数据 int c = 9 % 8; System.out.println(&quot;5+6 = &quot;+i); System.out.println(&quot;6-1 = &quot;+j); System.out.println(&quot;7*8 = &quot;+k); System.out.println(&quot;(整除)9/8 = &quot;+a); System.out.println(&quot;(除以)9.0/8 = &quot;+b); System.out.println(&quot;(取余)9%8 = &quot;+c); &#125; &#125; //优先级测试 public class test &#123; public static void main(String[] args) &#123; double a = (2+1)+3.0/5-6*7-(4/3); System.out.println(&quot;(2+1)+3.0/5-6*7-(4/3) = &quot;+a); //注意（4/3） 是取整，结果是1 &#125; &#125; 关系运算符在运行程序时，我们需要对一些数据进行判断，此时就需要关系运算符 关系运算符判断后，返回true 或 false 符号 含义 例子 == 等于 (6 == 7) false != 不等于 (6 != 7) true &gt; 大于 (6 &gt; 7) false &lt; 小于 (6 &lt; 7) true &lt;= 小于或等于 (6 &lt;= 7) true &gt;= 大于或等于 (6 &gt;= 7) false 逻辑运算符和电路图中的逻辑门类似， 逻辑运算符就是 与， 或，非 A为true B为false 符号 含义 例子 &amp;&amp; 与，and，当左边与右边同时为true时返回true (A &amp;&amp; B) false || 或, or, 左边或右边任意一个满足即返回false (A||B) true ! 非,与所选的条件相反 !(A||B) false 补充看别人的源码时有时会碰到以下的几种符号 符号 含义 例子 ++ 加一 a++; a的值加1 – 减一 b–; b的值减1 += 加等于 a += b; 意思是a= a + b; -= 减等于 a -= b; 意思是 a = a -b; /n 换行 “/n” /t 水平制表符 从左往右数8个空格 JAVA逻辑判断上文我们提到了逻辑运算符与关系运算符，这些符号会给我们返回boolean 类型的数据 ：true 或 false true / false便是用在逻辑判断中的 if / else假如大家对其他语言，例如python有所了解， 判断通常会使用if else语句，格式如下 if(条件语句)&#123; //执行的指令 &#125; else if(条件语句)&#123; //执行的指令 &#125; //else指的是最终条件，即排除if与else if条件之后 else&#123; //执行的指令 &#125; 例子 在这个例子里面会用到用户输入指令，Scanner import java.util.Scanner; public class test &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); //创建scanner对象，这样就可以从控制台输入 System.out.print(&quot;a: &quot;); int a = input.nextInt(); //nextInt()指输入的值是int类型数据，该方法是通过对象调用，后面会讲 System.out.print(&quot;b: &quot;); int b = input.nextInt(); //比较a与b的大小 if(a&gt;b) &#123; System.out.println(&quot;a大于b&quot;); &#125; else if(a&lt;b) &#123; System.out.println(&quot;a小于b&quot;); &#125; else &#123; System.out.println(&quot;a等于b&quot;); &#125; input.close(); &#125; &#125; 结果 除此之外，还有嵌套式的if else if(a &gt; b)&#123; if(a &gt; c)&#123; //当a大于b 同时 a大于c时，打印&quot;a is MAX&quot; System.out.println(&quot;a is MAX&quot;); &#125; else&#123; System.out.println(&quot;b &lt; a &lt;c &quot;); &#125; &#125; switch caseswitch case 类似于条件判断，通过switch的判断来选取对应的case，格式如下 switch(condition)&#123; case value: //action break; case value2: //action break; default: //当case中的value没有一个满足condition时，default中的指令才会执行 //action &#125; 例子 //输出输入数字所对应的英文（1-9） import java.util.Scanner; public class switch&#123; public static void main(String[] args) &#123; System.out.print(&quot;NUM: &quot;); Scanner num = new Scanner(System.in); int digit = num.nextInt(); String digitName; //String是字符串类型，属于引用数据类型，在后面有提到 switch (digit) &#123; case 1: digitName = &quot;one&quot;; break; case 2: digitName = &quot;two&quot;; break; case 3: digitName = &quot;three&quot;; break; case 4: digitName = &quot;four&quot;; break; case 5: digitName = &quot;five&quot;; break; case 6: digitName = &quot;six&quot;; break; case 7: digitName = &quot;seven&quot;; break; case 8: digitName = &quot;eight&quot;; break; case 9: digitName = &quot;nine&quot;; break; //有时为了节省空间，可以连在一起写 default: digitName = &quot;I cannot distinguish this number&quot;; break; &#125; System.out.print(digitName); num.close(); &#125; &#125; 每个case后面都跟有一个break，用于阻止case1中的action执行完毕后再执行case2的action 反例 import java.util.Scanner; public class switch2&#123; public static void main(String[] args) &#123; System.out.print(&quot;NUM: &quot;); Scanner num = new Scanner(System.in); int digit = num.nextInt(); String digitName; switch (digit) &#123; case 1: digitName = &quot;one&quot;; break; case 2: digitName = &quot;two&quot;; break; case 3: digitName = &quot;three&quot;; break; case 4: digitName = &quot;four&quot;; case 5: digitName = &quot;five&quot;; case 6: digitName = &quot;six&quot;; break; case 7: digitName = &quot;seven&quot;; break; case 8: digitName = &quot;eight&quot;; break; case 9: digitName = &quot;nine&quot;; break; default: digitName = &quot;I cannot distinguish this number&quot;; break; &#125; System.out.print(digitName); num.close(); &#125; &#125; 由于没有在case 4和 case 5后面加上break, 无论输入的是4还是5，最终给予digitName的赋值始终是 “six”; 直白点说，break就是用来阻止程序继续向下运行的指令 JAVA循环学完逻辑判断与基本的运算，接下来我们要了解一下java中的循环， java的循环如同其他语言一样，包含 for循环 while循环 do while循环 for循环结构 for(初始值；循环结束条件；初始值变化)&#123; //action &#125; 在for循环中，初始值一般是我们自定义的，例子如下 //我们创造一个for循环，这个循环运行5次，每次打印我们定义的变量的值 for(int i=0;i&lt;5;i++)&#123; System.out.println(i); &#125; 从输出的结果可以看出，当i的值等于5时，条件返回为false，循环终止 while循环格式 //判断条件指的是满足这个条件时，程序循环运行 while(判断条件)&#123; //action &#125; 例子 //与上面for循环的案例类似 int i=0; while(i &lt;5) &#123; System.out.println(i); i++; //前面计算符号补充部分有提及，i++指 i = i + 1 &#125; 如果对这个不太明白，下面有一幅图可以解释 总共运行了5次，在第6次时条件判断为false，所以循环停止 breakwhile循环还可以与之前switch case里面提到的break一起使用，例子如下 int i=0; while(i &lt; 7) &#123; //当i 等于 5 时，循环中止 if(i == 5) &#123; break; //break的作用是中止循环 &#125; System.out.println(i); i++; &#125; continue与break对应的是continue，break是中止循环 而continue是跳过这一轮循环将要执行的语句，直接进入下一轮循环，例子如下 public class test &#123; public static void main(String[] args) &#123; int i=0; while(i &lt;7) &#123; System.out.println(i); i++; //当i 等于 5时，跳过输出这一轮的 &quot;--------&quot; //由于i++放在前面，所以输出i后, i的值+1, 即在第5轮，输出i=4过后跳过输出 &quot;--------&quot; if(i == 5) &#123; continue; &#125; System.out.println(&quot;--------&quot;); &#125; &#125; &#125; do while循环格式 do&#123; //action &#125;while(判断条件); do while循环和while循环的区别是：无论条件为何，do while循环都会将action部分执行一遍，例子如下 public class test &#123; public static void main(String[] args) &#123; int i=0; do &#123; System.out.println(i); i++; &#125;while(i&lt;0); &#125; &#125; 判断与循环的应用前面几章我们学习了java的运算符，逻辑判断与循环，这一章举一些例子，灵活运用前面的知识 求最大公因数题目：求出48与292的最大公因数与最小公倍数， 程序分析：使用辗转相除法 public class LargestFactor &#123; public static void main(String[] args) &#123; int m =48; int n = 292; int a = m; int b = n; int r = a%b; while (r!=0) &#123; a = b; b = r; r = a%b; &#125; int divisor = b; System.out.println(&quot;The Greatest Common Divisor:&quot;+divisor); System.out.println(&quot;The Lowest Common Multiple:&quot;+(m*n)/divisor); &#125; &#125; 求100以内的素数题目：输出100以内的素数？ 程序分析：素数是大于1的正整数，只能除以它本身与1 public class isprime &#123; public static void main(String[] args) &#123; for(int i=2; i&lt;=100; i++) &#123; boolean isPrime = true; for (int j=2; j&lt;i; j++) &#123; if((i%j) == 0) &#123; isPrime = false; break; &#125; &#125; if(isPrime) &#123; System.out.println(i+&quot; is prime&quot;); &#125; &#125; &#125; &#125; 不死神兔题目：古典问题：有一对兔子，从出生后第3个月起都生一对兔子，小兔子长到第3个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少（20个月内）？ 程序分析：兔子的规律为数列1,1,2,3,5,8,13,21…(斐波那契数列) public class Test&#123; public static void main(String[] args)&#123; long a=1; long b=1; long c=0; System.out.print(a+&quot;\\t&quot;+b); //for循环用来计数 for(int i=3;i&lt;=20;i++)&#123; //a,b,c交换数据 c =a+b; a =b; b =c; System.out.print(c+&quot;\\t&quot;); &#125; &#125; &#125; 水仙花数题目：打印出1000以内的水仙花数，所谓的“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例如：152是一个“水仙花数”，因为153 =1的3次方+5的3次方+3的3次方。 程序分析：需要用到for循环，每个数分解出个位，十位，百位 public class flower &#123; public static void main(String[] args) &#123; //水仙花数是三位数，从100开始，到1000结束 for(int i=100; i&lt;1000; i++ ) &#123; //第一种获取每位的方法 int a = i/100; //对i取整，获取百位的数字 int b = (i-a*100)/10; // 减去1的百位上的数字，除以10，获取十位的数字 int c = i-100*a-10*b; //个位就是排除十位与百位 //第二种获取每位的方法 //int a = i/100; //int b = (i%100)/10; //对i除以100取余，再通过10取整，获得百位 //int c = (i%100)%10; //对i除以100取余，再通过10取余，获得个位 //第三种获取各位方法 //int num = i/10^0 %10; //个位 //int num = i/10^1 %10; //十位 int sum = a*a*a+b*b*b*b+c*c*c; if (sum==i) &#123; System.out.println(i+&quot;是水仙花数&quot;); &#125; &#125; System.out.println(&quot;Finish&quot;); &#125; &#125; 结果 99乘法表题目：输出9*9口诀 程序分析：嵌套式for循环，注意换行 public class test &#123; public static void main(String[] args) &#123; for(int i=1;i&lt;=9;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+(i*j)+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; &#125; 求Pi的值题目：根据Gregory-Leibniz series, 我们可以计算Pi的值,要求算到第10000个级数 程序分析：Pi = (4/1) - (4/3) + (4/5) - (4/7) + (4/9) - (4/11) + (4/13) … 观察发现规律：分母为奇数，偶数-1， public class test &#123; public static void main(String[] args) &#123; double rst=0.0; for(int i=1;i&lt;=10000;i++)&#123; //判断是偶数还是奇数 if(i%2==1)&#123; rst += 4.0/(2.0*i-1); //分母为奇数1，3，5，7…… &#125; else&#123; rst -= 4.0/(2*i-1); &#125; &#125; System.out.println(rst); &#125; &#125; JAVA函数函数，大家在初高中应该有所耳闻，例如f (x), f (x) 这个函数有名字f， 同时它也包含一个参数x。设置一个函数可以被我们连续调用，java或者说大部分主流的编程语言都继承了数学中函数的特点。 在本书的前面几章大家应该已经接触到了函数，System.out的println(“”)，这个就是一个系统类的函数（方法） 我们可以将想要打印在console（控制台）上的内容作为参数传入此函数（方法），它就将内容呈现出来 格式java的函数（在类对象中也可以叫做方法）格式 函数返回值类型可以为任意数据类型，int, double, char, string等 public static 都是修饰符，在后卖会讲到 return 的值类型一定要与定义函数时一致 在函数或方法中参数还有另外一个名字，形参；而我们传入时的参数叫实参（实际的参数） 作用域说到函数或方法，那一定要提及作用域，即我们创建的参数能够用在那些范围内 下面我们用一个例子来解释 public class test &#123; public static void main(String[] args) &#123; int a = 8; int b = 9; int c = add(a,b); //当要调用方法时，直接写该函数的名字与应该传入的参数 System.out.println(a); System.out.println(b); System.out.println(c); &#125; public static int add(int i, int j) &#123; int a = i + j; return a; &#125; &#125; 在上面的例子中，main主函数中的a, b, c是实参；而add函数中的i, j, a都是形参 我们可以看出虽然在main函数与add函数中a都是我们的参数，但是两者为什么都不冲突呢？ 因为作用域的不同导致了两者的不同。在add函数中定义的参数的作用域仅仅在add函数中，不超过add，而main函数中定义的参数的作用域也仅仅在main中，无法扩散到add函数中。 假如main函数想要与add函数交换参数，就必须通过形参和return。 void关键字有心的小伙伴也许已经发现了我们的main函数为什么没有返回值，且是返回值类型是void void的英文意思是空，即什么也没有 同理，用在函数上时，表示该函数接收参数但不需要有返回值，这个函数就像一个方法一样，如下 //写一个比较大小的程序 public class test &#123; public static void main(String[] args) &#123; int a = 19; int b = 79; int c = 100; MAX(a, b, c); //此时调用MAX方法，没有返回值 &#125; public static void MAX(int a, int b, int c) &#123; System.out.println(&quot;NUM: &quot;+a+&quot; &quot;+b+&quot; &quot;+c); int max = a; if(a &lt; b) &#123; max =b; if(b &lt; c) &#123; max = c; &#125; &#125; System.out.println(&quot;MAX is &quot;+max); &#125; &#125; 函数调用其他函数我们在一个函数中可以调用别的函数，例子如下 public class test &#123; public static void main(String[] args) &#123; int a = 19; int b = 79; int c = 100; MAX(a, b, c); &#125; public static void MAX(int a, int b, int c) &#123; System.out.println(&quot;NUM: &quot;+a+&quot; &quot;+b+&quot; &quot;+c); int max = a; if(a &lt; b) &#123; max =b; if(b &lt; c) &#123; max = c; &#125; &#125; print(max); //直接输入函数名与参数就可以使用该函数 &#125; //通过print函数我们把max的值打印出来 public static void print(int max) &#123; System.out.println(&quot;MAX is &quot;+max); &#125; &#125; JAVA数组上文提到了引用类型数据，在本章我将讲解其中一个引用类型数据：数组 对C语言或其他编程语言有所了解的伙伴应该听说过数组这个定义。数组，顾名思义，是将一系列统一的数据放在一起的组合。比如我们想将 ‘h’,’e’,’l’,’l’,’o’ 这几个字符放在一起之后再使用，此时我们就需要创建一个 字符类型的数组。 为什么说数组是引用类型的呢？ 当我们创立一个数组并赋予其值，并不是在内存中直接开辟含有这些数据的数组，而是将数组的指针指向这些数据。直白点说，数组就像浏览器中的收藏夹，我们需要点击哪个链接（数据）时，就打开这个收藏夹（数组） 以char类型的数组为例，接下来将介绍几种创建数组的方法 创建数组//声明数组变量 char[] words; char words[]; //创建数组的几种方法 //1 //每一组括号前要先声明数组中存储数据的类型 words = new char[5]; //在后面的括号中放的数据是我们所定义的数组的大小 //2 words2 = new char[5] //与上一个差不多 //当然声明与创建数组可以放在一起 char[] word = new char[5]; //3 char[] words3 = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;.&#39;l&#39;,&#39;o&#39;,&#125;; 当第1种和第2种数组创建完毕后，默认内部的5个元素都为’\\u0000’(char 类型的默认值); 当第3种数组创建完毕后，默认的元素是初始化的那些元素 import java.util.Arrays; public class test &#123; public static void main(String[] args) &#123; int[] words = new int[5]; char words2[] = new char[5]; char[] words3 = &#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;; //由于数组无法直接通过System.out.println打印出来， //我们需要调用Arrays包中的toString（）方法 System.out.println(&quot;words &quot;+Arrays.toString(words)); System.out.println(&quot;words2 &quot;+Arrays.toString(words2)); System.out.println(&quot;words3 &quot;+Arrays.toString(words3)); &#125; &#125; 结果 访问数组元素创建数组是为了储存数据，所以我们应该要明白如何访问/调用数组中的元素 我们需要通过数组的下标来访问数组中的元素 在计算机编程语言中，数组下标几乎都是从0开始（数组中第一个元素）,因为这样可以方便计算机的指针读取数据 所以数组中第一个元素下标是0，第二个元素下标是1，依次类推。注意最后一个元素的下标必须是（数组长度-1），因为元素下标是从0开始的。 public class array2&#123; public static void main(String[] args) &#123; double[] values = &#123;2,3,4,5&#125;; double one = values[0]; //注意获取数组中元素，接收的变量类型应与数组一致 double two = values[1]; System.out.println(one); System.out.println(two); &#125; &#125; 有心的同学应该注意到了，我们存进去的元素是整数类型，为什么最后打印出来是double呢？ 因为在存入double类型数组中时，编译器进行了自动类型转换，将整型转化为浮点double类型 遍历数组为了读取数组中的元素，我们通常使用遍历的方法 通过一组for循环来获取数组中的每个元素 public class array2&#123; public static void main(String[] args) &#123; double[] values = &#123;2,3,4,5&#125;; //public int length;是java数组中自带的方法，用于返回该数组的长度 for(int i=0;i&lt;values.length;i++) &#123; System.out.println(values[i]); &#125; &#125; &#125; 我们还可以使用for-each（也叫增强for）来遍历数组 for(type element : array)&#123; System.out.println(element); &#125; 增强for允许我们在不访问下标的情况下读取数组，十分方便 public class array2&#123; public static void main(String[] args) &#123; double[] values = &#123;2,3,4,5&#125;; for(double value: values) &#123; System.out.println(value); &#125; &#125; &#125; 数组与函数我们可以把数组作为一个返回值或参数放在函数中 将数组作为参数传入函数public class array2&#123; //add 将数组作为参数传入函数，返回数组中所有元素的和 public static double add(double[] values) &#123; double total = 0; for (double element : values) &#123; total = total + element; &#125; return total; &#125; public static void main(String[] args) &#123; double[] values = &#123;2,3,4,5&#125;; System.out.println(add(values)); &#125; &#125; 将数组作为返回值输出import java.util.Arrays; //将输入数组每个元素加1，并返回 public class array2&#123; public static double[] add(double[] values) &#123; for(int i=0;i&lt;values.length;i++) &#123; values[i] += 1; &#125; return values; &#125; public static void main(String[] args) &#123; double[] values = &#123;2,3,4,5&#125;; System.out.println(Arrays.toString(add(values))); &#125; &#125; 多维数组我们的现实世界是由多个维度所组成，一条线是一维， 一个平面是二维，我们所在的空间是三维 和现实世界类似，数组也可以创造多个维度 创建二维数组或多维数组的方式与一维数组类似 public class test &#123; public static void main(String[] args) &#123; int[][] num = new int[2][3]; //创建一个2行3列的二维数组 num[0][0] = 1; //给第一行，第一列的元素赋值为1 num[1][0] = 2; //给第二行，第一列的元素赋值为2 //因为是二维数组，通过两个for循环来遍历打印 for(int i=0;i&lt;num.length;i++) &#123; //num.length是获取二维数组的行数 for(int j=0;j&lt;num[0].length;j++) &#123; //num[0].length是获取第一行数组的个数，即num二维数组的列数 System.out.print(num[i][j]+&quot; &quot;); &#125; System.out.println(); &#125; &#125; &#125; 结果 在本章中我们有运用到一个数组的工具类, Arrays,在后面常用类中，我们会有详细的解释。 小案例 Tic-Tac-Toe (井字棋)import java.util.Scanner; public class TiTaTu&#123; public static void main(String[] args) &#123; //用二维数组模拟棋盘， 0和1代表O和X int [][] array = &#123; &#123;0,1,0,1&#125;, &#123;1,0,0,1&#125;, &#123;1,1,1,1&#125;, &#123;0,1,0,1&#125;, &#125;; boolean rst_X = false; boolean rst_O = false; int numOfX_S = 0; int numOfO_S = 0; int numOfX_RS = 0; int numOfO_RS = 0; int k = array.length -1; for(int n=0;n&lt;array.length;n++) &#123; int numOfX_H =0; int numOfO_H =0; for(int m=0;m&lt;array[n].length;m++) &#123; if(array[n][m] == 1) &#123; numOfX_H++; if(numOfX_H == array.length ) &#123; rst_X = true; &#125; &#125; else if(array[n][m] == 0)&#123; numOfO_H++; if(numOfO_H == array.length)&#123; rst_O = true; &#125; &#125; &#125; if(array[n][n] == 1) &#123; numOfX_S++; if(numOfX_S == array.length ) &#123; rst_X = true; &#125; &#125; else if(array[n][n] == 0) &#123; numOfO_S++; if(numOfO_S == array.length ) &#123; rst_O = true; &#125; &#125; //reverse diagonal line if(array[n][k] == 1) &#123; numOfX_RS++; if(numOfX_RS == array.length ) &#123; rst_X = true; &#125; &#125; else if(array[n][k] == 0) &#123; numOfO_RS++; if(numOfO_RS == array.length ) &#123; rst_O = true; &#125; &#125; k--; &#125; if(rst_X == true) &#123; System.out.print(&quot;X win&quot;); &#125; else if(rst_O == true) &#123; System.out.print(&quot;O win&quot;); &#125; else &#123; System.out.print(&quot;Equal&quot;); &#125; &#125; &#125; 案例2，打印二维数组初始值public class Print2DArray&#123; public static void PrintOut(int[][] array) &#123; for(int i=0; i&lt;array.length;i++) &#123; for(int j=0;j&lt;array[i].length;j++) &#123; System.out.printf(&quot;%3d&quot;, array[i][j]); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; int[][] a = new int[5][5]; PrintOut(a); &#125; &#125; JAVA类与对象不知道大家以前有没有听说过这样一句话“万物皆对象”。这句话出自Think in Java,一本今典的java书籍。在java中，任何东西都可以被描述成一个类，且每个类都能被用来实例化对象；因为周围的世界是由各种各样的对象所构成，所以我们可以利用java来模拟我们周围的世界，创建各种各样的类例如：学生类，老师类，汽车类，飞机类。 对象创建创建一个对象的前提是有这个对象的类，我们先创建一个Animal类 package Class_Study; public class animal &#123; private int age; //private是修饰符，后面会讲 public animal()&#123; //action 我们可以在这里添加一些指令 &#125; public animal(int num) &#123; age = num; &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; 拥有了animal这个类后，我们就可以实例化（创建）一个animal对象 animal Tom = new animal(); 以后要是想对animal对象进行一些操作，直接通过Tom调用animal的内部方法（长得像函数的东西）即可。 构造方法在类中的函数统一称作“方法” 有人也许注意到了在animal类中为什么还有与animal同名的方法呢？ 这些方法叫做构造方法，也称构造函数。 无参构造public animal()&#123; //public是修饰符 System.out.println(&quot;I am an animal.&quot;); //在无参构造方法里面，我们可以写一些指令 &#125; 像这一个构造方法，就是无参构造方法，当我们实例化对象时，可以不需要添加参数 animal Tom = new animal(); 假如我们书写的类中没有写构造方法，如下 package Class_Study; public class animal &#123; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; 此时，编译器会自动给我们加上一个无参构造方法，等同于这样 package Class_Study; public class animal &#123; public animal()&#123; &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; 有参构造有参构造方法就是在无参构造的基础上增添了参数，方便我们将外部的参数传递给实例化的对象 我们第一个实例化对象的例子中除了有无参构造方法，还有有参构造方法 public animal(int num) &#123; age = num; //将外部的参数num赋值给对象内部的age System.out.println(&quot;My age is &quot;+ age); //将age的值输出到控制台上 &#125; 因为是有参构造方法，我们实例化时可以加参数 int age = 3; animal Tom = new animal(age); //由于作用域的不同，我们在main函数中定义的age并不与animal对象中的age相冲突 注意当我们既没有写无参构造也没有写有参构造时，编译器会自动给我们加上一个无参构造方法。 但如果我们自己写了有参构造方法或无参构造方法任意一个以后，编译器就不会自动添加无参构造方法。 对象方法上面也提到了，在类对象中函数叫做方法method， 除了叫法不同，各种功能与函数一致 package Class_Study; public class animal &#123; private int age; public animal()&#123; &#125; public animal(int num) &#123; age = num; System.out.println(&quot;My age is &quot;+ age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; 在animal类中，roar就是对象方法。使用roar方法必须通过animal的实例化的对象来调用 public class animalTest &#123; public static void main(String[] args) &#123; animal Tom = new animal(3); Tom.roar(); &#125; &#125; 结果 因为在实例化过程中使用了有参构造方法，有参构造方法中有一行指令是打印age: “System.out.println(“My age is “+ age);” 所以在控制台中出现 My age is 3 我们通过Tom来调用类方法 Tom.roar(); 所以程序执行此方法，在控制台中打印 “I am yelling” this关键字this关键字可以用于在本类中调用，本类方法或实例变量； 它也可以用于调用本类中其他构造方法； this可以理解为当前对象 一个一个分析； 实例变量 当我们方法中的形参与类对象中的参数名字一样时，使用this关键字可以避免运行时的error,如下 没有使用this 关键字时 public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; public class animalTest &#123; public static void main(String[] args) &#123; animal Tom = new animal(3); Tom.printAge(); &#125; &#125; 此时的编译器 为什么我们输的是3，而打印的却是0 ？因为我们并没有将值真正赋给对象的age 为了避免这种无效赋值的情况，我们需要使用this this的作用相当于告诉编译器，你要把我传进的参数age赋值给类对象的age,然后调用类对象的age打印输出 public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; 本类方法 为了表示方便，在本类中调用本类方法，可以在调用的方法前加上this public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); this.Hungry(); &#125; public void Hungry() &#123; System.out.println(&quot;I am hungry!!&quot;); &#125; &#125; 这个this加或不加都没关系，编译器会帮我们自动加上 调用本类的其他构造方法 this可以调用构造方法，这样能避免相同初始化代码 this()是用来调用无参构造方法的 没加this() public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ this.age); &#125; &#125; 加上this(); public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this(); //必须方法构造方法最前面 this.age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ this.age); &#125; &#125; 可见，加上this()就调用了animal的无参构造方法 注意，this();必须在调用的方法最前面 this(a); 可以调用有参构造方法， a是有参构造需要的参数，例子如下 public class animal &#123; private int age; public animal()&#123; this(3); System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ this.age); &#125; &#125; //测试类 public class animalTest &#123; public static void main(String[] args) &#123; animal Tom = new animal(); Tom.printAge(); &#125; &#125; 我们直接调用animal的无参构造，但是age是有初始值的，就是我们在无参构造中this(3);传入的age。 方法重载Overload方法可以重载，当然之前学习的函数也可以重载；重载后的方法可以接收不同参数 所谓的重载Overload针对同一个类，在这个类里面可以包含名字相同但是接收参数不同的的方法。例子如下。 public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this(); this.age = age; &#125; public void printAge() &#123; System.out.println(&quot;My age is &quot;+ this.age); &#125; //对printAge进行Overload public void printAge(int year) &#123; this.age += year; System.out.println(&quot;After &quot;+year+&quot; years. My age is &quot;+this.age); &#125; &#125; public class animalTest &#123; public static void main(String[] args) &#123; animal Tom = new animal(3); Tom.printAge(); Tom.printAge(4); &#125; &#125; 结果 其实方法的重载就像无参构造方法与有参构造方法一样 对象封装封装，顾名思义将数据封起来，不让外界轻易访问。在java开发时，我们有时不希望外界访问或改变我们设计好的数据，此时需要将这些数据封装起来。 为了封装数据，我们需要一些访问修饰符，例如public, private(这些在前面大家应该已经遇到了，但是不知道是什么) 一般用访问修饰符时，都用public 或 private ，public定义的数据都可以访问，但是private的只有本类才能访问 封装可以使数据更安全，假如说想要获取或改变数据，可以使用get, set, 例子如下 public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; //有set的好处就是，假设在给age赋值时传入的时string类型或其他类型，set里面可以加上判断 this.age = age; &#125; 对象继承介绍聊完上面几章，我们进入对象中比较重要的环节，对象继承，这就像儿子与父亲一样，所以被继承的类大家称为父类，继承的类称之为子类 子类对于父类的继承 子类继承父类所有public方法与属性， 也可以添加自己独有的方法 JAVA继承遵循单一继承关系， 即一个子类只能继承一个父类 当子类添加自己方法时可以对父类方法进行覆盖， override。 例如父类可以使用a方法，子类继承a方法，可以再写一遍a方法，使a方法实现另一种 //继承语法： class B extends A&#123; &#125; //B是子类， A是父类， 子类继承父类 例子 package Class_Study; //animal是父类 public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; package Class_Study; public class TestForAnimal &#123; public static void main(String[] args) &#123; Dog kit = new Dog(); kit.roar(); &#125; &#125; class Dog extends animal&#123; Dog()&#123; System.out.println(&quot;I am a dog.&quot;); &#125; //方法覆盖override public void roar() &#123; //super.roar();这个super关键字后面再讲 System.out.println(&quot;I am hungry. I need meat&quot;); &#125; &#125; 在实例化子类对象时，我们会先调用父类的默认构造方法，再调用子类的构造方法， 这就是为什么会出现”I am an animal” 在上面这个例子中，dog类是animal类的子类，它继承了父类的方法 Dog kit = new Dog(); //实例化子类对象，调用子类的无参构造方法 在具有继承关系的创建中，系统先创建父类再创建子类。 如果有默认的构造方法， 先调用父类A的默认无参构方法，再调用子类B的所属构造方法。 这就是为什么我们调用dog类的无参构造方法时，先打印“I am an animal.”，再打印“I am a dog.” //方法覆盖override public void roar() &#123; System.out.println(&quot;I am hungry. I need meat&quot;); &#125; 在子类中，子类拥有与父类相同的方法，这样可以对父类的方法进行覆盖，（方法的Override必须是方法一样）（即访问修饰符+返回值类型+名称+传入参数类型一样） 多态世间万物都有属于自己的类，这些类之间又可以进行分类，例如汽车，飞机等可以被分在（继承）交通工具类里面；老师，学生，家长可以被分在（继承）人这个类里面。我们可以用交通工具类或人类来作为汽车或学生宽泛的表示方法。 使用父类作为方法形参实现多态， 使方法参数类型更为宽泛 使用父类作为方法返回值实现多态， 使方法可以返回不同子类对象 例子： A a = new B()； A是B的父类 使用多态时，只能使用父类的方法或子类覆盖父类的方法， 例如 //例子 package Class_Study; public class animal &#123; private int age; public animal()&#123; System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; package Class_Study; public class TestForAnimal &#123; public static void main(String[] args) &#123; animal kit = new Dog(); kit.roar(); // 作为父类的kit只能调用子类覆盖后的方法或自己本身的方法 &#125; &#125; class Dog extends animal&#123; //狗类继承了父类animal类，覆盖了roar()这个方法 Dog()&#123; System.out.println(&quot;I am a dog.&quot;); &#125; //方法覆盖override public void roar() &#123; System.out.println(&quot;I am hungry. I need meat&quot;); &#125; public void run() &#123; System.out.println(&quot;I can use four legs to run!!&quot;); &#125; &#125; 假设我们作为父类，再调用子类的方法，例如这个：用kit animal类调用dog子类的run方法，出现错误 向上转型格式 //Animal类是Dog类的父类 Animal a = new Dog() 刚才上面那个例子就使用了向上转型的方法（子类转为父类）。 向下转型向下转型前提是 原来实例是子类（先向上转型）： Animal a = new Dog() Dog dog = (Dog) a //利用强转向下转型 多态的好处是有很强的扩展性，例如这样 speak(new Cat()); speak(new Dog());//此时我们将cat类与dog类作为参数传进去 public void speak(Animal a)&#123; a.roar(); //函数会自动向上转型，调用cat与dog类中Override父类Animal的roar方法 &#125; instanceof关键字向下转型前，应判断引用中对象的真实类型，以达到准确性 语法， （dog instanceof animal）//返回结果为boolean if (args instanceof type) &#123; type new_name = (type) args; &#125; package Class_Study; public class TestForAnimal &#123; public static void main(String[] args) &#123; animal animal = new Dog(); if (animal instanceof Dog) &#123; //判断animal的真实类型是否是Dog类，是的话进行向下转型 Dog dog = (Dog) aanimal; dog.run(); &#125; &#125; &#125; class Dog extends animal&#123; Dog()&#123; System.out.println(&quot;I am a dog.&quot;); &#125; //方法重写override public void roar() &#123; System.out.println(&quot;I am hungry. I need meat&quot;); &#125; &#125; super关键字作为子类，我们继承了父类的方法，但当我们继承父类后并Override父类方法后，我们就不能再使用父类的方法，为了能再次使用，我们需要使用super关键字 和this()一样，super()必须是第一条语句 可以调用父类的属性和方法 super.upload() // 父类的方法 super.value //父类的属性，注意这个属性必须是public公共属性，私有属性无法继承 例子，调用父类属性 public class Value &#123; public static void main(String[] args) &#123; B b =new B(); b.print(); &#125; &#125; class A&#123; int value =10; &#125; class B extends A&#123; int value = 20; public void print() &#123; int value =30; System.out.println(value); //就近原则，选取本方法中的value System.out.println(this.value); //this调用本类中的value System.out.println(super.value);//super调用父类中的value &#125; &#125; 例子，调用父类的方法 package Class_Study; //父类 public class animal &#123; private int age; public animal()&#123; &#125; public animal(int age) &#123; this.age = age; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; package Class_Study; //子类 public class TestForAnimal &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.roar(); &#125; &#125; class Dog extends animal&#123; Dog()&#123; System.out.println(&quot;I am a dog.&quot;); &#125; //方法重写override public void roar() &#123; super.roar(); //通过super调用父类的roar方法 System.out.println(&quot;I am hungry. I need meat&quot;); &#125; public void run() &#123; System.out.println(&quot;I can use four legs to run!!&quot;); &#125; &#125; 结果 super也可以调用父类构造方法 super() // 调用无参构造方法 super(5, 6) //调用有参构造方法 在继承章节开头我们碰见的那个例子里面，当调用我们调用子类构造方法时，系统会自动调用父类的无参构造方法，即在子类无参构造之前加上super();如下 package Class_Study; //父类 public class animal &#123; private int age; public animal()&#123; //父类的无参构造 System.out.println(&quot;I am an animal.&quot;); &#125; public animal(int age) &#123; this.age = age; System.out.println(&quot;My age is &quot;+ this.age); &#125; public void roar() &#123; System.out.println(&quot;I am yelling.&quot;); &#125; &#125; package Class_Study; //子类 public class TestForAnimal &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); &#125; &#125; class Dog extends animal&#123; Dog()&#123; super(); System.out.println(&quot;I am a dog.&quot;); &#125; //方法重写override public void roar() &#123; super.roar(); System.out.println(&quot;I am hungry. I need meat&quot;); &#125; public void run() &#123; System.out.println(&quot;I can use four legs to run!!&quot;); &#125; &#125; 加上super() 没加super() 编译器默认调父类无参构造方法（在没加super()的前提下），不管子类调用的是否是无参还是有参构造 当C对象继承B对象，B对象继承A对象时，实例化C对象，先调用A的无参构造，然后调用B的无参构造，最后调用C的无参构造 //子类调用父类的有参构造 Dog()&#123; super(3); //在Dog子类的无参构造方法中，调用父类的有参构造 System.out.println(&quot;I am a dog.&quot;); &#125; 结果 对象是引用类型为什么说对象是引用类型？ 我们new一个对象，其实是用一个指针指向这个部分数据集合，例子如下 //创建一个Point类，有x,y值 public class Point &#123; private int x; private int y; public void SetPoint(int x, int y)&#123; this.x =x; this.y =y; &#125; public void show() &#123; System.out.println(&quot;(&quot;+this.x+&quot; , &quot;+this.y+&quot;)&quot;); &#125; &#125; public class TestPoint &#123; public static void main(String[] args) &#123; //实例化一个Point类 Point a = new Point(); //将a点的地址传入SetPoint函数 SetPoint(a); //如果对象不是引用类型，a点的x,y值就不会改变 a.show(); &#125; public static void SetPoint(Point b) &#123; b.SetPoint(5, 5); &#125; &#125; 结果 上面例子的box diagram 包装类由于基本类型不是对象，在万物皆对象的JAVA中，我们有时需要将这些数据封装成对象，这就是包装类 基本数据 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 基本类型封装的好处 方便进行对象操作 便于数据与字符串之间的转换 例如：将数字1转为字符串1，再将字符串1转为数字1 public class NumDemo1 &#123; public static void main(String[] args) &#123; int i =1; //把基本数据int封装成Integer Integer num = new Integer(i); //数字转为字符串 String word = num.toString(); //打印转成的类型 System.out.println(word.getClass()); //将字符串转为数字，打印转成的类型 System.out.println(Integer.valueOf(word).getClass()); &#125; &#125; JAVA字符串在前面大家已经不止一次接触到了字符串String类型数据，String字符串是一个功能强大的类，它可以将多个字符放在一起，如下 char word = &#39;h&#39;; String words = &quot;hello world&quot;; 字符串与字符有一点区别：字符串内容放在双引号内，而字符则是单引号。 特点 字符串是常量，创建后不可改变 字符串字面值储存在字符串池中，可以共享 String str = new String(“Java”)在堆里面创建一个对象 常用方法public int length() //返回字符串长度 public char charAt(int index) //根据下标获取字符 public boolean contains(String str) //判断当前字符串是否包含传进去的字符str public int indexOf(String str)//查找str首次出现的下标，存在则返回该下标，不存在则返回-1 public int lastIndexOf(String str)//查找字符串当中最后出现的下标索引 public String trim()//去除字符串前后的空格 public String toUpperCase()//全部转为大写 public boolean endWith(String str)//判断字符串是否是以str结尾 public boolean startWith(String str)//同样，也有以str开头的判断 public String replace(char oldChar, char newChar)//将原来旧的字符串替换为新的字符串 public String concat(String s)//返回连接后的字符串， s是加在后面的字符串 public String substring(int beginIndex, int endIndex)//返回一个分割过后的字符串 public char[] toCharArray()//将字符串转换成数组 Arrays.toString(char[] string)//为了将数组内的字符打印出来，调用Arrays工具类 下面用一串代码来演示如何使用这些方法 package StringStudy; import java.util.Arrays;//为了把数组中的内容转成字符串并打印出来 public class Demo1 &#123; public static void main(String[] args) &#123; String words = &quot;hello&quot;; System.out.println(words); words = &quot;world&quot;; System.out.println(words); String str = new String(&quot;Java&quot;); String str2 = new String(&quot;Java&quot;); System.out.println(&quot;str与str2是否在同一地址：&quot;+(str == str2)); System.out.println(&quot;str与str2是否内容完全相同&quot;+str.equals(str2)); System.out.println(&quot;words在第一个的字符串是:&quot;+words.charAt(0)); System.out.println(&quot;将words转化为数组后的 Array:&quot;+Arrays.toString(words.toCharArray())); System.out.println(&quot;将words转化为数组后的Array[0]:&quot;+words.toCharArray()[0]); System.out.println(&quot;判断words中是否含有w:&quot;+words.contains(&quot;w&quot;)); System.out.println(&quot;判断words中是否含有wd:&quot;+words.contains(&quot;wd&quot;)); System.out.println(&quot;返回对应字符串rd的下标：&quot;+words.indexOf(&quot;rd&quot;)); words = &quot;hello&quot;; System.out.println(&quot;返回对应字符串l的下标：&quot;+words.indexOf(&quot;l&quot;)); System.out.println(&quot;返回对应字符串l最后的下标：&quot;+words.lastIndexOf(&quot;l&quot;)); String student = &quot; Peter Bear &quot;; System.out.println(&quot;After deleting SPACE in String----&quot;+student.trim()+&quot;----&quot;); System.out.println(&quot;将字母全部改为大写:&quot;+student.toUpperCase()); System.out.println(&quot;将原来的字符串中的内容进行替换:&quot;+student.replace(&quot;ear&quot;, &quot;ear is 18 years old.&quot;)); String website = &quot;www.peterbear.com&quot;; System.out.println(&quot;返回在原来的字符串后面增添内容的字符出：&quot;+student.concat(&quot;&#39;s website: &quot;).concat(website)); &#125; &#125; 结果 JAVA修饰符再类对象封装中我们提到的private， public属于JAVA的访问修饰符；在本章我们将介绍其他的修饰符：非访问修饰符 staticstatic中文翻译是静态，所以关于static 的方法和属性叫做静态属性和静态方法 使用静态修饰符后程序会发生哪些变化？ 静态属性和方法利用类名进行调用（假如说一个类仅含有static成员，那么这个类被称作工具类） 静态成员是全类所共享的成员 static 关键字用来声明独立于对象的静态变量（静态属性），无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 //静态属性 static int count=10; 例子如下 package modifier; //创建一个类，这个类有静态属性与非静态属性，含静态方法与非静态方法 public class StaticStudy &#123; public int cnt=0; //非静态属性 public static int cnt2=0; //静态属性，静态变量 public void add() &#123; cnt++; &#125; public static void add2() &#123; cnt2++; &#125; public void show() &#123; //因为静态成员是全类所共享的成员，所以非静态方法可以调用静态成员变量 System.out.println(&quot;非静态计数器&quot;+cnt); System.out.println(&quot;静态计数器: &quot;+cnt2); &#125; &#125; package modifier; public class TestStatic &#123; public static void main(String[] args) &#123; StaticStudy num = new StaticStudy();//实例化一个类对象 num.show();//初始值，调用show非静态方法 num.add(); StaticStudy.add2();//通过类名调用静态方法 num.show();//add后的值 System.out.println(&quot;类名调用静态属性: &quot;+StaticStudy.cnt2);//类名调用静态属性 System.out.println(&quot;----实例化第二个对象&quot;+&quot;----&quot;); StaticStudy num2 = new StaticStudy();//再实例化一个类对象 num2.add(); StaticStudy.add2(); num2.show(); &#125; &#125; 从上面例子我们不难发现无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态方法特点 静态方法可以直接访问静态成员 private static int cnt3=0; public static int cnt2=0; //静态属性，静态变量 public static void add2() &#123; //静态方法给cnt2加一 cnt2++; &#125; 但是静态方法不能直接访问非静态成员 静态方法不能使用this和super关键字 静态方法不能重写，只能继承，没有多态 静态代码块static&#123; &#125; //整个程序执行过程中，只执行一次 //可以执行一些必要的初始化行为 //与其相反的是非静态代码块 &#123; &#125; 静态代码块中只能放静态成员 系统初始化过程：静态代码块—-&gt;main函数—-&gt;非静态代码块—-&gt;构造函数 这里请参考下面的链接 静态类倘若一个类是静态的，它一定是静态内部类//这个在讲到内部类的时候再具体分析 finalfinal意为最终的，最后的，即不可变的 最终类final修饰的不能被继承， 例如String, Math,System类，这些类的均无法被继承 当FinalStudy准备继承Point类时，由于Point类是被final修饰，所以无法被继承 最终变量final int num = 10; final static string address = &quot;school&quot;; 只能被赋值一次（常量） 1. 在构造方法中赋值 如果有一个对常量赋值，其他的构造方法都要对其进行赋值 2. 创建常量时直接赋值 我们创建了一个Point类，使用final修饰了原点，当我们想要改变原点数据时，失败 对于最终变量有两种初始化方法， 第一种：直接创建时就赋值 final int Origion_x=0; final int Origion_y=0; 第二种：使用代码块进行赋值 final int Origion_x; final int Origion_y; &#123; Origion_x=0; Origion_y=0; &#125; 第三种：在构造方法中 final int Origion_x; final int Origion_y; Point()&#123; Origion_x=0; Origion_y=0; &#125; 倘若变量用static + final修饰，为静态常量，初始化要在静态代码块中进行 第一种：直接创建时就赋值 static final int Origion_x=0; static final int Origion_y=0; 第二种：使用代码块进行赋值 static final int Origion_x; static final int Origion_y; static&#123; Origion_x=0; Origion_y=0; &#125; 最终方法不能被子类覆盖或者重写，只能继承 我们给父类的Print方法加上final修饰后，子类FinalStudy无法Override Print方法，所以只能继承该方法 例子如下 package modifier; public class FinalStudy extends Point&#123; &#125; class Point&#123; private int x; private int y; public void SetPoint(int x, int y) &#123; this.x =x; this.y =y; &#125; public final void Print() &#123; System.out.println(&quot;( &quot;+this.x+&quot;, &quot;+this.y+&quot; )&quot;); &#125; &#125; package modifier; //测试 public class TestFinal &#123; public static void main(String[] args) &#123; FinalStudy point = new FinalStudy(); point.SetPoint(1, 2); point.Print(); &#125; &#125; 对象常量final修饰基本类型：值不可变 final 修饰引用类型：地址不可改变 例子如下 class Point&#123; private int x; private int y; static final int Origion_x; static final int Origion_y; static&#123; Origion_x=0; Origion_y=0; &#125; public void SetPoint(int x, int y) &#123; this.x =x; this.y =y; &#125; public void Print() &#123; System.out.println(&quot;原点： &quot;+&quot;( &quot;+Origion_x+&quot;, &quot;+Origion_y+&quot; )&quot;); System.out.println(&quot;( &quot;+this.x+&quot;, &quot;+this.y+&quot; )&quot;); &#125; &#125; package modifier; import java.util.Arrays; public class TestFinal &#123; public static void main(String[] args) &#123; final int[] nums = new int[] &#123;1,3,5,7&#125;; System.out.println(Arrays.toString(nums)); // nums = new int[] &#123;5,6,7&#125;;//此时不能对nums再进行赋值，因为已经nums已经变成了常量 nums[0] = 9; //但是nums内部的数据可以进行更改，因为nums是引用类型 System.out.println(Arrays.toString(nums)); final Point p1 = new Point(); p1.SetPoint(6, 6); p1.Print(); p1.SetPoint(10, 10); p1.Print(); &#125; &#125; 结果 abstractabstract中文意思是抽象，抽象即为不具体 抽象类一个类不能同时被abstract和final修饰 当类对象没有具体的含义，可以将该类改为抽象类 例如Animal类，它本身没有任何意义各种方法比较抽象，但是继承Animal类的子类Dog类和Cat类有意义，所以要把Animal类改为抽象类 作用： 可以被子类继承，提供共性的属性和方法 可以声明为引用，更自然的使用多态 抽象类当中可以包含抽象方法，也可以包含非抽象方法 //语法： public abstract class Animal&#123; &#125; 如果一个类被改为抽象类，该类就不可以被实例化， 即不能new 对象；但是我们能够用这个类来作为引用，就像多态向上转型一样 下面是一个关于抽象类的例子 package modifier; public class TestAbstract &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.speak(); Animal bird = new Bird(); //可以声明为引用，更自然的使用多态 bird.speak(); //dog和bird调用父类的walk方法 dog.walk(); bird.walk(); &#125; &#125; abstract class Animal&#123; public abstract void speak(); public abstract void move(); //抽象类中包含非抽象方法 public void walk() &#123; System.out.println(&quot;I am walking&quot;); &#125; &#125; class Dog extends Animal&#123; @Override public void speak() &#123; System.out.println(&quot;Wang Wang Wang……&quot;); &#125; @Override public void move() &#123; System.out.println(&quot;Dog uses his four legs to run&quot;); &#125; &#125; class Bird extends Animal&#123; @Override public void speak() &#123; System.out.println(&quot;Yin Yin Yin……&quot;); &#125; @Override public void move() &#123; // TODO Auto-generated method stub &#125; &#125; 抽象方法一但类当中包含抽象方法，此类必须是抽象类 父类对象的方法本身没有意义，但为了实现多态（向上转型）又不得不保留 Animal dog = new Dog(); dog.eat(); 抽象方法只有方法的声明，没有方法实现，此外抽象方法只能在抽象类当中 //格式 public abstract void eat(); 子类继承父类，子类必须重写父类的抽象方法，否则子类必须是抽象类 //抽象的felid猫科动物类继承抽象的动物类，其中增添了抽象的猫科动物捕猎方法 abstract class felid extends Animal&#123; abstract void hunt(); &#125; 抽象类与抽象方法的小案例： 建立一个Vehicle的交通工具抽象类和一个主人类，打印主人回家时开的什么车，是什么品牌 package Polymophic_And_Abstract; public class Master &#123; private final String name; //将主人的名字封装起来 public Master(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void GoHome(Vehicle vehicle) &#123; System.out.println(this.getName()+&quot;回家了&quot;); vehicle.run(); &#125; &#125; package Polymophic_And_Abstract; public class TestForVehicle &#123; public static void main(String[] args) &#123; Master jim = new Master(&quot;Jim&quot;); Vehicle car = new Car(&quot;奔驰&quot;); jim.GoHome(car); &#125; &#125; //创建一个抽象的Vehicle类 abstract class Vehicle &#123; private final String band; public Vehicle(String band) &#123; this.band = band; &#125; public String getBand() &#123; return band; &#125; //一个抽象方法 public abstract void run(); &#125; //Car继承抽象的Vehicle交通工具类 class Car extends Vehicle&#123; public Car(String band) &#123; super(band); &#125; //implements 实现run()方法 @Override public void run() &#123; System.out.println(super.getBand()+&quot;牌的车在路上跑&quot;); &#125; &#125; 结果 JAVA接口介绍接口相当于是特殊的抽象类，定义方法，组成部分与抽象类类似 接口没有构造方法，所以不能创建对象但是可以implements，一个类可以实现多个接口，例如 C extends A implements B implements C 接口也可以和父类一样实现多态（向上转型）仅可调用接口中实现的方法，不能调用实例化对象所独有的方法 接口往往可以代表一种能力，一但类对象实现了该接口，它也具备了这种能力 实现接口时，访问修饰符必须是public 接口与抽象类相同之处： 可编译成字节码文件 不能创建对象 可以作为引用类型 // 当作为引用类型时，仅可调用实现了的接口； 具有Object类中定义的方法（Object类是所有类对象的父类） 不同之处： 接口所有属性都是用public static final修饰 接口所有方法都是用public abstract 修饰 接口没有构造方法，动态代码块和静态代码块 类无法使用多继承，但是接口可以实现多继承接口 package Interface; public interface Ability extends flyable, swimmable&#123; public abstract void fire(); &#125; interface flyable&#123; public abstract void fly(); &#125; interface swimmable&#123; public abstract void swim(); &#125; interface关键字类对象是class,而接口则是interface public interface A&#123; public static final String FIELD = &quot;Value&quot; public abstract void method(); &#125; 注意接口只能定义：公开静态常量 和公开抽象方法 public static final String FIELD=&quot;Value&quot;; //公开静态常量，使用时，直接用接口进行调用 public abstract void method();//公开抽象方法只用写返回值类型和方法名 类一但implement就必须实现覆盖接口中全部抽象方法，此类就是该接口的实现类 补充标记接口，例如Serializable接口 public interface Serializable&#123;&#125;; //表示实现这个接口的对象可以被序列化和克隆 public interface Cloneable&#123;&#125;; 案例 给人实现飞的能力 //先创建fly的接口 package Interface; public interface fly &#123; public abstract void fly(); &#125; //然后创建一个人类，来实现fly接口 package Interface; public class Person implements fly&#123; String name; int age; Person(String name, int age)&#123; this.name= name; this.age = age; &#125; public void eat() &#123; System.out.println(this.name+&quot; 在吃饭……&quot;); &#125; public void sleep() &#123; System.out.println(this.name+&quot; 在睡觉……&quot;); &#125; //由于继承了接口，我们必须实现接口的方法 @Override public void fly() &#123; System.out.println(this.name+&quot; can fly&quot;); &#125; &#125; //写一个测试类 package Interface; public class TestPerson &#123; public static void main(String[] args) &#123; Person jim = new Person(&quot;Jim&quot;,20); jim.fly(); //利用接口作为引用类型 fly baby = new Person(&quot;baby&quot;, 30); baby.fly(); &#125; &#125; USB案例 USB接口是大家熟知的一种接口，风扇，U盘，都是USB接口，我们要将USB接口插入电脑 //1先创建USB接口 package USB_Interface; public interface USB &#123; public abstract void Service(); &#125; //2实现Fan，U盘的接口 //U盘 public class USB_Flash implements USB &#123; @Override public void Service() &#123; System.out.println(&quot;USB-Flash has connected to the computer&quot;); &#125; &#125; //风扇 public class Fan implements USB&#123; @Override public void Service() &#123; System.out.println(&quot;Fan starts to run&quot;); &#125; &#125; //3由于我们要将U盘和风扇插入电脑中，所以要创建一个电脑类 package USB_Interface; public class Computer &#123; private USB usb1; private USB usb2; public USB getUsb1() &#123; return usb1; &#125; public void setUsb1(USB usb1) &#123; this.usb1 = usb1; &#125; public USB getUsb2() &#123; return usb2; &#125; public void setUsb2(USB usb2) &#123; this.usb2 = usb2; &#125; public void Run() &#123; System.out.println(&quot;Computer starts to work!!&quot;); if(this.getUsb1() != null) &#123; usb1.Service(); &#125; if(this.getUsb2() != null) &#123; usb2.Service(); &#125; &#125; &#125; //4最终的测试类 package USB_Interface; public class Test_USB &#123; public static void main(String[] args) &#123; Computer Windows = new Computer(); Windows.setUsb1(new Fan()); Windows.setUsb2(new USB_Flash()); Windows.Run(); &#125; &#125; 结果 JAVA内部类创建在类内部的类叫做内部类， class Outer&#123; //外部类 class Inner&#123; //内部类 &#125; &#125; 内部类拥有和普通类一样的属性，可以拥有方法，能够去实现接口，继承 如果外部类与内部类成员属性名字相同，则优先访问内部类成员如果想要访问同名外部类成员，需要先写上外部类名字，再this.name，或直接Outer.this.name 既然已经有了外部类，那为什么还要内部类呢？ 好处 内部类可以对外部类全部内容进行访问 方便访问外部类的私有属性（内部类可直接访问外部类的私有成员而不破坏封装） 成员内部类package InnerClass; import InnerClass.OuterClass.InnerClass; public class NormalInnerTest &#123; public static void main(String[] args) &#123; //1. 第一种实例化内部类的方法 //OuterClass outer = new OuterClass(); //InnerClass inner = outer.new InnerClass(); //2. 第二种实例化内部类的方法，一步到位 InnerClass inner = new OuterClass().new InnerClass(); inner.print(); &#125; &#125; class OuterClass&#123; private String words=&quot;Outer Class&quot;; class InnerClass&#123; public void print() &#123; System.out.println(OuterClass.this.words); new OuterClass().print(); System.out.println(&quot;Inner Class: Hello World&quot;); &#125; &#125; public void print() &#123; System.out.println(words+&quot;: Hello World&quot;); &#125; &#125; 成员内部类不能定义静态成员 静态内部类静态内部类可以不依赖外部类对象实例化对象 只有静态内部类可以用static修饰 //实例化静态内部类 Outer.Inner StaticInnerDemo =new Outer.Inner(); 案例 package InnerClass; class Outer&#123; //外部类中包含静态成员变量与非静态成员变量 private static String inf = &quot;Hello World&quot;; private String inf2 = &quot;GoodBye World&quot;; //创建静态内部类 public static class Inner&#123; //静态内部类里面包含静态方法与非静态方法 private static void print() &#123; System.out.println(&quot;\\t静态成员变量： &quot;+inf); //静态内部类无法直接调用非静态变量 // System.out.println(inf2); //由于外部类成员变量为私有，需要借助外部类来访问 Outer out = new Outer(); System.out.println(&quot;\\t非静态成员变量： &quot;+out.inf2); &#125; //非静态方法 public void print2() &#123; System.out.println(&quot;\\t非静态方法调用静态成员变量： &quot;+inf); &#125; &#125; //普通内部类 public class Inner2&#123; //普通成员内部类无法创建静态方法 public void print() &#123; //但是可以调用外部类中的静态成员变量 System.out.println(&quot;\\t静态成员变量： &quot;+inf); System.out.println(&quot;\\t非静态成员变量： &quot;+inf2); &#125; &#125; //外部类能够创建非静态方法 public void fun() &#123; //在外部类的方法中实例化内部类 Inner innerDemo = new Inner(); System.out.println(&quot;静态内部类的静态方法&quot;); //直接通过内部类类名访问静态方法 Inner.print(); System.out.println(&quot;静态内部类的非静态方法&quot;); //访问内部类非静态方法需要通过实例化的对象来访问 innerDemo.print2(); &#125; &#125; public class InnerClassDemo1 &#123; public static void main(String[] args) &#123; //实例化静态内部类 Outer.Inner StaticInnerDemo =new Outer.Inner(); //实例化普通内部类 Outer shell = new Outer(); shell.print(); Outer.Inner2 NormalInnerDemo = shell.new Inner2(); System.out.println(&quot;静态内部类的非静态方法&quot;); StaticInnerDemo.print2(); System.out.println(&quot;普通内部类的方法&quot;); NormalInnerDemo.print(); &#125; &#125; 结果 局部内部类把一个类定义在方法内部，这个类叫做局部内部类，就像定义在方法中的变量叫局部变量一样 局部内部类不能定义访问修饰符，即不能定义为static 但是可以包含静态常量，private final static int count =2000; public void fun(final String temp)&#123; class Inner&#123; public void print()&#123; System.out.println(info); System.out.println(temp); &#125; &#125; //实例化内部类，调用内部类方法 new Inner().print(); &#125; 匿名内部类在java中处理内部类之外，还有一种匿名内部类。 匿名内部类就是指没有一个具体名称的类，此概念是在接口和抽象类的应用上发展起来的, 有时这种类只用一次，命名又可惜，所以就使用匿名内部类 以之前写的Ability接口为例 //接口 package InnerClass; public interface Ability extends flyable&#123; public abstract void swim(); &#125; interface flyable&#123; public abstract void fly(); &#125; package InnerClass; import Interface.Ability; public class AnonymousInnerClass &#123; public static void main(String[] args) &#123; Ability SuperMan = new Ability()&#123; @Override public void swim() &#123; // TODO Auto-generated method stub System.out.println(&quot;I can swim&quot;); &#125; @Override public void fly() &#123; // TODO Auto-generated method stub System.out.println(&quot;I can fly&quot;); &#125; &#125;; SuperMan.swim(); SuperMan.fly(); &#125; &#125; 使用匿名内部类时，必须继承一个父类或实现一个接口 JAVA泛型JAVA泛型英文generics, 本质是参数化类型，就是把类型作为参数传递，泛型对象不能被实例化：T type = new T(); 这么说大家估计还是觉得这个定义比较抽象， 举个例子：我们要写一个排序方法，这个方法能够对int类型，String类型，double类型都进行排序，此时要使用泛型方法 泛型可以提高代码的重复性，防止类型转换异常，提高代码的安全性 泛型字母含义 E - Element：指集合中的元素 T - Type：Java类型，种类 K - Key：键 V - Value：值 N - Number：数值类型 格式 &lt;T,...&gt; //T是类型占位符，是一种引用类型 泛型方法泛型方法可以接收不同类型的参数，根据传进去的参数做适当的处理，格式如下 //&lt;T&gt; 声明此方法为泛型方法， T指出返回值是泛型T //Class&lt;T&gt; 指明泛型T的具体类型, c用来创建泛型T代表的类对象 public &lt;T&gt; T getObject(Class&lt;T&gt; c)&#123; //创建一个泛型对象 T t = c.newInstance(); return t; &#125; 例子，有三个不同类型的数组，分别打印出其中的值 package GenericsStudy; public class GenericDemo1 &#123; //泛型方法 public static &lt; E &gt; void printArray(E [] inputArray) &#123; //输出数组元素 for (E element : inputArray) &#123; System.out.printf(&quot;%s &quot;, element); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; //创建不同类型数组 Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;; Double[] doubleArray = &#123;1.1, 2.2, 3.3, 4.4&#125;; Character[] charArray = &#123;&#39;H&#39;, &#39;E&#39;, &#39;L&#39;,&#39;L&#39;,&#39;O&#39;&#125;; System.out.println(&quot;整型数组元素为：&quot;); //因为是写在本类里面，所以可以直接调用 //如果是测试类写在本类外面，需要通过类名来调用静态方法， printArray(intArray); System.out.println(&quot;\\n双精度型数组元素：&quot;); printArray(doubleArray); System.out.println(&quot;\\n字符串数组元素：&quot;); printArray(charArray); &#125; &#125; 案例2 编写一个add方法，传入不同类型的数字类型，并返回相加的值，相加的值是double类型 package GenericsStudy; public class GenericsDemo5 &#123; //extends是为了做泛型界定，即泛型T必须是Number的子类 public static &lt;T extends Number&gt; double add(T num1, T num2) &#123; double sum=0.0; sum = num1.doubleValue() + num2.doubleValue(); return sum; &#125; public static void main(String[] args) &#123; System.out.println(&quot;double 类型相加：5.5 + 6.7 =&quot;+add(5.5, 6.7)); System.out.println(&quot;int 类型相加：5 + 7 =&quot;+add(5, 7)); System.out.println(&quot;double 与 int 类型相加：5.5+6 =&quot;+add(5.5, 6)); &#125; &#125; 泛型类既然方法可以定义为泛型，类也可以定义成泛型 泛型类中可以包含泛型方法，多个类型参数 package GenericsStudy; public class GenericDemo3&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return this.t; &#125; public static void main(String[] args) &#123; GenericDemo3&lt;Integer&gt; one = new GenericDemo3&lt;Integer&gt;(); GenericDemo3&lt;String&gt; two = new GenericDemo3&lt;String&gt;(); one.add(1); two.add(&quot;Hello World&quot;); System.out.println(one.get()); System.out.println(two.get()); &#125; &#125; 上面提到了，泛型可以存储多个类型，下面我们来写一个简易字典，仅包含一对key和value package GenericsStudy; public class GenericDemo6 &#123; public static void main(String[] args) &#123; Dictionary&lt;String, Integer&gt; dic1 = new Dictionary&lt;String, Integer&gt;(); dic1.put(&quot;Peter&quot;,110); System.out.println(dic1.getKey()); System.out.println(dic1.getValue()); System.out.println(dic1.getAll()); &#125; &#125; class Dictionary&lt;K, V&gt;&#123; private K key; private V value; public void put(K key, V value) &#123; this.key = key; this.value = value; &#125; //获取key public K getKey() &#123; return key; &#125; //获取value public V getValue() &#123; return value; &#125; //获取key与value的字符串 public String getAll() &#123; return key.toString()+&quot;:&quot;+value.toString(); &#125; &#125; 泛型接口继承了泛型接口的类会变成泛型类 package GenericsStudy; public class GenericDemo7 &#123; public static void main(String[] args) &#123; ImpleData&lt;String&gt; Imple = new ImpleData&lt;String&gt;(); Imple.print(&quot;Hello World&quot;); &#125; &#125; //创建一个泛型接口 interface Data&lt;T&gt;&#123; T getData(T t1); &#125; //ImpleData实现了Data接口 class ImpleData&lt;T&gt; implements Data&lt;T&gt;&#123; @Override public T getData(T t1) &#123; return t1; &#125; public void print(T t1) &#123; System.out.println(&quot;Print: &quot;+this.getData(t1)); &#125; &#125; 通配符通配符是指这个 问号：？， List &lt;?&gt; seq = new ArrayList&lt;&gt;(); 表示该通配符所代表的类型是T类型的子类。 ? extends通常与List一起用，List是一种存储数据的容器和Array数组类似，在后面的章节有介绍 package GenericsStudy; import java.util.List; public class GenericDemo4 &#123; public static void main(String[] args) &#123; /*由于我们extends Number了，种类只能是Number类或Number的子类 如果使用String类型，会报错 */ List&lt;Number&gt; sequence = new ArrayList&lt;&gt;(); sequence.add(1); sequence.add(2); sequence.add(1.4); sequence.add(7.9f); getDate(sequence); &#125; public static void getDate(List&lt;? extends Number&gt; data) &#123; for(Object i : data) &#123; System.out.println(i); &#125; &#125; &#125; 表示该通配符所代表的类型是T类型的父类。 不能同时声明泛型通配符上界和下界 JAVA集合我们Java后端一般要进行数据处理，假设所有数据都是储存在数组里面，大小长度受限，不方便；所以我们在本章将引进集合的概念，集合是对象的容器，定义了对多个对象进行操作的常用方法，可实现数组的功能，但比数组更灵活。注意：数组可以存储基本类型，如int，但是集合只能存储引用类型，如String，所以在集合中存数字时，要将int类型转化为Integer类型 对于集合中的元素我们想要遍历有2种方法 增强for(for each循环) for(Object i :container1) &#123; System.out.println(i); &#125; 通过迭代器来遍历 //迭代器是通过集合内部的方法来获得的 Iterator&lt;Object&gt; itr = container1.iterator(); //itr.hasNext()是判断是否还有下一个元素，如果是，该循环开始执行 while(itr.hasNext()) &#123; //打印出下一个元素 System.out.println(itr.next()); &#125; Collection接口Collection接口是众多集合的父接口，List接口，Set接口都是继承Collection接口，然后通过实现类实现其中的方法。由于Collection,Set, List都是接口，创建时必须要用实现类；比如List的实现类ArrayList,Set的实现类HashSet. //引入集合模块 import java.util.Collection //创建集合，由于Collection是接口，我们用Collection的实现类ArrayList来实现 //Collection集合是泛型集合，&lt; &gt;中我们要添加存储的数据类型， Object类是所有类的父类 Collection&lt;Object&gt; container1 = new ArrayList&lt;&gt;(); 由于集合是无法储存基本类型的，当我们存入基本类型时，集合会自动装箱 list.add(20); 实际上是list.add(new Integer(20)); 如果有一些方法解释不全，可以参考以下API链接 API: https://www.runoob.com/manual/jdk1.6/ 常用方法 作用 例子 boolean add(E e) 添加元素,添加成功返回true container1.add(“apple”); void clear() 移除collection中的所有元素 container1.clear(); int size() 返回集合中元素的个数 int size = container1.size(); boolean contains(Object o) 如果此 collection 包含指定的元素，则返回 true container1.contains(“apple”); Iterator iterator() 返回collection的所有元素的迭代器 Iterator itr = container1.iterator(); boolean isEmpty() 判断此集合是否为空 container1.isEmpty(); boolean remove(Object o) 移除集合中的某对象 container1.remove(1); Object[] toArray 将此集合转为数组 Object[ ] arrray = container1.toArray(); 例子1 package CollectionStudy; import java.util.ArrayList;//引入ArrayList import java.util.Collection;//引入Collection import java.util.Iterator; //引入迭代器 public class CollectionDemo1 &#123; public static void main(String[] args) &#123; //使用多态 Collection&lt;Object&gt; container1 = new ArrayList&lt;&gt;(); //添加元素 container1.add(&quot;apple&quot;); container1.add(1); //增强for遍历元素 System.out.println(&quot;----增强For----&quot;); for(Object i :container1) &#123; System.out.println(i); &#125; //迭代器遍历元素 System.out.println(&quot;----Iterator----&quot;); Iterator&lt;Object&gt; itr = container1.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125; &#125; 例子2 Collection集合可以存储其他引用数据类型，我们创建一个学生类，并将学生类添加进ArrayList集合（Collection的实现类） package CollectionStudy; //Students类 public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; //重写toString方法，按照我们的规定返回字符串 @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; &#125; //测试类 package CollectionStudy; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class CollectionDemo2 &#123; public static void main(String[] args) &#123; Students Tom = new Students(18, &quot;Tom&quot;); Students Jimmy = new Students(22, &quot;Jimmy&quot;); //先实例化2个students对象 Collection&lt;Students&gt; container = new ArrayList&lt;Students&gt;(); container.add(Tom); container.add(Jimmy); //遍历 1 for(Object student : container) &#123; System.out.println(student); &#125; System.out.println(&quot;\\t----Line-----&quot;); //遍历 2 Iterator&lt;Students&gt; itr = container.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125; &#125; 结果 我们想用集合的contains方法，来判断是否包含某引用元素 Students Jimmy = new Students(22, &quot;Jimmy&quot;); Collection&lt;Students&gt; container = new ArrayList&lt;Students&gt;(); container.add(Jimmy); System.out.println(container.contains(Jimmy)); 结果是：true 假设我们传进去的不是Jimmy,而是: new Students(22, “Jimmy”) 结果是：false 为了避免这个问题，我们需要重写students类中的equals方法 //在Students类中重写此方法 @Override public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if(obj == null) &#123; return false; &#125; if(obj instanceof Students) &#123; Students students = (Students) obj; if(this.name.equals(students.name)&amp;&amp;this.age == students.age) &#123; return true; &#125; &#125; return false; &#125; 再次调用测试类 结果为：true List接口List是有序(添加顺序与遍历顺序一致)，有下标，元素可重复的集合 List的独有方法 如果有一些方法解释不全，可以参考以下API链接 API: https://www.runoob.com/manual/jdk1.6/ 方法 解释 例子 void add(int index, Object o) 在index位置插入对象o conatiner2.add(0, “Hello”); boolean addAll(int index, Collection c) 将一个集合元素增添到index位置 container2.addAll(0,container1); Object get(int index) 返回集合中指定位置的元素 container2.get(0); List subList(int fromIndex, int toIndex) 返回fromIndex与toIndex之间的元素 container2.subList(0, 5); ArrayListArrayList是由数组结构实现的，查询快，增删慢 增添包：import java.util.ArrayList; 构造方法：ArrayList container = new ArrayList&lt;&gt;();E为泛型即ArrayList可以增添任何类 常用方法 解释 public boolean add(E e); 添加元素 public E get(int index) 按照索引获取元素，从0开始 public E set(int index, E element) 可以替换指定元素 public boolean remove(Object 0) 根据内容删除元素 public E remove(int index) 根据index删除元素，返回删除元素 例子 我们要创建一个Students类，将几个students对象存入ArrayList类中 package CollectionStudy; public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; &#125; package CollectionStudy; import java.util.ArrayList; import java.util.Arrays; public class ArrayListCollection &#123; public static void main(String[] args) &#123; ArrayList&lt;Students&gt; container = new ArrayList&lt;&gt;(); Students Jim = new Students(18, &quot;Jim&quot;); Students Tom = new Students(20, &quot;Tom&quot;); //成功add元素后，返回是否成功 System.out.println(&quot;是否增添了Jim：&quot;+container.add(Jim)); container.add(Tom); System.out.println(&quot;获取第一个元素：&quot;+container.get(0)); //把第2个元素设置为Alex container.set(1, new Students(78, &quot;Alex&quot;)); System.out.println(&quot;第2个元素是：&quot;+container.get(1)); //container包含的元素个数 System.out.println(&quot;元素个数：&quot;+container.size()); //将ArrayList转化为数组 Object[] array = container.toArray(); System.out.println(&quot;将ArrayList转化为数组：&quot;+Arrays.toString(array)); //删除元素,删除Jim的信息 System.out.println(&quot;删除： &quot;+container.remove(Jim)); System.out.println(&quot;删除后个数:&quot;+container.size()); &#125; &#125; 结果 假如我们增添，删除时用的不是Jim, 而是new Students(18, “Jim”); ? package CollectionStudy; import java.util.ArrayList; import java.util.Arrays; public class ArrayListCollection &#123; public static void main(String[] args) &#123; ArrayList&lt;Students&gt; container = new ArrayList&lt;&gt;(); Students Jim = new Students(18, &quot;Jim&quot;); // Students Tom = new Students(20, &quot;Tom&quot;); System.out.println(&quot;是否增添了Jim：&quot;+container.add(Jim)); container.add(new Students(20, &quot;Tom&quot;)); System.out.println(&quot;获取第一个元素：&quot;+container.get(0)); //把第2个元素设置为Alex container.set(1, new Students(78, &quot;Alex&quot;)); System.out.println(&quot;第2个元素是：&quot;+container.get(1)); //container包含的元素个数 System.out.println(&quot;元素个数：&quot;+container.size()); //将ArrayList转化为数组 Object[] array = container.toArray(); System.out.println(&quot;将ArrayList转化为数组：&quot;+Arrays.toString(array)); //删除元素,注意，此时我们new Students(18,&quot;Jim&quot;); System.out.println(&quot;删除： &quot;+container.remove(new Students(18, &quot;Jim&quot;))); System.out.println(&quot;删除后个数:&quot;+container.size()); &#125; &#125; 结果 即使我们删除new Students(18,”Jim”);（内容相同），但是还是无法完全删除，删除返回为false 所以此时我们需要重写Students里面的equals方法（ArrayList判断remove时调用的方法） @Override public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if(obj == null) &#123; return false; &#125; if(obj instanceof Students) &#123; Students students = (Students) obj; if(this.name.equals(students.name)&amp;&amp;this.age == students.age) &#123; return true; &#125; &#125; return false; &#125; 结果，成功删除 LinkedListLink意思为链，链表集合就像所以数据被链子连接在一起一样 特点：链表结构实现，增删快，查询慢 使用方法与ArrayList类似 例子 继续用LinkedList存储Students类的信息 同样，我们先不重写equals方法 package CollectionStudy; public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; &#125; package CollectionStudy; import java.util.LinkedList; public class LinkedListDemo1 &#123; public static void main(String[] args) &#123; LinkedList&lt;Students&gt; container = new LinkedList&lt;&gt;(); System.out.println(&quot;增添Tom: &quot;+container.add(new Students(20, &quot;Tom&quot;))); container.add(new Students(18, &quot;Jim&quot;)); //pop从container中弹出元素 System.out.println(&quot;Pop第一个元素：&quot;+container.pop()); container.add(new Students(18, &quot;Jim&quot;)); container.add(new Students(72,&quot;Trump&quot;)); System.out.println(&quot;删除元素Jim：&quot;+container.remove(new Students(18, &quot;Jim&quot;))); //遍历 for(Object i :container) &#123; System.out.println(i); &#125; &#125; &#125; 结果Jim无法被删除，同时我们还发现List可以存储相同的元素 此时，我们再重写Students的equals方法 @Override public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if(obj == null) &#123; return false; &#125; if(obj instanceof Students) &#123; Students students = (Students) obj; if(this.name.equals(students.name)&amp;&amp;this.age == students.age) &#123; return true; &#125; &#125; return false; &#125; 结果，成功删除 Set接口上文我们介绍了List接口与其的实现类，现在我们开始讲Set接口 Set是无序(添加顺序与遍历顺序不一致)，无下标，元素不可重复的集合 但是使用new可以插入内容相同的元素，因为Set判断的依据是equals方法，如果equals方法未重写则根据地址判断. 例子引入 package setStudy; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class SetIntroduction &#123; public static void main(String[] args) &#123; //我们使用Set集合的实现类HashSet来创建集合 Set&lt;Object&gt; container = new HashSet&lt;&gt;(); container.add(&quot;Hello&quot;); container.add(&quot;World&quot;); container.add(&quot;Hello&quot;); container.add(&quot;My Friend&quot;); Iterator&lt;Object&gt; itr = container.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125; &#125; 这里由于是字符串，系统内部有equals方法，所以第二个”Hello”无法加入Set集合 HashSetHashSet是Set集合的一个实现类 存储结构：哈希表(数组+链表+红黑树) 存储过程 （1）根据hashcode计算保存的位置，如果此位置为空，则直接保存，如果不为空，则执行第二步 （2） 再执行equals方法，如果equals方法为true，则认为重复，否则形成链表，即添加到HashSet容器中 因为HashSet是以equal与hashcode进行比较，所以要重写hashcode与equals,这样就可以排除new的干扰。 构造方法 //E为任意种类的数据 HashSet&lt;E&gt; container = new HashSet&lt;&gt;(); 基本操作与List / Set / Collection类似 增添元素：add(E e); 删除元素：remove(E e); 也有迭代器：Iterator iterator(); package setStudy; import java.util.HashSet; public class HashSetStudy &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; container = new HashSet&lt;&gt;(); container.add(&quot;tim&quot;); container.add(&quot;Ketty&quot;); container.add(&quot;Yellow&quot;); System.out.println(&quot;HashSet中的内容：&quot;+container.toString()); System.out.println(&quot;HashSet的大小：&quot;+container.size()); System.out.println(&quot;此HashSet中是否含有Ketty数据：&quot;+container.contains(&quot;Ketty&quot;)); &#125; &#125; 案例2 像ArrayList一样，我们创建Students类，增添Students元素 package setStudy; public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; &#125; package setStudy; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class HashSetDemo2 &#123; public static void main(String[] args) &#123; HashSet&lt;Object&gt; container = new HashSet&lt;&gt;(); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Jim&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(19, &quot;Jone&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Alex&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Jim&quot;))); Iterator&lt;Object&gt; itr = container.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125; &#125; 结果 当我们增添内容相同的元素new Students(18, “Jim”)时，系统先判断是否是同一地址，如果没有看是否重写了equals和hashcode方法。因为判断地址不一样又没重写equals方法（照系统默认的equals方法），所以添加成功 现在我们重写Students类的equals和hashcode方法 @Override public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if(obj == null) &#123; return false; &#125; if(obj instanceof Students) &#123; Students students = (Students) obj; if(this.name.equals(students.name)&amp;&amp;this.age == students.age) &#123; return true; &#125; &#125; return false; &#125; @Override public int hashCode() &#123; //第一种转换string的方法 // String age = String.valueOf(this.age); //第二种 // String age = this.age+&quot;&quot;; String age = Integer.toString(this.age); return age.hashCode()*this.name.hashCode(); &#125; 结果，相同内容的数据添加失败 TreeSet实现Set接口的还有一个类，TreeSet，基于排列顺序实现元素不重复 此实现为基本操作（add、remove 和 contains） 实现了SortedSet接口，对集合元素自动排序 传入TreeSet的元素对象类型必须实现Comparable接口（指定排序规则） 因为TreeSet是通过ComparaTo方法确认是否为重复元素，所以可以通过内部类来override比较方法 使用TreeSet时，最好不要用Object类 package setStudy; import java.util.TreeSet; public class TreeSetStudy &#123; public static void main(String[] args) &#123; TreeSet&lt;String&gt; container = new TreeSet&lt;&gt;(); container.add(&quot;Hello&quot;); container.add(&quot;xyz&quot;); container.add(&quot;world&quot;); container.add(&quot;hello&quot;); container.add(&quot;99&quot;); System.out.println(container.toString()); &#125; &#125; String类型，(0,1,2..)默认数字在前–&gt;大写–&gt;小写（a,b,c…z） 案例2 还是Students的案例 package setStudy; public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; &#125; package setStudy; import java.util.Iterator; import java.util.TreeSet; public class TreeSetStudy &#123; public static void main(String[] args) &#123; TreeSet&lt;Students&gt; container = new TreeSet&lt;&gt;(); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Jim&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(19, &quot;Jone&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Alex&quot;))); System.out.println(&quot;添加成功：&quot;+container.add(new Students(18, &quot;Jim&quot;))); //遍历 Iterator&lt;Students&gt; itr = container.iterator(); while(itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125; &#125; 由于我们再Students类中没有重写CompareTo方法，报错 继承Comparable接口重写CompareTo方法 package setStudy; public class Students implements Comparable&lt;Object&gt;&#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; @Override public int compareTo(Object obj) &#123; Students stu = (Students) obj; return (stu.name.hashCode() - this.name.hashCode()); &#125; &#125; 此时TreeSet根据我们重写的compareTo方法来判断Object是否重复，我们的判断依据是students的名字的hashcode。 结果 Map接口Map是一种将Key与value（键对象与值对象）相互映射的集合 Key Value 1 Biden 2 Trump 有时能用Map就不要用List，查找信息Map使用效率有时比List要高 //通过HashMap这个实现类来创建一个Map对象 //Students是传入Key的类型， String是value的类型 Map&lt;Students, String&gt; container = new HashMap&lt;&gt;(); 常用方法 解释 V put(K key, V value) 放入键值对 Object get(Object Key) 通过key来获取值value Set KeySet() 返回所有的Key的Set集合 Collection values() 返回包含所有值的collection集合 boolean containsKey(Object key) 如果此映射包含对于指定键的映射关系，则返回 true boolean containsValue(Object Value) 如果此映射将一个或多个键映射到指定值，则返回 true V remove(Object key) 如果存在，根据key移除此键值对 如果有一些方法解释不全，可以参考以下API链接 API: https://www.runoob.com/manual/jdk1.6/ 实现Map接口的类有HashMap, TreeMap等 Map遍历 KeySet() Map &lt;String, String&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; key = map.KeySet(); //是所有的Key的集合. 随后可以使用增强for 或迭代器去遍历 System.out.println(&quot;\\tKeySet&quot;); for( Students i : container.keySet() ) &#123; System.out.println(i.getName()+&quot;----&quot;+container.get(i)); &#125; EntrySet() EntrySet()的效率要略高于KeySet() for(Entry&lt;Students, String&gt; i :container.entrySet()) &#123; System.out.println(i.getKey().getName()+&quot;----&quot;+i.getValue()); &#125; HashMapHashMap和HashSet类似，也是存储数据的集合；HashSet是存储值数据，而HashMap是存储键值对数据 在HashMap中Key的数据是根据hashcode来存的 HashMap是无序的,即我们插入和取出的顺序是不一样的 Students案例 由于是根据hashcode来存储key，我们需要重写students中的hashcode和equals方法 package Map_Key_Value; public class Students &#123; private int age; private String name; public Students(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;Student [ name: &quot;+this.getName()+&quot;, age: &quot;+this.getAge()+&quot; ]&quot;; &#125; @Override public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if(obj == null) &#123; return false; &#125; if(obj instanceof Students) &#123; Students students = (Students) obj; if(this.name.equals(students.name)&amp;&amp;this.age == students.age) &#123; return true; &#125; &#125; return false; &#125; @Override public int hashCode() &#123; // TODO Auto-generated method stub //第一种转换string的方法 // String age = String.valueOf(this.age); //第二种 // String age = this.age+&quot;&quot;; String age = Integer.toString(this.age); return age.hashCode()*this.name.hashCode(); &#125; &#125; package Map_Key_Value; import java.util.HashMap; import java.util.Map.Entry; public class OriginalMap &#123; public static void main(String[] args) &#123; HashMap&lt;Students, String&gt; container = new HashMap&lt;&gt;(); // Students Jim = new Students(18, &quot;Jim&quot;); // container.put(Jim, &quot;CSSE120&quot;); container.put(new Students(18, &quot;Jim&quot;), &quot;CSSE120&quot;); container.put(new Students(20, &quot;John&quot;), &quot;CSSE220&quot;); container.put(new Students(17, &quot;Alex&quot;), &quot;MA112&quot;); container.put(new Students(20, &quot;Eric&quot;), &quot;ESL102&quot;); System.out.print(&quot;获取 Students(18, \\&quot;Jim\\&quot;) 的值：&quot;); System.out.println(container.get(new Students(18, &quot;Jim&quot;)));//get value //遍历 //使用KeySet方法 System.out.println(&quot;\\tKeySet遍历&quot;); for(Students i:container.keySet()) &#123; System.out.println(i.getName()+&quot;----&quot;+container.get(i)); &#125; //使用EntrySet方法 System.out.println(&quot;\\tEntrySet遍历&quot;); // Set&lt;Map.Entry&lt;Students, String&gt;&gt; entrys = container.entrySet(); for(Entry&lt;Students, String&gt; i : container.entrySet()) &#123; System.out.println(i.getKey().getName()+&quot;----&quot;+i.getValue()); &#125; &#125; &#125; TreeMapTreeMap存储数据根据compareTo方法，对于自定义对象需要override比较方法，这个与TreeSet类似 下面就不多解释了，不懂可以查看API API： https://www.runoob.com/manual/jdk1.6/ JAVA常用类java中还有一些常用的工具类，这些类都是日常开发时可能会用到的 Arrays类Arrays是数组的意思，Arrays是为数组所开发的工具类(方法是静态static方法) arrays能处理的类型有int, double, long, char等 常用方法 解释 static boolean equals(int[ ] a, int[ ] a2) 如果两个int类型数组相等，则返回true static int hashCode(int[ ] a) 返回指定数组的哈希值 static void sort(double[ ] a) 对指定数组进行升序排序 static String toString(char[ ] a) 将数组内容转化为字符串 static void sort(T[ ] a, Comparator&lt;? super T&gt; c ) 根据指定比较器的顺序对指定对象数组进行排序 Date和Calendar类Data和Calendar是java中表示时间的两个类，它们能返回当前的时间的毫秒值 毫秒值表示自 1970 年 1 月 1 日 00:00:00 GMT 以来经过的毫秒数。 Date构造方法 //以当前时间来初始化对象 Date date = new Date(); //构造函数接收一个参数，这个参数是从1970年起的毫秒数 Date date = new Date(long millisec) 常用方法 解释 String toString() 格式化日期转义形式yyyy-mm-dd的日期 int getHours() 获取此刻的小时 String toLocaleString() 返回当前本地格式的时间（方法已过时） package DateAndCalendar; import java.util.Date; public class DateDemo1 &#123; public static void main(String[] args) &#123; Date date = new Date(); System.out.println(date.toString()); System.out.println(date.toLocaleString()); &#125; &#125; 我们可以使用SimpleDateFormat将日期输出格式化 格式 含义 例子 yyyy 年 2020 MM 月 1 dd 日 22 HH 24小时制 13 hh 12小时制 1 ss 秒 07 S 毫秒 7000 E 星期几 Monday D 一年中的第几天 365 F 一个月中的第几周的周几 2 w 一年中的第几周 7 W 一个月中的第几周 2 a AM / PM PM z 时区 CST package DateAndCalendar; import java.text.SimpleDateFormat; import java.util.Date; public class DateDemo1 &#123; public static void main(String[] args) &#123; Date date = new Date(); // System.out.println(date.toString()); // System.out.println(date.toLocaleString()); SimpleDateFormat Df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(Df.format(date)); &#125; &#125; 我们还能用时间来做一个定时器 package DajavateAndCalendar; //在10s之内，持续打印hello， 结束时打印world public class DateDemo1 &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); while(true) &#123; long end = System.currentTimeMillis(); if((end-start)&gt;10000) &#123; System.out.println(&quot;world&quot;); break; &#125; System.out.println(&quot;hello&quot;); &#125; &#125; &#125; Calendar通过Calendar我们可以获取时间中特定的数据 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。 由于Calendar是protected类型，只能通过其他方法进行构建 static Calendar getInstance() //使用默认时区获取日历 Calendar date = Calendar.getInstance(); 在Calendar中，系统定义了一些常量 Calendar.YEAR 年 Calendar.MONTH 月 Calendar.DATE 日期 Calendar.HOUR 小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 常用方法 int get(int field) calendar.get(Calendar.YEAR)//可用于获取calendar特定的年-月-日 abstract void add(int field, int amount) //根据日历给特定的字段增减时间量 void set(int year, int month, int day, int hourOfDay, int minute, int second)//设置特定值 例子 package DateAndCalendar; import java.util.Calendar; import java.util.Date; public class CalendarDemo1 &#123; public static void main(String[] args) &#123; Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime()); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH)+1; int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(&quot;Today is &quot;+year+&quot;-&quot;+month+&quot;-&quot;+day); &#125; &#125; JAVA异常处理在写程序时我们可能会遇到程序报错的情况，此时编译器会出现红色的提示，如下 这就是异常Exception 所有的异常都是从java.lang.Exception中继承的，Exception类是Throwable类的子类，Throwable还有一个子类Error 常见异常 用户输入了非法数据 要打开的文件不存在 网络连接通信时中断，或者JVM内存溢出 三大类异常 1. 检查性异常(checked exception) 如用户输入异常或者打开一个不存在的文件（这些异常在编译时不能被简单地忽略） 2. 运行时异常 运行时可能被程序员避免的异常 3. 错误 错误不是异常，通常是摆脱程序员控制的问题，例如当内存溢出时，会报错误 检查性异常 InterruptedException一个线程被另一个线程中断，抛出该异常。 NoSuchFieldException请求的变量不存在 非检查性异常 1. ArithmeticException 2. NumberFormatException 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 3. NullPointerException 4. IndexOutOfBoundsException 遍历超过 5. UnsupportedOperationException 捕获异常//捕获异常的基础语法 try&#123; &#125;catch(IOException e1)&#123; //如何处理该异常，异常e1的类型可以为Exception的子类或Exception； &#125;catch(ArithmeticException e2)&#123; &#125;finally&#123; //finally可加可不加 //如果加了，无论是否发生异常，finally 代码块中的代码总会被执行。 //一般这里用于释放内存，如input.close() &#125; 例子 我们要用户输入两个数并互除，在除法中，被除数不能为0，所以我们要捕获这个异常 package Exception; import java.util.Scanner; public class ExceptionStudyDemo1 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;Num1: &quot;); int num = input.nextInt(); System.out.print(&quot;Num2: &quot;); int num2 = input.nextInt(); //注意此时num/num2得出的数字是整数 System.out.println(&quot;Num1 / Num2 = &quot;+num/num2); &#125; catch(ArithmeticException a) &#123; System.out.println(a.getMessage()); //获取为什么错误 &#125; finally &#123; input.close(); &#125; &#125; 解决方法 添加一个 double rst = num*1.0/num2;java package Exception; import java.util.Scanner; public class ExceptionStudyDemo1 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;Num1: &quot;); int num = input.nextInt(); System.out.print(&quot;Num2: &quot;); int num2 = input.nextInt(); double rst = num*1.0/num2; System.out.println(&quot;Num1 / Num2 = &quot;+rst); &#125; catch(ArithmeticException a) &#123; System.out.println(a.getMessage()); &#125; finally &#123; input.close(); &#125; &#125; &#125; Throws 关键字throws中文意思是抛出，当一个函数有一个异常，此时我们不想处理时，我们可以throws这个Exception，交给函数外的部分处理 还是刚才num / num2的例子 package Exception; import java.util.Scanner; public class ExceptionStudyDemo1 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;Num1: &quot;); int num = input.nextInt(); System.out.print(&quot;Num2: &quot;); int num2 = input.nextInt(); divide(num, num2); &#125; catch(ArithmeticException a) &#123; System.out.println(a.getMessage()); &#125; finally &#123; input.close(); &#125; &#125; public static void divide(int num, int num2) throws ArithmeticException&#123; System.out.println(&quot;Num1 / Num2 = &quot;+num/num2); &#125; &#125; 自定义异常类所有异常必须是Throwable的子类。如果希望写一个检查性异常，则需要继承Exception类；如果是运行时异常，则继承RuntimeException类继承语法 class CustomException extends Exception&#123; //里面根据编译器自动生成 &#125; package Exception; import java.util.Scanner; public class ExceptionStudyDemo1 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); try &#123; System.out.print(&quot;Num1: &quot;); int num = input.nextInt(); System.out.print(&quot;Num2: &quot;); int num2 = input.nextInt(); divide(num, num2); &#125; catch(CustomException a)&#123; //捕获自定义异常 &#125; public static void divide(int num, int num2) throws CustomException&#123; //在方法中抛出异常 if(num2 == 0) &#123; throw new CustomException(); //在方法中加入此语句，即为判断那种情况下抛出自定义异常 &#125; &#125; &#125; 自定义异常有什么用呢？ 当我们自己开发时，有时需要自己定义一些异常（别人能看懂的异常类名字），这样可以方便开发 JAVA IO处理我们每次运行一个程序，此时我们输入的数据仅仅是存在缓存中的，倘若我们关掉程序，数据就会随之消失。为了把数据存起来，我们需要学习IO处理（Input Output），这样数据才可以写入内存硬盘里面。 流的概念流stream可以为数据与目的之间建立通道。通过流我们可以把在内存中的信息写入到硬盘中；同理，我们也可以将硬盘中的数据读取，print在控制台里面通过流读取的不管是字节还是字符，一般返回的都是int值 流的分类流有很多种类，按照处理数据侧重点的不同可以分为输入/输出字节流与输入/输出字符流; 这里我引用某位博主的图片来解释：https://blog.csdn.net/mu_wind/article/details/108674284 字节流字节流每次读取或写入一个字节，2字符=1字节， 1字节(Byte) = 8位 (bit)。字节流可以处理图像，视频等 一般英文字母一个字母为一个字节（字节是以int类型表示而字母则是以char类型表示） 字符流字符流每次读取或写入一个字符。字符流只能用于处理文字信息 中文与英文有点区别，1个中文代表1个字符(char)，1个字符 = 2个字节， 加入用字节流读取中文字符会出现乱码 流的使用字节流使用输入字节流 //实例化对象 FileInputStream file = new FileInputStream(&quot;E:\\\\java程序\\\\ReadFile.txt&quot;); //读取文件内容 //读取出来的是字节流信息，要转化成char或string才能打印 //file.read()一次读取一个字节，如果有返回此字节，若没有返回-1 int data; while((data = file.read()) != -1) &#123; System.out.print((char)data); &#125; //使用自制缓冲区读取数据 byte[] buffer = new byte[3];//自制的一次能储存3个字节的缓冲区 int count=0; while((count = file.read(buffer))!=-1) &#123; System.out.print(new String(buffer,0,count)); &#125; //注意打开的文件使用后要关闭 file.close(); 输出字节流 //实例化对象 //true表示如果给出的文件地址已存在，则在此文件的基础上再写如内容 FileOutputStream Out = new FileOutputStream(&quot;E:\\\\java程序\\\\OutPutFile.txt&quot;,true); //写入内容 String words = &quot;HELLO WORLD &quot;; Out.write(words.getBytes()); //通过字节流来写入，必须是字节形式 //同样，写完记得关闭 Out.close(); 由于普通的输入输出字节流效率不高，一般需要与缓冲流相互配合 文件内容先读入缓冲区，接着被程序访问，这样可以减少程序访问硬盘的次数 缓冲输入输出流 //使用缓冲区读取数据 FileInputStream file = new FileInputStream(&quot;E:\\\\java程序\\\\ReadFile.txt&quot;); BufferedInputStream buf = new BufferedInputStream(file); int data; while((data = buf.read()) != -1) &#123; System.out.print((char)data); &#125; //缓冲区用完也最好记得关闭 buf.close(); //使用缓冲区输出数据 package IOStudy; import java.io.BufferedOutputStream; import java.io.FileOutputStream; public class buf &#123; public static void main(String[] args) throws Exception &#123; System.out.println(&quot;hello world&quot;); FileOutputStream file = new FileOutputStream(&quot;E:\\\\java程序\\\\BufferOutput.txt&quot;,true); BufferedOutputStream buf = new BufferedOutputStream(file); for(int i=0;i&lt;4;i++) &#123; buf.write(&quot;hello world &quot;.getBytes()); buf.flush(); //使用缓冲区每写入一次数据要刷新一遍 &#125; System.out.println(&quot;Finish&quot;); buf.close(); &#125; &#125; 对象流与序列化字节流可以传输任何数据类型，包括对象，由此产生了另一个流，对象流 创建方法 ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(source, true)); ObjectInputStream 读取Obj数据顺序根据写入顺序来，先进先出 在使用对象流写入对象数据时，该对象必须实现Serializable接口之前接口部分有提到Serializable没有任何方法和常量，它是一个标记类 下面我们要将两个学生类的信息储存到硬盘中，再通过一个程序将内容读取出来 //学生类，要实现Serializable接口 package IOStudy; import java.io.Serializable; public class Student implements Serializable&#123; /** * */ private static final long serialVersionUID = -4870784691100550826L; private String name; private int age; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;[&quot;+this.getName()+&quot; , &quot;+this.getAge()+&quot;]&quot;; &#125; &#125; //写入信息 package IOStudy; import java.io.FileOutputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; public class ObjectWrite &#123; public static void main(String[] args) throws Exception&#123; String source = &quot;E:\\\\java程序\\\\ObjWriter.bin&quot;; ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(source)); Student Biden = new Student(&quot;Biden&quot;, 78); Student Trump = new Student(&quot;Trump&quot;, 72); obj.writeObject(Trump); obj.writeObject(Biden); obj.writeObject(null); obj.close(); System.out.println(&quot;Finish&quot;); &#125; &#125; //读取信息 package IOStudy; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.util.ArrayList; public class ObjectRead &#123; public static void main(String[] args) throws Exception&#123; String source =&quot;E:\\\\java程序\\\\ObjWriter.bin&quot;; ObjectInputStream obj = new ObjectInputStream(new FileInputStream(source)); Object stu; while((stu=obj.readObject())!= null) &#123; System.out.println(stu); &#125; obj.close(); &#125; &#125; 字符流使用字符流输入输出 //实例化对象 FileReader read = new FileReader(Source); //读取操作与字节流类似 //案例（反例），我们使用默认的解码格式读取数据 package IOStudy; import java.io.FileInputStream; import java.io.FileReader; import java.io.InputStreamReader; public class ReadFile2 &#123; public static void main(String[] args) throws Exception&#123; String Source = &quot;E:\\\\java程序\\\\字符Reader.txt&quot;; FileReader read = new FileReader(Source); int count =0; while((count = read.read())!= -1) &#123; System.out.print((char)count); &#125; read.close(); &#125; &#125; 结果，中文出现乱码 由于英文一个字母只占一个字节，默认的GBK解码没有问题。但是中文一个字占3个字节，使用GBK解码（与文本保存的格式不同）出现了乱码。 为了保证能正确解码，我们读取字符文件时要指定解码格式，例如UTF-8 //下面是对上面例子的修改 package IOStudy; import java.io.FileInputStream; import java.io.FileReader; import java.io.InputStreamReader; public class ReadFile2 &#123; public static void main(String[] args) throws Exception&#123; String Source = &quot;E:\\\\java程序\\\\字符Reader.txt&quot;; InputStreamReader read = new InputStreamReader(new FileInputStream(Source),&quot;UTF-8&quot;); int count =0; while((count = read.read())!= -1) &#123; System.out.print((char)count); &#125; &#125; &#125; 结果 中文字符流写出时，不用担心上面编码的问题，系统默认是GBK编码，例子如下 package IOStudy; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.OutputStreamWriter; public class WriteFile2 &#123; public static void main(String[] args) throws Exception&#123; String Source = &quot;E:\\\\java程序\\\\字符Writer.txt&quot;; FileWriter file = new FileWriter(Source); file.write(&quot; 世界你好 &quot;); System.out.println(&quot;Finish&quot;); file.close(); &#125; &#125; 写入的结果 ANSI就是GBK编码格式 当然，我们也可以指定输出格式，像输入一样 package IOStudy; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.OutputStreamWriter; public class WriteFile2 &#123; public static void main(String[] args) throws Exception&#123; String Source = &quot;E:\\\\java程序\\\\字符Writer.txt&quot;; OutputStreamWriter file = new OutputStreamWriter(new FileOutputStream(Source,true), &quot;UTF-8&quot;); // FileWriter file = new FileWriter(Source); file.write(&quot; 世界你好 &quot;); System.out.println(&quot;Finish&quot;); file.close(); &#125; &#125; 结果：文件使用UTF-8编码格式 字符流读取缓冲流package IOStudy; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStreamReader; public class BufferCharRead &#123; public static void main(String[] args) throws Exception&#123; String source = &quot;E:\\\\编程.txt&quot;; BufferedReader buf = new BufferedReader(new InputStreamReader(new FileInputStream(source), &quot;GBK&quot;)); for(int i=0;i&lt;20;i++)//打印缓冲区中的前20行 //buf.readLine()指读一行数据 System.out.println(buf.readLine()); buf.close(); &#125; &#125; 文件夹操作java的IO处理还包括文件夹的一些操作，例如文件夹的创建，删除等 //构造方法 //--1-- File file = new File(String parent_path, String child_path); //--2-- File file = new File(String absolute_path) 目录操作 解释 createNewFile() 创建一个新文件，不是文件夹 mkdir() 创建一个新目录 delete() 删除文件或空目录 exists() 判断File对象所表示的对象是否存在 getAbsolutePath() 获取文件的绝对路径 getName() 获取目录的名字 getParent() 获取文件/目录所在的目录,该文件夹所在绝对路径E:\\java程序\\PicSource\\Summer_PocketParent就是E:\\java程序\\PicSource Child就是Summer_Pocket isDirectory() 判断是否是目录 isFile() 判断是否是文件 length() 获取文件的长度,以字节为单位 renameTo() 修改文件名为 listFiles() 列出目录中的所有内容 File[] files = file.listFiles(); 返回的是File类型数组 File[] file2 = file.listFiles(FileFilter filter);//可以通过Filefilter进行过滤文件的目的 FileFilter接口 public interface FileFilter //需要实现的方法 boolean accept(File pathname) 案例 存了一些图片在某个文件夹中，我们要将这些图片重命名，按1-50的顺序重命名 package IOStudy; import java.io.File; import java.io.FileFilter; import java.util.Scanner; public class FileOperator &#123; public static void main(String[] args) throws Exception &#123; File file = new File(&quot;E:\\\\java程序\\\\PicSource&quot;); System.out.println(&quot;dictory&#39;s name: &quot;+file.getName()); File[] files = file.listFiles(); Integer count =0; for(File pic:files) &#123; File image = new File(file.getAbsolutePath(),count.toString()+&quot;.jpg&quot;); if(pic.isFile()) &#123; pic.renameTo(image); count++; &#125; &#125; File[] file2 = file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; if(pathname.getName().endsWith(&quot;.jpg&quot;)) return true; return false; &#125; &#125;); for(File pic:file2) &#123; System.out.println(pic.getName()); &#125; &#125; &#125; 结果 Propertiesproperties是一个属性集合，继承HashTable,是一个线程安全的集合；properties可以储存键值对，同时键值对是字符串类型，它没有泛型。 //构造方法 Properties container = new Properties(); //常用方法 container.setProperty(&quot;Trump&quot;,&quot;72&quot;); //使用迭代器遍历properties中的键值对 Iterator&lt;Entry&lt;Object, Object&gt;&gt; itr = container.entrySet().iterator(); while(itr.hasNext()) &#123; Entry&lt;Object, Object&gt; set = itr.next(); System.out.println(set.getKey()+&quot;=====&gt;&quot;+set.getValue()); &#125; //使用Set遍历键值对 Set&lt;String&gt; set = container.stringPropertyNames(); for(String pro:set) &#123; System.out.println(pro+&quot;=====&gt;&quot;+container.getProperty(pro)); &#125; //load加载存储在硬盘中property的内容 container.load(FileInputStream fis); //以适合的方法将键值对写入到输出流，可以保存注释 container.store(FileOutputStream fos, String comment); //-----// //store方法，以适合的方法将键值对写入到输出流，可以保存注释 FileOutputStream fos = new FileOutputStream(&quot;E:\\\\java程序\\\\properties_save.txt&quot;); container.store(fos, &quot;American President&quot;); fos.close(); //----// //将属性列表输出到指定的输出流 container.list(PrintWriter file); 举一个储存properties的例子 package IOStudy; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.util.Iterator; import java.util.Map.Entry; import java.util.Properties; import java.util.Set; public class PropertyStudy &#123; public static void main(String[] args) throws Exception &#123; Properties container = new Properties(); container.setProperty(&quot;Trump&quot;, &quot;72&quot;); container.setProperty(&quot;Biden&quot;, &quot;74&quot;); System.out.println(container.getProperty(&quot;Trump&quot;)); //使用迭代器遍历 Iterator&lt;Entry&lt;Object, Object&gt;&gt; itr = container.entrySet().iterator(); while(itr.hasNext()) &#123; Entry&lt;Object, Object&gt; set = itr.next(); System.out.println(set.getKey()+&quot;=====&gt;&quot;+set.getValue()); &#125; //将属性列表输出到指定的输出流 PrintWriter file =new PrintWriter(new FileOutputStream(&quot;E:\\\\java程序\\\\properties_save.txt&quot;)); container.list(file); file.close(); &#125; &#125; 读取properties在硬盘中的内容 //load加载properties内容 FileInputStream fis = new FileInputStream(&quot;E:\\\\java程序\\\\properties_save.txt&quot;); container.load(fis); fis.close(); Set&lt;String&gt; set = container.stringPropertyNames(); for(String pro:set) &#123; System.out.println(pro+&quot;=====&gt;&quot;+container.getProperty(pro)); &#125; 参考文献API：https://www.runoob.com/manual/jdk1.6/ 菜鸟教程：https://www.runoob.com/java/java-tutorial.html JAVA final关键字：https://blog.csdn.net/PickUpOldDriver/article/details/80566628 JAVA static block：https://blog.csdn.net/qq_35868412/article/details/89360250 JAVA this关键字：https://blog.csdn.net/qq_43555323/article/details/84993460 JAVA IO：https://blog.csdn.net/baobeiSimple/article/details/1713797","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"}]},{"title":"大一ESL101 Argumentative Essay (hole)","slug":"2020-11-10-ESL101-Argumentative-Essay-(hole)","date":"2020-11-10T05:00:00.000Z","updated":"2021-08-20T13:41:58.640Z","comments":true,"path":"2020-11-10-ESL101-Argumentative-Essay-(hole)/","link":"","permalink":"http://xiongy-rhit.github.io/2020-11-10-ESL101-Argumentative-Essay-(hole)/","excerpt":"Question Is Camp Green Lake actually beneficial for the boys?","text":"Question Is Camp Green Lake actually beneficial for the boys? My EssayYao Xiong 11/10/20 ESL101-OL1 Ms.Hurdlik Draft#2 Why is Punishment Beneficial?Sometimes, when making mistakes at school, we will receive some punishments, such as standing out of the classroom or cleaning the entire restroom by ourselves. Why should teachers implement them if such punishments are not beneficial for students? Actually, many teachers want to use these methods to let students realize their own problems and avoid them in the future. It is the same idea as digging holes at Camp Green Lake. Camp Green Lake is beneficial for those boys’ both physical bodies and inner characters. First, boys get stronger through digging the holes at Camp Green Lake. Opponents might argue that forcing those young boys to dig different five-foot holes in such a desolate desert is harmful to them because after digging holes, each child feels exhausted. However, digging the holes at the Camp Green Lake is similar to doing exercises in gyms. To dig the holes, boys have to use up their inner energy which is stored in their muscles. It is this action that allows them to cooperate with their whole body together. In the long run, boys will become stronger than before. Take Stanley as an example. When he arrived at Camp Green Lake, it was hard for him to dig his own holes. In the beginning, he was the last one who finished the holes and was not able to lift his heavy body. “He put his hands on the rim and tried to pull himself up. He couldn’t do it. His arms were too weak to lift his heavy body.”(Holes, P19)However, after digging holes at Camp Green Lake for several months, he could climb the high mountain with Zero. “Stanley took hold of Zero’s forearms and pulled him upright. Then he stooped down and let Zero fall over his right shoulder. He stood up, lifting Zero’s worn-out body off the ground.” (Holes, P75) It is easy for us to find the reason through connecting his experience at Camp Green Lake: it was digging holes that helped Stanley strengthen his muscles and provided extra power for him to climb God’s Thumb. Thus, Camp Green Lake is beneficial for boys when considering physical body strength. Secondly, Camp Green Lake is a good place for boys to make friends. At Camp Green Lake, everyone is treated equally. “Stanley was thankful that there were no racial problems. X-Ray, Armpit, and Zero were black. He, Squid, and Zigzag were white. Magnet was Hispanic. On the lake, they were the same reddish brown color – the color of dirt.” (Holes, P37)Such related peaceful environment allowed boys to erase discrimination and make friends with each other. In the past, Stanley was alone because other kids always laughed at his weight. However, at Camp Green Lake, nobody cared about their size and races. Stanley could feel more confident about himself so that he was willing to talk with other boys in his camp. There, boys called Stanley Caveman, which means they had accepted him as a member in the team. When Stanley was reading his letter, X-ray got him out of the trouble. “‘Give him some space,’ said X-Ray. ‘If Caveman doesn’t want to read it to us, he doesn’t have to. It’s probably from his girlfriend.’ Stanley smiled.” (Holes, P. 33) Due to this merit of Camp Green Lake, Stanley was able to meet such authentic friends. Thirdly, staying in Camp Green Lake enables boys to shape their characters to be better. On the surface, some opponents might assert that digging holes at Camp Green Lake was the Warden’s conspiracy to take advantage of the free labor. However, at Camp Green Lake, finding treasures was the secondary purpose of digging holes. To those boys who broke laws before, digging holes was actually a kind of physical punishment. Because the process of digging holes was hard, boys could repent of their mistakes. Being afraid of digging holes again, as a result, those boys would not be violent or dishonest anymore. Because the judge realized this effect, he advised Stanley to attend Camp Green Lake. “The judge said that there was an opening at Camp Green Lake, and he suggested that the discipline of the camp might improve Stanley’s character.” (Holes, P11) In addition, the guider, Mr. Pendanski, also talked with those boys from time to time, which could lead them in a good direction. “The person is you, Stanley. You’re the reason you are here. You’re responsible for yourself. You messed up your life, and it’s up to you to fix it. No one else is going to do it for you.” (Holes, P26) With the help of such conversations, the boys had more understanding of their own crimes and got rid of bad habits which were parts of their characters before. Combining hard labor with psychological education is better than just sending those boys into jails, which only provide physical punishments. In conclusion, to some people, Camp Green Lake was a hell for those boys. However, considering their previous crimes, digging holes at Camp Green Lake was better than staying in the jails because those boys could improve their muscle strength, shape own characters, and even make more friends. At Camp Green Lake, those boys will receive physical and spiritual purification. Thus, Camp Green Lake is beneficial to those boys. Work Cited Page Sachar, Louis (1998). Holes. Farrar, Straus and Giroux (US),","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"大一ESL101 comparison essay","slug":"2020-10-16-ESL101-comparison-essay","date":"2020-10-16T04:00:00.000Z","updated":"2021-08-20T13:34:55.822Z","comments":true,"path":"2020-10-16-ESL101-comparison-essay/","link":"","permalink":"http://xiongy-rhit.github.io/2020-10-16-ESL101-comparison-essay/","excerpt":"Yao Xiong 10/7/20 ESL101-OL1 Ms.Hurdlik Draft#2 Big University or Small College​ University provides higher education and research opportunities for people. A proper university is related to students’ future developments. However, deciding where to study, a big university or a small college, is a huge task, especially when going abroad. In the past, as a high school student, I was struggling to make such a decision. Finally, I decided to attend a small college, considering activity participation, class size, and intimate community.","text":"Yao Xiong 10/7/20 ESL101-OL1 Ms.Hurdlik Draft#2 Big University or Small College​ University provides higher education and research opportunities for people. A proper university is related to students’ future developments. However, deciding where to study, a big university or a small college, is a huge task, especially when going abroad. In the past, as a high school student, I was struggling to make such a decision. Finally, I decided to attend a small college, considering activity participation, class size, and intimate community. ​ The first aspect is school activity engagement. It is true that big universities have a broad range of clubs and thousands of volunteer activities provided for students. For example, at UCDavis, they have more than 800 student clubs on campus, whether you are interested in cultural identity, religion, a future profession, artistic expression or community service. However, at big universities, the number of students is at least ten thousand for one term. In another words, the competition for choosing ideal clubs is quite intensive. Thus, to take part in some clubs, such as Computer Security Club, American Football Club, and Gaming Club, students have to make full use of every minute. In contrast, at small colleges, with fewer students, undergraduates can choose their ideal clubs without any obstructions. Simultaneously, considering student enjoyment in school activities, small colleges also plan many clubs, which are enough for students. For instance, Rose-Hulman Institute of Technology has more than 90 clubs and organizations. Though it is a STEM college, Rose still provides colorful after-class activities: playing in the band, being a DJ on the campus radio station, and expanding horizons in Engineers. Thus, the ability to engage in my dream school activity is the first reason I chose a small college. ​ In addition, one of the biggest differences between large universities and small colleges is the class size. Because big universities have a huge number of students, to decrease the cost, professors there have to teach undergraduates in a huge group. It is common for a big university student to take part in such lecture courses five times a week, and during the class time, professors usually have difficulty answering every student’s question. In another words, to save more time, they often reduce class interactions with students. As a result, although students are confused about the class topic, they cannot get an explanation from professors immediately. In contrast, at small colleges, with a higher student-faculty ratio, students have opportunities to take courses with fewer people. Because there are only about 30 students in each class, professors are willing to increase class interactions with them. Therefore, students can receive better class experience. Take Jimmy and Tony, two elder students from my high school, as an example. After graduation, Jimmy chose Rose-Hulman Institute of Technology, and Tony went to University of Wisconsin-Madison. Tony told me that there were over 40000 students at his university. Taking a lecture course with two hundred students was the normality, and in a two-hour class, the professor only provided ten minutes to answer students’ questions, so it was terrible that most of the students could not get specific solutions immediately. In contrast, at RHIT, Jimmy mentioned that the student-faculty ratio was only 11:1 there, which was higher than University of Wisconsin-Madison. There professors liked to hold classes of around 20 students. Such small classes facilitated great learning environments because of more active interactions between professors and students. Considering the course experience, I chose Rose-Hulman. ​ Finally, I think having fewer students is also a benefit of small colleges because a small scale college encourages students to build relationships with peers more easily. Everyone will know each other through classes, clubs, and other activities, so at small colleges, students are more like family members instead of classmates. At there, students have an advantage in making friends. Students’ seats are fixed at the beginning of the semester, which means they can use the rest of the time to be familiar with other 30 classmates. Through several class discussions and group projects, they are able to enhance their friend circles quickly. In contrast, at big universities, the situation is quite different. Because students choose their seats randomly in a classroom and near people are always changing every class, hardly can they get to know a specific student and build friendship with him. Expending the circle of friends is my goal to study abroad. Increasing few intimate friends during four years offends my purpose. Thus, it was the high possibility of making intimate friends that attracted me to RHIT. ​ To sum up, although big universities can provide me with more research opportunities all over the world, I still chose a small college. To take part in ideal clubs easily and experience better teaching quality, I arrived at Rose-Hulman Institute of Technology. Six weeks’ study experience at RHIT had left me a good impression: responsible faculties and interesting classes. I hope more students can join our RHIT family in the future.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"致高中的三年","slug":"2020-05-02-至高中的三年","date":"2020-05-02T04:00:00.000Z","updated":"2021-08-20T17:13:02.693Z","comments":true,"path":"2020-05-02-至高中的三年/","link":"","permalink":"http://xiongy-rhit.github.io/2020-05-02-%E8%87%B3%E9%AB%98%E4%B8%AD%E7%9A%84%E4%B8%89%E5%B9%B4/","excerpt":"这里是一段视频，充满高中三年的回忆，再见了高中，Goodbye我的青春；","text":"这里是一段视频，充满高中三年的回忆，再见了高中，Goodbye我的青春；","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"本科offer全集","slug":"2020-4-30-本科offer全集","date":"2020-04-30T04:00:00.000Z","updated":"2021-08-20T13:46:22.222Z","comments":true,"path":"2020-4-30-本科offer全集/","link":"","permalink":"http://xiongy-rhit.github.io/2020-4-30-%E6%9C%AC%E7%A7%91offer%E5%85%A8%E9%9B%86/","excerpt":"高中辛苦（快乐）三年，斩获这些offer,留此随笔以作纪念","text":"高中辛苦（快乐）三年，斩获这些offer,留此随笔以作纪念","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"高中毕业感想","slug":"HighSchoolGraduation","date":"2020-03-03T13:51:27.000Z","updated":"2021-08-20T02:24:14.320Z","comments":true,"path":"HighSchoolGraduation/","link":"","permalink":"http://xiongy-rhit.github.io/HighSchoolGraduation/","excerpt":"","text":"时光荏苒，白驹过隙。3年，我们马上要毕业了，真快。仿佛早晨才刚刚相遇，此时又即将分别。高中时光转瞬即逝，留下的是美好的回忆。以前的我胆小害羞，但如今我逐渐变得自信阳光。这得益于国际部出色的教学方法：国际部是中西合璧的产物。它坚守着中国传统教学的质量，同时融入西方先进教育的思想。学生上课与老师积极互动，课下一起合作完成project。Emily老师与Jeff老师令我印象深刻。 Emily在物理课上与我们激烈讨论现代物理的杰出成果，课后一同布置教室，老师和我们就像亲人，其乐融融。Jeff老师关心同学，即便在周末也不忘发来邮件以示慰问。 这三年的学习生活有苦也有甜。如今依稀记得那成堆的书本和厚厚的笔记，它们承载着我高中奋斗的时光。寒窗苦读三年载，终迎金榜题名时。努力学习终有回报，收到满意的offer，仿佛之前的投入一切都是值得的。路漫漫其修远兮，吾将上下而求索。Yesterday is a history, future is a mystery, and today is a present. 天行健君子以自强不息，地势坤君子以厚德载物。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"高中毕业前夕文学课Extended Essay","slug":"2020-02-29-High-School-Extended-Essay","date":"2020-02-29T05:00:00.000Z","updated":"2021-08-20T02:36:05.887Z","comments":true,"path":"2020-02-29-High-School-Extended-Essay/","link":"","permalink":"http://xiongy-rhit.github.io/2020-02-29-High-School-Extended-Essay/","excerpt":"Peter Professor Jeff Literature 2 February 2020 To what extent procrastination affects our life and which factors cause procrastination?IntroductionIn the daily life, everyone has the experience on finishing projects. Normally, organized people prefer to divide time and complete work as quickly as possible. However, most of us tend to start action till the deadline. Some students even enjoy the pleasant sensation at the last gasp. In psychology, this phenomenon is called “procrastination.” To what extent procrastination affects our life and which factors cause procrastination? Does procrastination really have no benefits? To achieve this goal, I have organized my paper into five main sections, each of which has few sub-sections. In the first section, I provide the history of the world “procrastination”, how ancient people view procrastination, and procrastination in our daily life. In the second section, I will describe the causation of procrastination from two aspects: external factors and internal factors. In the third section, it includes the analysis on the advantages and disadvantages of having procrastination. In the forth section, I list several solutions to help people if procrastination has brought problems to their life. What’s more, at the end of this article, I have listed few methods to practice the solutions in real life. Among two of the chapters, I cite one experiment to introduce procrastination and one method to solve procrastination problem.","text":"Peter Professor Jeff Literature 2 February 2020 To what extent procrastination affects our life and which factors cause procrastination?IntroductionIn the daily life, everyone has the experience on finishing projects. Normally, organized people prefer to divide time and complete work as quickly as possible. However, most of us tend to start action till the deadline. Some students even enjoy the pleasant sensation at the last gasp. In psychology, this phenomenon is called “procrastination.” To what extent procrastination affects our life and which factors cause procrastination? Does procrastination really have no benefits? To achieve this goal, I have organized my paper into five main sections, each of which has few sub-sections. In the first section, I provide the history of the world “procrastination”, how ancient people view procrastination, and procrastination in our daily life. In the second section, I will describe the causation of procrastination from two aspects: external factors and internal factors. In the third section, it includes the analysis on the advantages and disadvantages of having procrastination. In the forth section, I list several solutions to help people if procrastination has brought problems to their life. What’s more, at the end of this article, I have listed few methods to practice the solutions in real life. Among two of the chapters, I cite one experiment to introduce procrastination and one method to solve procrastination problem. Chapter1 HistoryDEFINITION Procrastination is the avoidance of doing a task that needs to be accomplished by a certain deadline. It could be further started as a habitual or international delay of starting or finishing a task despite knowing it might have negative consequences. Where is this word from? “Procrastinate” is not an originated word in English. English speakers borrowed the word in the 16th century from Latin procrastinates, which itself evolved from the prefix pro-, meaning “forward,” and crastinus meaning “of tomorrow.” “Procrastinate” means to move or act slowly so as to fall behind. It typically implies blameworthy delay especially through laziness or apathy. How ancient people view procrastination. People thousands of years ago were much like we are today. The genius of ancient world had claimed “Do not say, ‘when I am free I will study, for perhaps you will not become free.’” Punctuality is the essence of ethics. As Bible mentions, “Make the best use of the time, because the days are evil.” (Ephesians[1] 5:16) From ancient articles, we view that procrastination is disgusted by individuals. Academic procrastination. Procrastination stays everywhere around us, especially for students. As they receive the first assignment from teachers, some of them tend to finish homework at the deadline day. Such students always find excuse to explain their problems. This phenomenon can be defined as “academic procrastination.” To know about the situation of nowadays’ students, I make a survey around my classmates. Through asking them when they hand in last literature project, I found that 40 percent of them prefer to delay their projects, which means academic procrastination is common among students. It is also obvious from the study of University of Vermont. Since 1984, Vermont University made a survey. 46% of the students reported that they “always” or “nearly always” procrastinate writing papers, while approximately 30% reported procrastinating studying for exams and reading weekly assignments. Nearly a quarter of the subjects reported that procrastination was a problem for them regarding the same tasks. A 1992 study showed that up to 95 percent of college students regularly procrastinate, and 70 percent of graduate student reports are almost delayed in writing a paper. Chapter 2 REASONSThere may be some problems to make academic procrastination so common among students. According to the research and observation, I divide the factors into two groups: external factors and internal factors. 1. External factor: Circumstance People are easily influenced by their surroundings. It is a shared convention that that “it is impossible to remember a whole book at the country fair.” In the same way, hardly can a student finish an essay or project on time in a noisy place. For instance, the teacher assigns one personal project to each student, and one of the guys chooses to finish his work at the dormitory. By happened, without many works, his roommates start to play computer games. Because of the attraction of surrounding people, the student who has a project may give up his project. As a result, he cannot complete the assignment on time, which means he gets procrastination. Thus, circumstance can lead a person’s procrastination. Not only surroundings could trigger our procrastination, but also internal factors can lead procrastination. \\1. Internal factor: Having no confidence. Plenty of students like to avoid problems and most of them prefer to procrastinate. As the psychologist mentions “From the psychological level, some people are not confident in the ability to work is an important reason for procrastination.”The reason why such people lose confidence is that they used to receive setbacks in one area. As a result, they tend to create psychological escape. That’s why these people have procrastination problems. 2. Internal factor: perfectionism. Perfectionists[2] set high standards for themselves. They want to make everything in good order. There is an eternal goal in their hearts – the pursuit of perfection. The idea haunts them and keeps them fighting for it all their lives. They strive for certain, precise “perfection”, and they pay close attention to the nuances of everything, sometimes to the point of nit-picking. In the end, perfectionists usually devote most of their time on preparation and thinking but little on action, so perfectionists choose to procrastinate their works. 3. Internal factor: Indolence. Not every procrastinator used to meet frustrations, and not every procrastinator is perfectionist. Some people choose to procrastinate and delay their projects or essays because they are really lazy. Such individuals are inactive in every field, which means they make no effort to seek progress, so they accept hedonism[3]. Hedonism becomes one of the reasons cause procrastination. 4. Internal factor: Unsustainable attention. Keeping focus is one of the ways to success. However, few people have the ability to concentrate on one event for a long time. When students start to do projects or write essays, some of them can be easily attracted by surrounding smart phones. They cannot wait for over five minutes without checking YouTube or Wechat. These students’ efforts are always half-hearted. Finally, as the time passes by, the people who check cell-phones from time to time usually have slow progress on their works, so they choose to create excuse to delay projects or essays. Unsustainable attention becomes one of the most significant reasons why students choose academic procrastination. Chapter 3 ADVANTAGES AND DISADVANTAGESAfter analyzing the causation of procrastination, some people may ask “Does procrastination have no advantages since everything has two sides.” Yes. There is nothing actual totally wrong and nothing exact right. Procrastination is also the same. \\1. Advantage: Getting inspiration. Sometimes procrastination at the last crucial moment can become the source of inspiration and creativity. The great artist Leonardo Da Vinci was a classic procrastinator, writing in his notes: “tell me, tell me, what has been accomplished?” And his most famous painting, the Mona Lisa, took him about four years to complete. A king in ancient Greece had a crown made of pure gold, but he was afraid that a craftsman might put silver in it. For the crown was as heavy as the gold given to the goldsmith, no one knew whether the goldsmith had adulterated the gold or not, so the king asked Archimedes to test him. If he couldn’t, he cut off his head. After much meditation and unsuccessful attempts, Archimedes was ready to face death and await his final judgment. That day, he sat in the bath tub, seeing the water overflow, and suddenly he understood and immediately solved the thorny problem with density. Procrastination, in retrospect, can lead to a moment of confusion and an impasse in thinking, and tomorrow you’ll have a great idea, and inspiration will come from the delay. This is one of the values of procrastination, which in popular psychology is called the “brewing effect.” Therefore, people who procrastinate may be more creative. Two sidesProcrastination does not always provide benefits to people, which means sometimes procrastination may bring disadvantages to individuals. Many students spend the last day of the summer vacation; the night before school begins, catching up on homework until dawn. Completing all the work in a short time is not only a physical challenge but also a mental task. In such situation, procrastination may bring unbelievable consequences. Here are several disadvantages on procrastination. 1. Disadvantage: Anxiety. For procrastination cannot help us finish works on time, people usually feel worried about themselves. In the long run, such kind of individuals will lose confidences in specific areas. As a result, they will be racked with self-doubt, constantly. Take a woman with 26 as an example. Female, 26, has suffered from procrastination for many years and has experienced it every day. She has decided to do something, put it off, and put it off until the last minute. She can’t enjoy the present life and is very anxious about not finishing her tasks. Thus, procrastination may bring anxiety to people who have heavy works. 2. Disadvantage: Lack of concentration. We are living in an era of information explosion. We are often interrupted by mobile phone messages and news feed. Many people find it increasingly difficult to stay focused and get things done. This is one of the dangers of procrastination. With long run procrastination, many people cannot concentrate on one object. Almost everyone used to have such experience: you may want to write an article in the morning, but after ten minutes, without any inspirations, you open the Internet to search for materials. Unluckily, due to attractive entertainment news, you put down articles, and after half an hour, once you decide to go back to writing again, your friend send a message to invite to you to a party. In the end, hardly can you finish the article in a given time. Because of procrastination, people lose their attention. In other words, they are not able to concentrate for a long time. Even a small sound can interrupt their focus. 3. Disadvantage: Wear done the body. People with procrastination cannot finish projects at the given time, which means these individuals have no choice but to stay up too late to finish their works. According to Chinese medical books, to begin with, stay up late will bring gastrointestinal problems. People who stay up late deprive the gastrointestinal tract of the opportunity to rest, leading to peptic stomach ulcers. Secondly, staying up late will induce cardiovascular and cerebral vascular diseases. Staying up late make people in nervous state, cannot relax, so it will cause vasoconstriction abnormality, and blood pressure is higher than normal, which means they are easy to induce hypertension or aggravate the disease. Now as the incidence of cardiovascular diseases is increasing more and more among young, one of the indirect causes is procrastination. 4. Disadvantage: GPA. As a student, Grade point average is quite significant for us. It is getting high scores in school that provided a high platform for us to find a good job. However, sometimes, procrastination may break everything. Since handing in projects or essays on time is the most necessary point for a student, students with procrastination cannot catch up the standard. As a result, they will lose many scores in some subjects, even cannot graduate from university easily due to procrastination. According to an Educational Science Professor, Hatice Odaci, academic procrastination is a significant problem during college years in part because many college students lack efficient time management skills in using the internet. As a result, such students become engulfed in distractions, and thus in procrastination. Comparing with the students using computers over five hours one day, about 70% of the rest students have higher grade point average, and the students do not procrastinate works are usually much easier to graduate from the colleges. Procrastination is a double-edged sword: finishing all hard work at the last gasp in some ways can inspire people’s creativity but keeping for a long time is not only bad for physical body but hurt mental hearts. Chapter 4 SOLUTIONSSince procrastination sometimes will bring problems to people, is there any solution for us to avoid it? The first solution: RET. Rational emotion therapy (RET), founded by American psychologist Alice, emphasizes the criticism of irrational beliefs, and its basic theory –ABC theory plays a good role in overcoming procrastination. Alice thinks that the distractions of humans’ behaviors and mental are not caused by activating events. In other words, because of individuals’ wrong belief, some consequences begin to happen. A person should abandon perfectionism, which means they need to realize that nothing can become perfect, just like the arms of Venus. Individuals are supposed to develop and perfect themselves constantly in life. Provided that everyone realizes this idea, in the end, he or she will have the opportunity to get rid of procrastination. The second solution: Setting a proper goal. Having a good goal is like walking with a proper leader. A person without target is like a boat without sweep, so how to make a proper goal? Most of us go to our graves with our music still inside us. (Oliver Wendell Holmes) Making a goal should marches to our own rhythm. Henry David Thoreau used to mention: “If a man does not keep pace with his companions, perhaps it is because he hears a different drummer. Let him step to the music which he hears, however measured or far away.” Provided that you are a student, your first goal is to get high grade average points. If you are a worker, your first goal is to maximum your benefits. We should know what we are aiming for so that we can make the goal with is proper to us. About sixty percent of people choose to procrastinate because they have no goals, so they behave like birds losing directions. If such people can design for themselves, they can get out from shadows and give up procrastinating. The third solution: Eliminating distractions. Modern games are introduced into many peoples’ daily life in an increasing speed. When individuals enjoy games, isn’t necessary that they give some consideration to the time they spent? Many procrastinators have no enough time to finish their works for they waste too much time on other things, such as playing electric games or watching movies. To remove interference, procrastinators can subconsciously tell themselves to get rid of these distractions, turn off the TV, and put the entertainment further away. They can also encourage themselves to talk and watch movies after finishing their work. If they can keep for a long time, procrastination can be removed from their lives. Chapter 5 PRACTICEHow to use these solutions in our daily life? A scheme cannot be used is not a good plan. The first step is making sure whether you have procrastination. Taking a test can help you see how bad your procrastination is. Make sure if your work time is always on the Internet? Make sure if you have no work plan and no time management; Make sure if you ever have the experience that you can finish work on time, but you deliberately choose to delay your work. Provided that you are satisfied most of the questions mentioned before, you may really have a heavy procrastination. The second step is taking actions. If your problem is that you are worried about my GPA, you should try your best to memorize for 2 hours a day before the exam. If your cannot finish your essay, you’d best to plan to use two days to search for materials and three days to write plus two days to revise. Example There was an author of a web site refused to start writing a paper for months, soher psychologist suggested her to set aside the good and the bad, and she can make an experiment to test the worst paper she could write. The author did so. Surprisingly, she found that her “worst” essay was so satisfying that she felt she could submit it to her tutor with a few revising. Of course, sometimes there is a gap between the first draft and the final requirements of the paper. Thus, the psychologist taught the writer another method: work for one more hour and then write one more page. Even if the psychological experiments have shown that satisfying one’s immediate emotional needs is not the best strategy and keeping immediate emotional needs in the long run will reduce rather than increase one’s self-satisfaction and happiness. However, mortal therapy is quite practical to procrastinators, which means procrastinators don’t need to pay attention to the food that affects their mood, and procrastinators just need to follow their minds and concentrate on their own things so that they can calm down. The author followed the instructions, writing down on one page whenever she wanted to do except writing. Until she has finished all of her work, the author began to start the events that written on the paper, such as surfing the websites or enjoying a fantastic movie. CONCLUSIONMany procrastinators enjoy the feeling of suddenly relaxing after a stressful time, and the results of procrastination are sometimes good. In another word, the procrastinators are able to discuss and consult with other peoples and then write more comprehensively than I had finished first. Many students and workers tend to delay their works and assignments because of this. They consider that delaying works enables them to complete works more comprehensively and creatively. However, this kind of benefits may become disadvantages. We can’t force ourselves to walk across the plank forever by setting fire under it. Moreover, the feeling of repressed anxiety and dissatisfaction with oneself is not pleasant, so the best thing to do is not to delay works. Start to work from today. Even if using less time may limit our talents and abilities, it enables us to finish our researches and make our life more pleasant. Notes Some of the conclusions are taken from daily life The purpose of this essay is to help people understand procrastination. The examples are searched from the websites. According to the descriptions of my web-friends, I translate Chinese into English. Works citedMr Feng “A research paper on procrastination” (2015-02-23 21:22:31) http://blog.sina.com.cn/s/blog_80cae6a40102vk4p.html Quan Run Wen 2001 “Morita therapy in China” “Journal of healthy psychology” ，Web, 2 February, 2020 Johnson, Juliet McEwen. “the 9 reasons People Procrastinate with social Media”. Web, 8 Feb, 2020 Dictionary “Procrastination.” Merriam Webster.com Dictionary , Merriam-Webster, Web,. Accessed 22Feb.2020 ChuJun Fan 2016 “A study on the harm of procrastination in college students and its coping strategies”,6 Feb, 2020 Ross J. Q. Owens “How to study in college” TENTH EDITION Walter Park Cornell University, Emeritus , 1, Jan, 2020 [1] Ephesians: a book of the Bible, originally a letter to the church in Ephesus and traditionally attributed to St Paul [2] Perfectionist: a person who likes to do things perfectly and is not satisfied with anything else. [3] Hedonism: the belief that pleasure is the most important thing in life.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"画樱花树，使用python","slug":"pythonDrawing","date":"2020-02-15T05:00:00.000Z","updated":"2021-08-20T17:13:34.472Z","comments":true,"path":"pythonDrawing/","link":"","permalink":"http://xiongy-rhit.github.io/pythonDrawing/","excerpt":"春节期间，疫情突发，闲着无聊，自学python；","text":"春节期间，疫情突发，闲着无聊，自学python； 下面是根据python的turtle库所绘画出的樱花树","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"高中校园微电影","slug":"2019-05-11-高中校园微电影","date":"2019-05-11T04:00:00.000Z","updated":"2021-08-20T17:12:38.125Z","comments":true,"path":"2019-05-11-高中校园微电影/","link":"","permalink":"http://xiongy-rhit.github.io/2019-05-11-%E9%AB%98%E4%B8%AD%E6%A0%A1%E5%9B%AD%E5%BE%AE%E7%94%B5%E5%BD%B1/","excerpt":"高中嘛，总有些好玩的活动，高二上学期举办的校园微电影，过去凑个热闹，当个群演。","text":"高中嘛，总有些好玩的活动，高二上学期举办的校园微电影，过去凑个热闹，当个群演。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"robot_project_physics","slug":"2019-01-06-robot_project_physics","date":"2019-01-06T05:00:00.000Z","updated":"2021-08-20T17:13:46.718Z","comments":true,"path":"2019-01-06-robot_project_physics/","link":"","permalink":"http://xiongy-rhit.github.io/2019-01-06-robot_project_physics/","excerpt":"高二上学期，物理老师Emily闲着没事做，组织的robot物理project（就是把roborave那套玩一遍）","text":"高二上学期，物理老师Emily闲着没事做，组织的robot物理project（就是把roborave那套玩一遍）","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"DIY","slug":"DIY","permalink":"http://xiongy-rhit.github.io/tags/DIY/"},{"name":"JAVA","slug":"JAVA","permalink":"http://xiongy-rhit.github.io/tags/JAVA/"},{"name":"java","slug":"java","permalink":"http://xiongy-rhit.github.io/tags/java/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://xiongy-rhit.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数学","slug":"数学","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Git","slug":"Git","permalink":"http://xiongy-rhit.github.io/tags/Git/"},{"name":"微积分","slug":"微积分","permalink":"http://xiongy-rhit.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://xiongy-rhit.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Maple","slug":"Maple","permalink":"http://xiongy-rhit.github.io/tags/Maple/"},{"name":"前端","slug":"前端","permalink":"http://xiongy-rhit.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"静态网页","slug":"静态网页","permalink":"http://xiongy-rhit.github.io/tags/%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/"},{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"http://xiongy-rhit.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"},{"name":"随笔","slug":"随笔","permalink":"http://xiongy-rhit.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}