
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Java数据结构与算法汇总 | Yao Xiong</title>
        <meta name="author" content="Yao Xiong">
        <meta name="description" content="莫听穿林打叶声， 何妨吟啸且徐行">
        <meta name="keywords" content="Yao Xiong Projects">
        <link rel="icon" href="/img/favicon.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.2.0/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:2147483647;justify-content:space-between;background:#fff;transition:all 0.3s ease-out;-webkit-user-select:none;-moz-user-select:none;user-select:none"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="showpage" style="display: -not-none">
                    <div id="menushow">
                        <nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Yao Xiong</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;projects</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menushow" id="phone-menu">
        <div class="curtain" @click="menushow = !menushow" v-show="menushow"></div>
        <div class="title" @click="menushow = !menushow">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Yao Xiong</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menushow">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">projects</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div class="article">
    <div>
        <h1>Java数据结构与算法汇总 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2021/7/23
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/java/" style="color: #ff7d73">
                    java
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="color: #03a9f4">
                    数据结构与算法
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <p>作者:Yao Xiong</p>
<p>[TOC]</p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>学习计算机主要是了解计算机组成结构与如何灵活运用计算机；在灵活运用计算机时，数据结构与算法起到重中之重的作用。要想成为计算机大神，数据结构与算法是必须跨过的坎。Good Luck👍。</p>
<span id="more"></span>



<h1 id="Comparable-与-Iterable-接口"><a href="#Comparable-与-Iterable-接口" class="headerlink" title="Comparable 与 Iterable 接口"></a>Comparable 与 Iterable 接口</h1><h2 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><em>Interface Comparable<T></T></em></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406201919191.png" alt="image-20210406201919191"></p>
<p>如果一个类实现Comparable接口，其必须实现CompareTo方法，调用此方法的对象将与里面的o对象进行比较</p>
<p>例如：</p>
<p>x.CompareTo(T y) </p>
<p>x和y进行比较，如果相等返回0；若x&gt;y，返回1；若x&lt;y，返回-1；当然，CompareTo方法的实现由我们自己定义</p>
<ul>
<li>实现此接口的对象拥有自然顺序（natural ordering）</li>
<li>对象之间可以使用CompareTo(T o)来进行比较</li>
<li>如果对储存此对象的集合调用sort方法，Collections工具类会根据CompareTo方法排序：Collections.sort(list2);</li>
</ul>
<pre><code class="java">//节点实现Comparable接口
class Node implements Comparable&lt;Node&gt; &#123;
    private int num;
    Node(int num)&#123;
        this.num = num;
    &#125;
    @Override
    public int compareTo(Node arg0) &#123;
        // TODO Auto-generated method stub
        int num2 = arg0.num;
        return num - num2;
    &#125;
    @Override
    public String toString() &#123;
        return num+&quot;&quot;;
    &#125;
    
&#125;


//在主程序中调用
public class NaturalOrderTest &#123;
    public static void main(String[] args) &#123;
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        list.add(66);
        list.add(33);
        list.add(66);
        list.add(68);
        list.add(23);
        list.add(78);
        LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;();
        for(Integer i:list) &#123;
            list2.add(new Node(i));
        &#125;
        Node node = new Node(23);
        Collections.sort(list2);
        System.out.println(list2);
        
    &#125;
    
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406215842517.png" alt="image-20210406215842517"></p>
<h3 id="集合调用进行排序"><a href="#集合调用进行排序" class="headerlink" title="集合调用进行排序"></a>集合调用进行排序</h3><p>假如我们需要对一组集合中的对象进行2种不同的排序方法</p>
<p>Collections.sort(…)有2种形式           // Collections指集合工具类</p>
<ol>
<li><p>Sort by the natural order: Collections.sort(todoList); todoList里面的对象必须是Comparable的</p>
<ul>
<li>Collections.sort(list2);</li>
</ul>
</li>
<li><p>Sort according to a specified order</p>
<ul>
<li>Collections.sort(list2, ComparatorClass);</li>
<li>ComparatorClass是一个类，实现了Comparator接口</li>
</ul>
</li>
</ol>
<p>Comparator也是一个接口</p>
<p><em>Interface Comparator<T></T></em></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406204319601.png" alt="image-20210406204319601"></p>
<p>要实现compare(T o1, T o2)方法，返回值是int，与Comparable类似</p>
<p>o1是前一个元素， o2是后一个元素</p>
<p>针对第2中形式(Comparator)，我写了一个例子</p>
<pre><code class="java">//实现Comparator接口
class ComparatorClass implements Comparator&lt;Node&gt;&#123;

    @Override
    public int compare(Node arg0, Node arg1) &#123;
        // TODO Auto-generated method stub
        return arg1.num-arg0.num; //进行逆序排列
    &#125;
    
&#125;

//原来实现Comparable接口的类
class Node implements Comparable&lt;Node&gt; &#123;
    int num;
    Node(int num)&#123;
        this.num = num;
    &#125;
    @Override
    public int compareTo(Node arg0) &#123;
        // TODO Auto-generated method stub
        int num2 = arg0.num;
        return num - num2;
    &#125;
    @Override
    public String toString() &#123;
        return num+&quot;&quot;;
    &#125;
    
    
    
&#125;


//测试类
public class NaturalOrderTest &#123;
    public static void main(String[] args) &#123;
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        list.add(66);
        list.add(33);
        list.add(66);
        list.add(68);
        list.add(23);
        list.add(78);
        
        LinkedList&lt;Node&gt; list2 = new LinkedList&lt;&gt;();
        for(Integer i:list) &#123;
            list2.add(new Node(i));
        &#125;

        //进行排序
        Collections.sort(list2, new ComparatorClass());
        System.out.println(list2);
        
    &#125;
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406220909648.png" alt="image-20210406220909648"></p>
<p>有了Comparator接口的实现类，我们可以对已有的集合中的元素(<em>元素属性足够多</em>)进行各种指定的排序，如</p>
<pre><code class="java">Collections.sort(list, new BigToSmallComparator()); //从大到小

Collections.sort(list, new LftToRtComparator());//从左到右

Collections.sort(list, new TopToBotComparator());//从上到下
</code></pre>
<h2 id="Comparator-和Comparable总结"><a href="#Comparator-和Comparable总结" class="headerlink" title="Comparator 和Comparable总结"></a>Comparator 和Comparable总结</h2><p>Comparable</p>
<ul>
<li>interface for objects that can be compared</li>
<li>control classes’ natural ordering</li>
<li>实现方法：int compareTo(T o1);</li>
</ul>
<p>Comparator</p>
<ul>
<li>still an interface for objects but used to defined the rule</li>
<li>use Comparator to sort objects in an order other than their natural ordering</li>
<li>实现方法：int compare(T o1, T o2);</li>
</ul>
<h2 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406223042219.png" alt="image-20210406223042219"></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406223100699.png" alt="image-20210406223100699"></p>
<p>Iterable也是一个接口</p>
<p>实现这个接口，必须实现其Iterator方法，返回一个迭代器</p>
<pre><code class="java">class MyList implements Iterable&lt;MyList&gt;&#123;

    @Override
    public Iterator iterator() &#123;
        // TODO Auto-generated method stub
        return null;
    &#125;
    
&#125;
</code></pre>
<p>同时，实现了iterable接口的集合都可以进行for-each-loop（增强for），当然还要返回有效的iterator()</p>
<p>所以同时我们也要实现iterator接口（一般使用内部类来实现此接口）</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406224454050.png" alt="image-20210406224454050"></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406224515646.png" alt="image-20210406224515646"></p>
<p>实现Iterator接口</p>
<ul>
<li>boolean    hasNext()</li>
<li>E     next()</li>
<li>void    remove()</li>
</ul>
<p>使用内部类来实现</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210406224841672.png" alt="image-20210406224841672"></p>
<p>外部类实现Iterable接口，内部类实现Iterator接口</p>
<p><strong>为什么要用内部类？</strong></p>
<blockquote>
<p>引用Data Structure and Algorithm Analysis in Java的原话</p>
<p>The inner class is useful in a situation in which each inner class object is associated</p>
<p>with exactly one instance of an outer class object. In such a case, the inner class object can</p>
<p>never exist without having an outer class object with which to be associated.</p>
<p>翻译过来就是：当一个类需要使用另一个类里面的元素时，同时要保证被引用的类的元素是私有的，此时我们就可以使用内部类；在这种情况下，如果没有外部类，内部类就无法存在。</p>
</blockquote>
<h2 id="Iterator和Iterable总结"><a href="#Iterator和Iterable总结" class="headerlink" title="Iterator和Iterable总结"></a>Iterator和Iterable总结</h2><p>Iterator与Iterable两个接口缺一不可</p>
<p>Iterator接口让实现Iterable的对象返回一个迭代器对象</p>
<p>Iterable为Iterator的使用创造条件</p>
<ul>
<li>实现Iterable接口后，集合就可以进行for-each循环</li>
<li>Iterable is an interface specification for a class that is equipped with an Iterator</li>
<li>Iterator is an interface specification for a class that can generate iterative elements</li>
<li>Each Collection class needs an associated Iterator class</li>
<li>Iterator may access inside of collection</li>
<li>Iterator provides elements one at a time.</li>
</ul>
<h1 id="数据结构：链表"><a href="#数据结构：链表" class="headerlink" title="数据结构：链表"></a>数据结构：链表</h1><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>JAVA中有许多的数据结构,例如数组，队列，栈，链表等。与其他数据结构相比，链表具有增删快，充分利用碎片化空间的特点。链表是引用类型数据，它就像一个表格，包含众多节点（内部的数据通过一个个指针链所相连接）。就像下面这张图<br><img src="https://img-blog.csdnimg.cn/20210219150804680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BldGVyYmVhclhZ,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">链表都是由一个个节点构成，每个节点中包含数据与指针，指针为节点指明方向，即下一个数据或上一个数据。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>链表也可以分类</p>
<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>单向循环链表</li>
</ul>
<p>单向链表是指链表中每个节点都只能指向下一个节点，不能指向上一个。（上面那张示意图就是单向链表）</p>
<p>双向链表是指链表中每个节点都可以指向上一个节点，同时也可以指向下一个节点，示意图如下<br><img src="https://img-blog.csdnimg.cn/20210219152113230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BldGVyYmVhclhZ,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>单向循环链表：一个单向链表的最后一个节点的next指针，指向开头的节点。（示意图如下）<br><img src="https://img-blog.csdnimg.cn/20210219152902270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BldGVyYmVhclhZ,size_16,color_FFFFFF,t_70"></p>
<h3 id="实现链表"><a href="#实现链表" class="headerlink" title="实现链表"></a>实现链表</h3><p>对于链表，我们要实现增删改查的功能。<br>增添数据、删除数据、修改数据、查找数据</p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><pre><code class="java">package DataStructure;

import java.util.Stack;

/**
 * @author 23881
 * 链表的增删改查
 * 合并链表
 * 逆序打印
 *反转链表
 *打印倒是第n个元素
 */
public class SingleLinkedListDemo &#123;

    public static void main(String[] args) &#123;
        SingleLinkedList list = new SingleLinkedList();
//        list.add(new HeroNode(1,&quot;peter&quot;,&quot;peterbear&quot;));
//        list.add(new HeroNode(3,&quot;tony&quot;,&quot;hairCutter&quot;));
        System.out.println(&quot;\t增添元素&quot;);
        list.AddByOrder(new HeroNode(1,&quot;peter&quot;,&quot;peterbear&quot;));
        list.AddByOrder(new HeroNode(3,&quot;tony&quot;,&quot;hairCutter&quot;));
        list.AddByOrder(new HeroNode(2,&quot;jerry&quot;,&quot;printf&quot;));
        list.AddByOrder(new HeroNode(5,&quot;jim&quot;,&quot;java&quot;));
        list.AddByOrder(new HeroNode(6,&quot;trump&quot;,&quot;python&quot;));
        list.AddByOrder(new HeroNode(2,&quot;jerry&quot;,&quot;printf&quot;));
        list.print();
        System.out.println(&quot;\t查找元素&quot;);
        list.Search(0);
        System.out.println(&quot;\t更改元素&quot;);
        list.Update(new HeroNode(2,&quot;zhang&quot;,&quot;专业户&quot;));
        list.print();
        System.out.println(&quot;\t删除元素&quot;);
        list.Delete(2);
        list.print();
        System.out.println(&quot;\t此链表中节点的个数：&quot;+list.size());
        System.out.println(&quot;\t倒数第n个元素\n&quot;+list.NodeFromLast(3));
        System.out.println(&quot;\t反转后的链表&quot;);
        list.ReserveNode();
        list.print();
        System.out.println(&quot;\t逆序打印&quot;);
        list.RevPrint();
        list.ReserveNode();
        System.out.println(&quot;\t合并链表&quot;);
        System.out.println(&quot;链表1：&quot;);
        list.print();
        System.out.println(&quot;链表2：&quot;);
        SingleLinkedList list2 = new SingleLinkedList();
        list2.AddByOrder(new HeroNode(5,&quot;Biden&quot;,&quot;瞌睡虫&quot;));
        list2.AddByOrder(new HeroNode(8,&quot;John&quot;,&quot;somebody&quot;));
        list2.print();
        System.out.println(&quot;合并后：&quot;);
        list.Combine(list2);
        list.print();
        
    &#125;
    
    
&#125;
 
class HeroNode&#123;
    public int No;
    public String Name;
    public String NickName;
    public HeroNode next; //指向下一个节点
    public HeroNode(int No, String Name, String NickName) &#123;
        this.No = No;
        this.Name = Name;
        this.NickName = NickName;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Node[ No: &quot;+this.No+&quot;; Name: &quot;+this.Name+&quot;; NickName: &quot;+this.NickName+&quot; ]&quot;;
    &#125;
    @Override
    public boolean equals(Object obj) &#123;
        HeroNode node = (HeroNode)obj;
        return node.No == this.No &amp;&amp; node.Name.equals(node.Name) &amp;&amp; node.NickName.equals(node.NickName);
    &#125;
    
    
&#125;


class SingleLinkedList&#123;
    //先初始化一个头节点
    public HeroNode Head = new HeroNode(0,&quot;&quot;,&quot;&quot;);
    
    //添加节点
    //找到当前列表的最后一个节点，将最后一个节点的next指向下一个
    public void add(HeroNode node) &#123;
        //head节点不能动，用一个指针指向head
        HeroNode cur = Head;
        //遍历链表
        while(cur.next != null) &#123;
            cur = cur.next;
        &#125;
        cur.next = node;
    &#125;
    
    //按照heronode的编号来存储数据，判断数据是否存在与存储数据
    public void AddByOrder(HeroNode node) &#123;
        HeroNode cur = Head;
        if(isempty()) &#123;
            add(node);
            return;
        &#125;
        while(cur.next != null) &#123;
            if(cur.next.No &gt; node.No) &#123;
                node.next = cur.next;
                cur.next = node;
                break;
            &#125;
            else if(cur.next.No == node.No ) &#123;
                System.out.printf(&quot;%s的编号%d 已存在，无法添加\n&quot;,node.Name,node.No);
                break;
            &#125;
            cur = cur.next;
            if(cur.next == null) &#123;
                add(node);
                break;
            &#125;
        &#125;
        
    &#125;
    
    //对链表中数据进行反转 
    public void ReserveNode() &#123;
        HeroNode cur = Head.next;

        HeroNode temp = new HeroNode(0,&quot;&quot;,&quot;&quot;);
        while(cur!=null) &#123;
            Head.next = cur.next;
            cur.next = temp.next;
            temp.next = cur;
            cur = Head.next;
        &#125;
        Head = temp;
        //第二种
//        HeroNode next =null;
//        while(cur!=null) &#123;
//            next = cur.next;
//            cur.next = temp.next;
//            temp.next = cur;
//            cur = next;
//        &#125;
//        Head = temp;
    &#125;
    
    //删除信息
    public void Delete(int No) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;此链表为空链表，无法删除任何元素&quot;);
            return;
        &#125;
        if(No == 0) &#123;
            System.out.println(&quot;无法删除头节点&quot;);
            return;
        &#125;
        HeroNode cur = Head;
        while(cur.next != null) &#123;
            if(cur.next.No == No) &#123;
                cur.next = cur.next.next;
                return;
            &#125;
            cur = cur.next;
        &#125;
        System.out.println(&quot;未找到匹配的信息&quot;);
    &#125;
    
    
    //改变信息
    public void Update(HeroNode NewNode) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        if(NewNode.No == 0) &#123;
            System.out.println(&quot;无法改变头节点的值&quot;);
            return;
        &#125;
        HeroNode cur = Head;
        while(cur!=null) &#123;
            if(cur.next.No == NewNode.No) &#123;
                NewNode.next = cur.next.next;
                cur.next = NewNode;
                return;
            &#125;
            cur = cur.next;
        &#125;
    &#125;
    
    //查找信息
    public void Search(int No) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        if(No == 0) &#123;
            System.out.println(&quot;此节点为头节点&quot;);
            return;
        &#125;
        HeroNode cur = Head;
        while(cur!=null) &#123;
            if(cur.No == No) &#123;
                System.out.println(&quot;编号 &quot;+No+&quot;:&quot;+cur);
                return;
            &#125;
            cur = cur.next;
        &#125;
        System.out.println(&quot;未找到匹配信息&quot;);
    &#125;
    
    //查找单链表倒数第k个结点
    public HeroNode NodeFromLast(int k) &#123;
        if(k&gt;size()||k&lt;=0) &#123;
            return null;
        &#125;
        HeroNode cur = Head.next;
        for(int i=0;i&lt;(size()-k);i++) &#123;
            cur = cur.next;
        &#125;
        return cur;
    &#125;
    //判空
    public boolean isempty() &#123;
        return Head.next == null;
    &#125;
    
    //遍历打印链表
    public void print() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        HeroNode cur = Head.next;
        while (cur != null) &#123;
            System.out.println(cur);
            cur = cur.next;
        &#125;
    &#125;
    
    //从尾到头打印链表
    //1.将单链表反转，然后遍历（会破坏原来的结构）
    //2.利用栈，将各个节点压入到栈中，先进后出的特点，实现逆序打印的效果
    public void RevPrint() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;此链表为空&quot;);
            return;
        &#125;
        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();
        HeroNode cur = Head.next;
        while (cur != null) &#123;
            stack.push(cur);
            cur = cur.next;
        &#125;
        while(stack.size()&gt;0) &#123;
            System.out.println(stack.pop());
        &#125;
    &#125;
    
    //获取链表节点个数
    public int size() &#123;
        int count =0;
        HeroNode cur = Head;
        while(cur.next != null) &#123;
            cur=cur.next;
            count++;
        &#125;
        return count;
    &#125;
    
    //合并链表
    public void Combine(SingleLinkedList list) &#123;
        HeroNode cur = list.Head.next;
        while(cur!=null) &#123;
            list.Head = cur.next;
            cur.next = null;
            this.AddByOrder(cur);
            cur = list.Head;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="单向链表改进版"><a href="#单向链表改进版" class="headerlink" title="单向链表改进版"></a>单向链表改进版</h4><p>对于上方的单向链表，我们还可以进行升级，以减少代码的冗余程度，比如我们在添加或删除时，都需要对整个链表进行遍历，以找到确切的位置，我们可以把查找变成一个函数，只在添加或删除时对结点进行操作，如下</p>
<pre><code class="java">//在这里面，我们用2个结点，一个表示开头，一个表示结尾，一个变量表示大小    
private Node&lt;E&gt; beginMaker;
private Node&lt;E&gt; endMaker;
private int theSize=0;
</code></pre>
<pre><code class="java">package ReviewForDataStructure;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class MySingleList&lt;E&gt; implements Iterable&lt;E&gt;&#123;
    public MySingleList() &#123;
        doClear();
    &#125;
    
    public void clear() &#123;
        doClear();
    &#125;
    
    public int size() &#123;
        return theSize;
    &#125;
    
    public boolean isEmpty() &#123;
        return size() == 0;
    &#125;
    
    //默认添加到最后
    public void add(E element) &#123;
        add(size(), element);
    &#125;
    
    //添加到指定位置
    public void add(int idx, E element) &#123;
        addAfter(getNode(idx, 0, size()),element);
    &#125;
    
    public E getData(int idx) &#123;
        return getNode(idx+1, 0, size()).data;
    &#125;
    
    public E remove() &#123;
        return remove(size()-1);
    &#125;
    
    public E remove(int idx) &#123;
        Node&lt;E&gt; pre = getNode(idx, 0, size());
        Node&lt;E&gt; node = getNode(idx+1, 0, size());
        pre.next = node.next;
        theSize--;
        return node.data;
    &#125;
    
    //内部Node类
    private static class Node&lt;E&gt;&#123;
        public Node&lt;E&gt; next;
        public E data;
        public Node(E data, Node&lt;E&gt; nx)&#123;
            this.data = data;
            this.next = nx;
        &#125;
    &#125;
    
    private class MyListIterator implements Iterator&lt;E&gt;&#123;
        Node&lt;E&gt; current = beginMaker.next;
        @Override
        public boolean hasNext() &#123;
            // TODO Auto-generated method stub
            return current != endMaker;
        &#125;

        @Override
        public E next() &#123;
            // TODO Auto-generated method stub
            if(!hasNext())
                throw new NoSuchElementException();
            
            E nextItem = current.data;
            current  = current.next;
//            System.out.println(&quot;\n----&quot;+nextItem);
            return nextItem;
        &#125;
        
    &#125;
    
    private void addAfter(Node&lt;E&gt; p, E element) &#123;
        p.next = new Node&lt;E&gt;(element,p.next);
        theSize++;
    &#125;
    
    /**
     * always get the pointed node
     * @param idx
     * @param lower
     * @param upper
     * @return
     */
    private Node&lt;E&gt; getNode(int idx, int lower, int upper) &#123;
        if(idx&lt;lower || idx &gt; upper) &#123;
            throw new NullPointerException();
        &#125;
        
        Node&lt;E&gt; p=beginMaker;
        
        for(int i=0;i&lt;idx;i++) &#123;
            p=p.next;
        &#125;
        
        return p;
    &#125;
    
    private void doClear() &#123;
        endMaker = new Node&lt;E&gt;(null, null);
        beginMaker = new Node&lt;E&gt;(null, endMaker);
        
        theSize =0;
    &#125;
    
    private Node&lt;E&gt; beginMaker;
    private Node&lt;E&gt; endMaker;
    private int theSize=0;
    
    @Override
    public Iterator&lt;E&gt; iterator() &#123;
        // TODO Auto-generated method stub
        return new MyListIterator();
    &#125;
    
&#125;
</code></pre>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><pre><code class="java">package DataStructure;


public class DoubleLinkDemo &#123;
    public static void main(String[] args) &#123;
        DoubleLinkList list = new DoubleLinkList();
        list.add(120,&quot;CSSE&quot;);
        list.add(399,&quot;ESL&quot;);
        list.add(220,&quot;CSSE&quot;);
        list.add(399,&quot;ESL&quot;);
        list.add(102,&quot;CSSE&quot;);
        list.add(221,&quot;MA&quot;);
        System.out.println(&quot;\tlist的大小：&quot;+list.size());
        System.out.println(&quot;\t正序打印&quot;);
        list.print();
        System.out.println(&quot;\t逆序打印&quot;);
        list.Rsprint();
        System.out.println(&quot;\t查找数据&quot;);
        Node[] array = list.search(&quot;CSSE&quot;);
        for(Node node:array) &#123;
            if(node!=null) &#123;
                System.out.println(node);
            &#125;
        &#125;
        System.out.println(&quot;\t删除数据&quot;);
        list.del(220);
        list.print();
        System.out.println(&quot;\t更改数据&quot;);
        list.update(new Node(221,&quot;MA&quot;), new Node(113,&quot;MA&quot;));
        list.print();
        
    &#125;
&#125;

class Node&#123;
    int num;
    String name;
    Node pre;
    Node next;
    Node(int num,String name)&#123;
        this.num = num;
        this.name =name;
        pre =null;
        next=null;
    &#125;
    @Override
    public String toString() &#123;
        return name+&quot; &quot;+num;
    &#125;
    @Override
    public boolean equals(Object obj) &#123;
        Node node = (Node)obj;
        return node.num == this.num&amp;&amp;node.name.equals(this.name);
    &#125;
    
    
&#125;

class DoubleLinkList&#123;
    private Node head;
    DoubleLinkList()&#123;
        head =null;
    &#125;
    //判空
    public boolean isempty() &#123;
        return head == null;
    &#125;
    
    //增
    public void add(int num,String name) &#123;
        Node node = new Node(num,name);
        if(isempty()) &#123;
            head = node;
            return;
        &#125;
        Node cur = head;
        while(cur.next!=null) &#123;
            if(cur.equals(node)) &#123;
                System.out.println(node+&quot; 节点已存在，无法添加&quot;);
                return;
            &#125;
            cur = cur.next;
        &#125;
        cur.next = node;
        node.pre = cur;
    &#125;
    
    //删
    //根据编号删除数据
    public void del(int num) &#123;
        Node cur = head;
        //数据为空
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        //数据在开头
        if(cur.num == num) &#123;
            head = cur.next;
            return;
        &#125;
        //数据在中间
        while(cur.next!=null) &#123;
            if(cur.num == num) &#123;
                cur.pre.next = cur.next;
                cur.next.pre = cur.pre;
                return;
            &#125;
            cur = cur.next;
        &#125;
        //数据在末尾
        if(cur.num == num) &#123;
            cur.pre.next= null;
            return;
        &#125;
        System.out.println(&quot;未找到相关数据&quot;);
    &#125;
    
    //改,更改数据
    public void update(Node Oldnode,Node Newnode) &#123;
        Node cur = head;
        //数据为空
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        //数据在开头
        if(cur.equals(Oldnode)) &#123;
            Newnode.next = cur.next;
            cur.next.pre = Newnode;
            head = Newnode;
            return;
        &#125;
        //数据在中间,数据在末尾
        while(cur!=null) &#123;
            if(cur.equals(Oldnode)) &#123;
                Newnode.next = cur.next;
                cur.pre.next = Newnode;
                Newnode.pre = cur.pre;
                return;
            &#125;
            cur = cur.next;
        &#125;
        System.out.println(&quot;未找到相关数据&quot;);
    &#125;
    
    //查
    //根据name查找数据
    public Node[] search(String name) &#123;
        Node cur = head;
        boolean exist = false;
        Node[] array = new Node[this.size()];
        int count=0;
        //数据为空
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return null;
        &#125;
        while(cur!=null) &#123;
            if(cur.name.equals(name)) &#123;
                array[count] = cur;
                exist =true;
                count++;
            &#125;
            cur = cur.next;
        &#125;
        if(!exist) &#123;
            System.out.println(&quot;未找到相关数据&quot;);
        &#125;
        return array;
    &#125;
    
    //list的大小
    public int size() &#123;
        int count=0;
        Node cur = head;
        while(cur!=null) &#123;
            cur = cur.next;
            count++;
        &#125;
        return count;
    &#125;
    
    //正遍历
    public void print() &#123;
        Node cur = head;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        while(cur!= null) &#123;
            System.out.println(cur);
            cur = cur.next;
        &#125;
    &#125;
    
    //逆遍历
    public void Rsprint() &#123;
        Node cur = head;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        while(cur.next!=null) &#123;
            cur = cur.next;
        &#125;
        while(cur!=null) &#123;
            System.out.println(cur);
            cur = cur.pre;
        &#125;
    &#125;
    
&#125;
</code></pre>
<h4 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h4><pre><code class="java">public class CircleLinkedListDemo &#123;
 public static void main(String[] args) &#123;
  CircleLinkedList list = new CircleLinkedList();
  for(int i=0;i&lt;5;i++) &#123;
   list.add(i);
  &#125;
  System.out.println(&quot;\t添加数据&quot;);
  list.print();
  System.out.println(&quot;\t删除头部数据&quot;);
  list.del(0);
  list.print();
  System.out.println(&quot;\t更改数据&quot;);
  list.update(new Node(3), new Node(0));
  list.print();
  System.out.println(&quot;\t查找数据，是否包含此数据&quot;);
  System.out.println(list.contains(3));
//  System.out.println(&quot;\t删除中间数据&quot;);
//  list.del(3);
//  list.print();
//  System.out.println(&quot;\t删除尾部数据&quot;);
//  list.del(4);
//  list.print();
&#125;
&#125;
</code></pre>
<pre><code class="java">class Node&#123;
 int num;
 Node next;
 Node(int num)&#123;
  this.num = num;
  next = null;
 &#125;
 @Override
 public boolean equals(Object obj) &#123;
  Node node =(Node) obj;
  return node.num == this.num;
 &#125;
 @Override
 public String toString() &#123;
  return num+&quot;&quot;;
 &#125;
 
&#125;
</code></pre>
<pre><code class="java">class CircleLinkedList&#123;
    private Node head;
    
    public CircleLinkedList() &#123;
        head = null;
    &#125;
    
    //判空
    public boolean isempty() &#123;
        return head == null;
    &#125;
    
    //增
    public void add(int num) &#123;
        Node node = new Node(num);
        //开始为空
        if(isempty()) &#123;
            head = node;
            node.next = head;
            return;
        &#125;
        //开始不为空
        Node cur = head;
        while(cur.next!=head) &#123;
            if(cur.equals(node)) &#123;
                System.out.println(&quot;此数据已存在&quot;);
                return;
            &#125;
            cur =cur.next;
        &#125;
        cur.next = node;
        node.next = head;
    &#125;
    
    //删
    public void del(int num) &#123;
        Node cur = head;
        //判空
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        
        while(cur.next!=head) &#123;
            if(cur.next.num == num) &#123;
                //数据在尾部
                if(cur.next.next == head) &#123;
                    cur.next = head;
                    return;
                &#125;
                cur.next = cur.next.next;
                return;
            &#125;
            cur = cur.next;
        &#125;
        //数据在头部,此时指针在尾部
        if(cur.next.num == num) &#123;
            head = head.next;
            cur.next = cur.next.next;
            return;
        &#125;
        System.out.println(&quot;未找到相关数据&quot;);
    &#125;
    
    //改
    public void update(Node OldNode, Node NewNode) &#123;
        Node cur = head;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        //中间与尾部
        while(cur.next != head) &#123;
            if(cur.next.equals(OldNode)) &#123;
                NewNode.next = cur.next.next;
                cur.next = NewNode;
                return;
            &#125;
            cur =cur.next;
        &#125;
        //数据在头部
        if(cur.next.equals(OldNode)) &#123;
            NewNode.next = head.next;
            head = NewNode;
            cur.next = head;
            return;
        &#125;
        System.out.println(&quot;未找到相关数据&quot;);

    &#125;
    
    //查
    public boolean contains(int num) &#123;
        Node cur = head;
        do&#123;
            if(cur.num == num) &#123;
                return true;
            &#125;
            cur=cur.next;
        &#125;while(cur!=head) ;
        return false;
    &#125;
    //遍历
    public void print() &#123;
        Node cur = head;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        do&#123;
            System.out.println(cur);
            cur = cur.next;
        &#125;while(cur!= head); 
    &#125;
</code></pre>
<h5 id="Josephus问题（约瑟夫问题）"><a href="#Josephus问题（约瑟夫问题）" class="headerlink" title="Josephus问题（约瑟夫问题）"></a>Josephus问题（约瑟夫问题）</h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>链表的学习比较抽象，刚开始接触会很懵，不知道哪个是哪个。多画图，多分析，对于链表的理解就会更加深刻。</p>
<h1 id="数据结构：栈"><a href="#数据结构：栈" class="headerlink" title="数据结构：栈"></a>数据结构：栈</h1><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>栈和队列一样是一种特殊的线性表结构，它的特点是先进后出（first in last out）。下面有一张图来描述栈</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210221105835749.png" alt="image-20210221105835749"></p>
<p>栈有两个常用方法</p>
<ul>
<li>pop()，出栈，从尾部弹出元素</li>
<li>push(int value)，压栈，把数据压入栈中</li>
</ul>
<h3 id="实现栈"><a href="#实现栈" class="headerlink" title="实现栈"></a>实现栈</h3><p>实现栈的方式有多种，我列举2种：一种是用数组来实现栈，还有一种是用链表来实现栈</p>
<ol>
<li>ArrayStack（数组）</li>
<li>LinkedListStack（链表）</li>
</ol>
<h4 id="ArrayStack"><a href="#ArrayStack" class="headerlink" title="ArrayStack"></a>ArrayStack</h4><pre><code class="java">package DataStructure;

public class ArrayStackDemo &#123;

    public static void main(String[] args) &#123;
        ArrayStack stack= new ArrayStack(3);
        System.out.println(&quot;\t压栈&quot;);
        stack.push(120);
        stack.push(220);
        stack.push(221);
        stack.push(449);
        System.out.println(&quot;\t打印栈元素&quot;);
        stack.print();
        try &#123;
            System.out.println(&quot;\t弹出栈元素&quot;);
            System.out.println(&quot;弹出的元素：&quot;+stack.pop());
        &#125;catch(Exception e) &#123;
            System.out.println(e.getMessage());
        &#125;
        System.out.println(&quot;\t弹出后的元素&quot;);
        stack.print();
    &#125;

&#125;

class ArrayStack&#123;
    private int MaxSize;
    private int top;//标号，默认为-1
    private int[] array;
    //构造器
    public ArrayStack(int size) &#123;
        MaxSize = size;
        top = -1;
        array = new int[MaxSize];
    &#125;
    
    //判空
    public boolean isempty() &#123;
        return top == -1;
    &#125;
    
    //判满
    public boolean isfull() &#123;
        //判断满，数组最后一位下标MaxSize-1
        return top == MaxSize -1;
    &#125;
    
    //入栈,压栈
    public void push(int value) &#123;
        if(isfull()) &#123;
            System.out.println(&quot;已满，无法添加元素:&quot;+value);
            return;
        &#125;
        top++;//压栈，先+1
        array[top] = value;//开始赋值
    &#125; 
    
    //出栈，弹出
    public int pop() &#123;
        if(isempty()) &#123;
            throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;);
        &#125;
        int value = array[top];
        top--;
        return value;
        
    &#125;
    
    //遍历栈，从上往下
    public void print() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;栈为空&quot;);
            return;
        &#125;
        for(int i=top;i&gt;=0;i--) &#123;
            System.out.printf(&quot;Stack[%d] = %d\n&quot;,i,array[i]);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210222214103653.png" alt="image-20210222214103653"></p>
<h4 id="LinkedListStack"><a href="#LinkedListStack" class="headerlink" title="LinkedListStack"></a>LinkedListStack</h4><pre><code class="java">package DataStructure;

public class LinkedListStackDemo &#123;
    public static void main(String[] args) &#123;
        LinkedListStack stack= new LinkedListStack(3);
        System.out.println(&quot;\t压栈&quot;);
        stack.push(120);
        stack.push(220);
        stack.push(221);
        stack.push(449);
        System.out.println(&quot;\t打印栈元素&quot;);
        stack.print();
        try &#123;
            System.out.println(&quot;\t弹出栈元素&quot;);
            System.out.println(&quot;弹出的元素：&quot;+stack.pop());
        &#125;catch(Exception e) &#123;
            System.out.println(e.getMessage());
        &#125;
        System.out.println(&quot;\t弹出后的元素&quot;);
        stack.print();
    &#125;

&#125;

class StackNode&#123;
    int value;
    StackNode next;
    public StackNode(int num) &#123;
        value = num;
        next = null;
    &#125;
    @Override
    public String toString() &#123;
        return value+&quot;&quot;;
    &#125;
    
&#125;
class LinkedListStack&#123;
    private int MaxSize;
    private StackNode head;
    //构造器
    public LinkedListStack(int size) &#123;
        MaxSize = size;
        head =null;
    &#125;
    
    //容器中元素个数
    public int size() &#123;
        int count =0;
        StackNode cur = head;
        while(cur != null) &#123;
            count ++;
            cur = cur.next;
        &#125;
        return count;
    &#125;
    
    //判空
    public boolean isempty() &#123;
        return head == null;
    &#125;
    
    //判满
    public boolean isfull() &#123;
        return size() == MaxSize;
    &#125;
    
    //压栈
    public void push(int value) &#123;
        StackNode node = new StackNode(value);
        if(isempty()) &#123;
            head = node;
            return;
        &#125;
        if(isfull()) &#123;
            System.out.println(&quot;已满，无法添加元素:&quot;+value);
            return;
        &#125;
        StackNode cur = head;
        while(cur.next != null) &#123;
            cur = cur.next;
        &#125;
        cur.next = node;
    &#125;
    
    //出栈
    public StackNode pop() &#123;
        if(isempty()) &#123;
            throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;);
        &#125;
        
        StackNode pre = head;
        if(size()==1) &#123;
            head = null;
            return pre;
        &#125;
        StackNode cur = pre.next;
        while(cur.next != null) &#123;
            pre = pre.next;
            cur = cur.next;
        &#125;
        StackNode temp = cur;
        pre.next = null;
        return temp;
    &#125;
    
    //从上到下遍历
    public void print() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;栈为空&quot;);
            return;
        &#125;
        LinkedListStack container = new LinkedListStack(size());
        StackNode cur = head;
        while(cur!=null) &#123;
            container.push(cur.value);
            cur = cur.next;
        &#125;
        while(container.size()&gt;0) &#123;
            System.out.println(container.pop());
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210222214114768.png" alt="image-20210222214114768"></p>
<h4 id="LinkedListStack-改进版"><a href="#LinkedListStack-改进版" class="headerlink" title="LinkedListStack 改进版"></a>LinkedListStack 改进版</h4><p>由于Stack First In Last Out的性质， 我们可以对之前的LinkedListStack进行优化，当pop或push元素时我们只操纵第一个元素，如下</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210508162348272.png" alt="image-20210508162348272"></p>
<p>下面是代码实现</p>
<pre><code class="java">package DataStructure;

import java.util.AbstractList;

public class LinkedListStackDemo2&lt;E&gt;&#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        LinkedListStackDemo2&lt;Integer&gt; stack= new LinkedListStackDemo2&lt;&gt;();
        System.out.println(&quot;\t压栈&quot;);
        stack.push(120);
        stack.push(220);
        stack.push(221);
        stack.push(449);
        
        System.out.println(&quot;ShowAll&quot;);
        stack.ShowAll();
        
        System.out.println(&quot;Size&quot;);
        System.out.println(stack.Size);
        
        System.out.println(&quot;出栈&quot;);
        System.out.println(stack.pop());
        
        System.out.println(&quot;Size&quot;);
        System.out.println(stack.Size);
        
        System.out.println(&quot;Peek&quot;);
        System.out.println(stack.peek());

    &#125;
    
    private Node&lt;E&gt; head=null;
    private int Size=0;
    
//    Return the Size of this Queue
    public int size() &#123;
        return Size;
    &#125;
    
//    Return whether this queue is Empty
    public boolean isEmpty() &#123;
        return head == null;
    &#125;
    
//    Add new item into the queue
    public void push(E item) &#123;
        if(isEmpty()) &#123;
            head = new Node&lt;&gt;(item);
            Size++;
            return;
        &#125;
        
        head = new Node&lt;&gt;(item, head);
        Size++;
    &#125;
    
//    Return the top data
    public Node&lt;E&gt; peek() &#123;
        if(isEmpty())
            return null;
        return new Node&lt;&gt;(head.data);
    &#125;
    
//    Return the top data
    public Node&lt;E&gt; pop()&#123;
        Node&lt;E&gt; temp = head;
        if(!isEmpty()) &#123;
            head = head.next;
            Size--;
        &#125;
        return temp;
    &#125;
    
//    Show all the items in the stack
    public void ShowAll() &#123;
        ShowAll(head);
    &#125;
    
//    Internal Method For Showing the items
    private void ShowAll(Node&lt;E&gt; root) &#123;
        if(root == null)
            return;
        else &#123;
            System.out.println(root);
            ShowAll(root.next);
        &#125;
    &#125;
    
    private static class Node&lt;E&gt;&#123;
        E data;
        Node&lt;E&gt; next;
        public Node(E d) &#123;
            data =d;
            next =null;
        &#125;
        
        public Node(E d, Node&lt;E&gt; n) &#123;
            data =d;
            next =n;
        &#125;

        @Override
        public String toString() &#123;
            // TODO Auto-generated method stub
            return &quot;[ data: &quot;+data+&quot; ]&quot;;
        &#125;
        
        
    &#125;
    

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210508210722123.png" alt="image-20210508210722123"></p>
<h3 id="LinkedListStack时间复杂度"><a href="#LinkedListStack时间复杂度" class="headerlink" title="LinkedListStack时间复杂度"></a>LinkedListStack时间复杂度</h3><p>这种方法实现的栈，入栈，出栈，效率大大提升(因为每次都只是在头部操作)</p>
<p>入栈时，时间复杂度为O(1)</p>
<p>出栈，时间复杂度也为O(1)</p>
<p>查询Size，同样是O(1)</p>
<h3 id="用栈来实现计算器"><a href="#用栈来实现计算器" class="headerlink" title="用栈来实现计算器"></a>用栈来实现计算器</h3><p>本计算器支持正整数的加减乘除运算</p>
<h4 id="包含的知识"><a href="#包含的知识" class="headerlink" title="包含的知识"></a>包含的知识</h4><ol>
<li>字符串转化为字符数组</li>
<li>字符与double类型数据间的转换</li>
<li>栈的pop与push</li>
<li>链表栈（本计算器是通过链表栈来实现的）</li>
<li>优先级判断</li>
</ol>
<p>输入数字与符号给计算器时，计算器会考虑符号的优先级，例如乘号优先级&gt;减号的优先级；</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>当我们从控制台输入一连串字符时，我们的程序需要对字符串进行拆解，</li>
<li>for循环区分数字与符号，然后将内容分别压入数字栈与符号栈；</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210222213634717.png" alt="image-20210222213634717"></p>
<ol start="3">
<li><p>使用while循环遍历符号栈，当符号栈为空时，运算终止</p>
</li>
<li><p>循环时，我们分别从符号栈和数字栈中pop出元素：num1, num2, operator; 计算完后再push入数字栈中（即计算完的值代替了原来的两个num）；通过循环进行最终得出最后的答案。</p>
</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210222213721057.png" alt="image-20210222213721057"></p>
<ol start="5">
<li>进行计算之前要先判断优先级，例如:”6X6-5”，我们需要先看一下符号栈后一个符号优先级是否大于即将pop的；如果是，我们要将他们数字与符号调换一下顺序：5-6X6 ，由于另一个符号是减号，我们要将减号改为+，其中一个数字乘上-1：-5+6X6</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210222213749453.png" alt="image-20210222213749453"></p>
<ol start="6">
<li>直到循环结束，numStack中的最后一个元素就是最终的答案.</li>
</ol>
<p>本计算器使用上面的链表栈来实现的，其中节点稍作改动，节点接收double类型数据，因为我们不知道用户输入的数字个数具体有多少，所以此链表栈没有isfull（判满）。</p>
<p>在链表栈中，我们还增添了peek方法，用于查看倒数第2个符号是什么（判断优先级）</p>
<pre><code class="java">package DataStructure;

import java.util.Arrays;
import java.util.Scanner;

public class StackCalculatorDemo &#123;
    public static void main(String[] args) &#123;
        Scanner input = new Scanner(System.in);
        System.out.print(&quot;please input the operation equation: &quot;);
        String expression = input.next();
        Calculator cal = new Calculator();
        cal.process(expression);
        input.close();
    &#125;
&#125;

class NumNode&#123;
    double value;
    NumNode next;
    public NumNode(double num) &#123;
        value = num;
        next = null;
    &#125;
    @Override
    public String toString() &#123;
        return value+&quot;&quot;;
    &#125;
    
&#125;

class Stack&#123;
    private NumNode head = null;
    //容器中元素个数
    public int size() &#123;
        int count =0;
        NumNode cur = head;
        while(cur != null) &#123;
            count ++;
            cur = cur.next;
        &#125;
        return count;
    &#125;
    
    //判空
    public boolean isempty() &#123;
        return head == null;
    &#125;
    
    
    //压栈
    public void push(double value) &#123;
        NumNode node = new NumNode(value);
        if(isempty()) &#123;
            head = node;
            return;
        &#125;
        
        NumNode cur = head;
        while(cur.next != null) &#123;
            cur = cur.next;
        &#125;
        cur.next = node;
    &#125;
    
    //出栈
    public NumNode pop() &#123;
        if(isempty()) &#123;
            throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;);
        &#125;
        
        NumNode pre = head;
        if(size()==1) &#123;
            head = null;
            return pre;
        &#125;
        NumNode cur = pre.next;
        while(cur.next != null) &#123;
            pre = pre.next;
            cur = cur.next;
        &#125;
        NumNode temp = cur;
        pre.next = null;
        return temp;
    &#125;
    
    //查看倒数第2个元素，但是不弹出
    public NumNode peek() &#123;
        if(isempty()) &#123;
            throw new RuntimeException(&quot;栈为空，无法弹出元素&quot;);
        &#125;
        
        NumNode pre = head;
        if(size()==1) &#123;
            return pre;
        &#125;
        NumNode cur = pre.next;
        while(cur.next != null) &#123;
            pre = pre.next;
            cur = cur.next;
        &#125;
        return pre;
    &#125;
    
    //从上到下遍历
    public void print() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;栈为空&quot;);
            return;
        &#125;
        Stack container = new Stack();
        NumNode cur = head;
        while(cur!=null) &#123;
            container.push(cur.value);
            cur = cur.next;
        &#125;
        while(container.size()&gt;0) &#123;
            System.out.println(container.pop());
        &#125;
    &#125;
    
&#125;

class Calculator&#123;
    public void process(String question) &#123;
//        String question = &quot;7*88+6*6-5/10&quot;;
        //将输入的字符串转为数组
        char[] array = question.toCharArray();
        
//        System.out.println(Arrays.toString(array));
        
        //创建2个栈，一个用于存储符号，另一个用于存储数字
        Stack operStack = new Stack();
        Stack numStack = new Stack();
        //number字符串用于存储多位数字的字符
        String number =&quot;&quot;;
        //for循环遍历一遍
        for(char i: array) &#123;
            //通过字符判断是否为数字，
            if(Character.isDigit(i)) &#123;
                number += i;
            &#125;
            else &#123;
                numStack.push(Integer.valueOf(number));
                number=&quot;&quot;;
                operStack.push(i);
            &#125;
        &#125;
        //由于最后一个是数字，for循环最后一遍未压入数字栈，需要手动压入
        numStack.push(Integer.valueOf(number));
        
        //当最后一个符号栈遍历完，运算结束
        while(!operStack.isempty()) &#123;
            char nextOpe = (char)operStack.peek().value;
            //判断优先级
            if(priority(nextOpe) == 1) &#123;
//                System.out.println(&quot;数字&quot;);
//                numStack.print();
//                System.out.println(&quot;符号&quot;);
//                operStack.print();
                double num1 = numStack.pop().value;
                double num2 = numStack.pop().value;
                double num3 = numStack.pop().value;
                double ope1 = operStack.pop().value;
                //看下一个是否是‘-’号，
                if((char) ope1 == &#39;-&#39;) &#123;
                    //更改符号，改变数字正负
                    ope1 = (int)&#39;+&#39;;
                    num1*=-1;
                &#125;
                double ope2 = operStack.pop().value;
                
                numStack.push(num1);
                numStack.push(num3);
                numStack.push(num2);
                operStack.push(ope1);
                operStack.push(ope2);    
            &#125;
            double num1 = numStack.pop().value;
            double num2 = numStack.pop().value;
            char ope = (char)operStack.pop().value;
            Double rst = cal(num1, num2, ope);
            numStack.push(rst);
        &#125;
        System.out.println(&quot;答案是：&quot;+numStack.pop());

    &#125;
    
    //计算过程，使用switch case
    public double cal(double num1, double num2, char ope) &#123;
        double rst =0;
        switch (ope) &#123;
        case &#39;*&#39;:
            rst = num2*num1;
            break;
        case &#39;/&#39;:
            rst = num2*1.0/num1;
            break;
        case &#39;+&#39;:
            rst = num2+num1;
            break;
        case &#39;-&#39;:
            rst = num2-num1;
            break;
    
        default:
            break;
        &#125;
        return rst;
    &#125;
    
//优先级判断
    public int priority(char ope) &#123;
        if(ope == &#39;*&#39; || ope==&#39;/&#39;) &#123;
            return 1;
        &#125;
        else if(ope == &#39;+&#39; || ope ==&#39;-&#39;) &#123;
            return 0;
        &#125;
        else &#123;
            return -1;
        &#125;
    &#125;
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210223185107177.png" alt="image-20210223185107177"></p>
<h3 id="前、中、后缀表达式（波兰、逆波兰计算器）"><a href="#前、中、后缀表达式（波兰、逆波兰计算器）" class="headerlink" title="前、中、后缀表达式（波兰、逆波兰计算器）"></a>前、中、后缀表达式（波兰、逆波兰计算器）</h3><p>式子：3+(7+8)x4-6</p>
<p>按照我们常规的计算方法，我们从左往右计算，看到括号先计算括号里面的数，再根据优先级算其他的数字；这就是所谓的<strong>中缀表达式</strong> </p>
<p><strong>前缀表达式</strong>是把符号置于数字的左侧，以上面式子为例：**+3-x+7846**。当计算时，我们从右往左把数字压入栈中，顺序依次是：6-&gt;4-&gt;8-&gt;7（此时7在栈顶）；接着我们依次从栈中弹出2个元素：7和8，然后读取第一个符号进行计算。计算结果再压入栈中，依次循环，如果下一个是数字，压入栈中直到读取完最后一个符号。</p>
<p><strong>前缀表达式</strong>又称<strong>波兰表达式</strong>，是波兰逻辑学家J·Lukasiewicz所发现的。</p>
<p>因为前缀表达式是从右往左扫描，数字和符号有自己的讲究，不能乱放（要按照优先级：括号&gt;乘号&gt;加号）。</p>
<p><strong>后缀表达式</strong>被称为<strong>逆波兰表达式</strong>。和前缀表达式相似，后缀表达式的符号在数字的后面；</p>
<p>继续以上面的式子为例：**378+4x+6-**。</p>
<p>讲了这么多，既然中缀表达式与我们生活中使用的计算方式一样，为什么还要学前缀与后缀表达式呢？</p>
<p>由于计算机是线性思维，它无法立刻发现括号等，所以使用中缀表达式不好操作；相反用后缀或前缀表达式可以解决这个问题，计算机只用从前往后读，或从后往前读就行，这样可以方便检索运算。</p>
<h5 id="后缀表达式实现（逆波兰表达式）"><a href="#后缀表达式实现（逆波兰表达式）" class="headerlink" title="后缀表达式实现（逆波兰表达式）"></a>后缀表达式实现（逆波兰表达式）</h5><ol>
<li>后缀表达式从左向右扫描，如果遇到数字，将数字压入栈中</li>
<li>倘若遇到运算符，弹出2个数字，进行运算，运算后的结果压入栈</li>
<li>下一个是数字，再压入栈中，直到遇到运算符号</li>
<li>依次循环，向后遍历，直到最后一个符号被遍历完</li>
<li>最终存在栈中的元素就是计算的结果</li>
</ol>
<p>先从中缀转后缀</p>
<pre><code class="java">package DataStructure;

import java.util.Stack;

public class PostfixDemo &#123;
    public static void main(String[] args) &#123;
        PolanCal cal = new PolanCal(&quot;3+(7+8)*4-6&quot;);
        cal.ToPostExpression();
        System.out.println(cal.output);
    &#125;
&#125;

class PolanCal&#123;
    String input;//中缀表达式
    String output = &quot;&quot;;//后缀表达式
    Stack&lt;Character&gt; TempStack = new Stack&lt;&gt;(); //用于暂时存储中缀转后缀的符号
    PolanCal(String input)&#123;
        this.input = input;
    &#125;
    public void ToPostExpression() &#123;
        //3+(7+8)*4-6
        //378+4*+6-
        char[] words = this.input.toCharArray();
        for(char i:words) &#123;
            switch (i) &#123;
            case &#39;+&#39;:
            case &#39;-&#39;:
                Prio(i,1);//优先级判断
                break;
            case &#39;*&#39;:
            case &#39;/&#39;:
                Prio(i,2);
                break;
            case &#39;(&#39;:
                TempStack.push(i);
                break;
            case &#39;)&#39;:
                while(!TempStack.isEmpty()) &#123;
                    //遍历，将括号间的符号加入到output
                    char operator = TempStack.pop();
                    if(operator ==&#39;(&#39;) &#123;
                        break;
                    &#125;
                    else &#123;
                        output += operator;
                    &#125;
                &#125;
                break;
            default:
                //读取的是数字就直接加入到output字符串中
                output += i;
                break;
            &#125;
        &#125;
        //遍历完后，将暂时栈里面的符号弹出，存入到output
        while(!TempStack.isEmpty()) &#123;
            output += TempStack.pop();
        &#125;
        
    &#125;
    public void Prio(char oper1, int priority1) &#123;
        while(!TempStack.isEmpty()) &#123;
            char onTop = TempStack.pop();//弹出位于栈顶部的符号
            if(onTop ==&#39;(&#39;) &#123;//如果栈顶的是前括号，就不弹出
                TempStack.push(onTop);
                break;//将输入的符号压入栈中
            &#125;
            else &#123;
                //要比较栈顶的符号与输入的符号哪个优先级大
                int priority2;
                if(onTop ==&#39;+&#39;||onTop==&#39;-&#39;) &#123;
                    priority2 = 1;
                &#125;
                else &#123;
                    priority2 = 2;
                &#125;
                //栈顶符号优先级小于输入的优先级
                //符号还原，不pop
                if(priority2 &lt; priority1) &#123;
                    TempStack.push(onTop);
                    break;
                &#125;
                else &#123;
                    output += onTop;
                &#125;
            &#125;
        &#125;
        
        TempStack.push(oper1);
    &#125;
    
    
&#125;
</code></pre>
<p>实现中缀转后缀之后，现在要实现计算过程</p>
<p>其中有些代码稍作了改动</p>
<ol>
<li>原来的中缀无法转多位数字，现在支持多位中缀转后缀：“3+(7+89)*4-66+8”</li>
<li>为了处理数据方便，后缀表达式各符号用空格分开</li>
</ol>
<pre><code class="java">package DataStructure;

import java.util.Arrays;
import java.util.Stack;

public class PostfixDemo &#123;
    public static void main(String[] args) &#123;
        PolanCal cal = new PolanCal(&quot;3+(7+89)*4-66+8&quot;);
        cal.ToPostExpression();
        System.out.println(&quot;转逆波兰后缀表达式：&quot;+cal.output);
        cal.StartCal();
    &#125;
&#125;

class PolanCal &#123;
    String input;// 中缀表达式
    String output = &quot;&quot;;// 后缀表达式
    Stack&lt;Character&gt; TempStack = new Stack&lt;&gt;(); // 用于暂时存储中缀转后缀的符号

    PolanCal(String input) &#123;
        this.input = input;
    &#125;

    public void ToPostExpression() &#123;
        // 3+(7+8)*4-6
        // 378+4*+6-
        char[] words = this.input.toCharArray();
        for (int i=0;i&lt;words.length;i++) &#123;
            char word =words[i];
            switch (word) &#123;
            case &#39;+&#39;:
            case &#39;-&#39;:
                Prio(word, 1);// 优先级判断
                break;
            case &#39;*&#39;:
            case &#39;/&#39;:
                Prio(word, 2);
                break;
            case &#39;(&#39;:
                TempStack.push(word);
                break;
            case &#39;)&#39;:
                while (!TempStack.isEmpty()) &#123;
                    char operator = TempStack.pop();
                    if (operator == &#39;(&#39;) &#123;
                        break;
                    &#125; else &#123;
                        output += operator + &quot; &quot;;
                    &#125;
                &#125;
                break;
            default:
                // 读取的是数字就直接加入到output字符串中
                output += word;
                if(i&lt;words.length-1&amp;&amp;!Character.isDigit(words[i+1])) &#123;
                    output +=&quot; &quot;;
                &#125;
                break;
            &#125;
        &#125;
        // 遍历完后，将暂时栈里面的符号弹出，存入到output
        output+=&quot; &quot;;
        while (!TempStack.isEmpty()) &#123;
            output += TempStack.pop();
        &#125;

    &#125;

    public void Prio(char oper1, int priority1) &#123;
        while (!TempStack.isEmpty()) &#123;
            char onTop = TempStack.pop();// 弹出位于栈顶部的符号
            if (onTop == &#39;(&#39;) &#123;// 如果栈顶的是前括号，就不弹出
                TempStack.push(onTop);
                break;// 将输入的符号压入栈中
            &#125; else &#123;
                // 要比较栈顶的符号与输入的符号哪个优先级大
                int priority2;
                if (onTop == &#39;+&#39; || onTop == &#39;-&#39;) &#123;
                    priority2 = 1;
                &#125; else &#123;
                    priority2 = 2;
                &#125;
                // 栈顶符号优先级小于输入的优先级
                // 符号还原，不pop
                if (priority2 &lt; priority1) &#123;
                    TempStack.push(onTop);
                    break;
                &#125; else &#123;
                    output += onTop + &quot; &quot;;
                &#125;
            &#125;
        &#125;

        TempStack.push(oper1);
    &#125;

    public void StartCal() &#123;
        String[] nums = output.split(&quot; &quot;);
        Stack&lt;Double&gt; numStack = new Stack&lt;&gt;();
        for (String i : nums) &#123;
            if (isNumeric(i)) &#123;
                numStack.push(Double.valueOf(i));
            &#125; else &#123;
                double num1 = numStack.pop();
                double num2 = numStack.pop();
                double rst =0;
                if(i.equals(&quot;+&quot;)) &#123;
                    rst = num2+num1;
                &#125;else if(i.equals(&quot;-&quot;)) &#123;
                    rst = num2-num1;
                &#125;else if(i.equals(&quot;*&quot;)) &#123;
                    rst = num2*num1;
                &#125;else if(i.equals(&quot;/&quot;)) &#123;
                    rst = num2*1.0/num1;
                &#125;
                numStack.push(Double.valueOf(rst));
            &#125;
        &#125;
        System.out.println(&quot;最终计算结果：&quot;+numStack.pop());
    &#125;
    
    public static boolean isNumeric(String str)&#123;
        for (int i = str.length();--i&gt;=0;)&#123;  
             if (!Character.isDigit(str.charAt(i)))&#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210223224626197.png" alt="image-20210223224626197"></p>
<h1 id="数据结构：队列Queue"><a href="#数据结构：队列Queue" class="headerlink" title="数据结构：队列Queue"></a>数据结构：队列Queue</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><p>与Stack栈相反，队列是First In First Out，像排队一样，在Java util包中，LinkedList就是一个Queue队列</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>为了方便查找开头与结尾，我们在队列的头和尾都用2个Node来指向</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210508212901468.png" alt="image-20210508212901468"></p>
<p>当我们使用这种方法实现队列，同样，时间复杂度为O(1),插入和删除</p>
<p>具体我就不实现了，其实和Stack大同小异</p>
<h1 id="数据结构：哈希表-HashTable"><a href="#数据结构：哈希表-HashTable" class="headerlink" title="数据结构：哈希表 HashTable"></a>数据结构：哈希表 HashTable</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><p>HashTable是常见的数据结构，就像Set，List，Collition。哈希表常用于缓存中，功能与Raddis相似，但是后者比前者更强。哈希表是根据键值对来访问数据，（key）。HashTable一般由数组与链表所构成，如图</p>
<img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/Users\23881\Desktop\Self_study\Java基础\哈希表.jpg" style="zoom:150%;">

<p>每个数组元素都是由链表所构成，当存储数据时，根据散列函数我们选择对应的链表，将节点数据存入链表中。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>为了实现哈希表，先创建一个节点</p>
<p>因为是键值对的形式，我们的节点要有2个部分，1个key，1个value</p>
<pre><code class="java">//因为key值是独一无二的，ID就是key, name就是value
class NameNode&#123;
    int num;
    String name;
    NameNode next;
    NameNode(int num, String name)&#123;
        this.num = num;
        this.name = name;
        next = null;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;[ ID: &quot;+num+&quot;, Name: &quot;+name+&quot; ]&quot;;
    &#125;
    
    
&#125;
</code></pre>
<p>链表类</p>
<pre><code class="java">//List链表实现功能：增删遍历。当增添时不能增添已有ID，（满足key-value原则）
class List&#123;
    NameNode head;
    List()&#123;
        head = null;
    &#125;
    
    public boolean isempty() &#123;
        return head == null;
    &#125;
    
    public void add(NameNode node) &#123;
        if(isempty()) &#123;
            head = node;
            return;
        &#125;
        if(isExist(node)) &#123;
            System.out.println(&quot;ID已存在，请重新输入&quot;);
            return;
        &#125;
        NameNode cur = head;
        while(cur.next != null) &#123;
            cur = cur.next;
        &#125;
        
        cur.next = node;
    &#125;
    
    public boolean isExist(NameNode node) &#123;
        NameNode cur = head;
        while(cur != null) &#123;
            if(node.num == cur.num) &#123;
                return true;
            &#125;
            cur = cur.next;
        &#125;
        return false;
    &#125;
    
    public void delete(NameNode node) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        

        NameNode cur = head;
        if(cur.num == node.num) &#123;
            head = cur.next;
            System.out.println(&quot;删除完毕&quot;);
            return;
        &#125;
        do &#123;
            NameNode pre =cur;
            cur =cur.next;
            if(cur.num == node.num) &#123;
                pre.next = cur.next;
                System.out.println(&quot;删除完毕&quot;);
                return;
            &#125;
        &#125;while(cur != null);
        System.out.println(&quot;没有相关元素ID&quot;);
    &#125;
    
    
    public void print() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;链表为空&quot;);
            return;
        &#125;
        
        NameNode cur = head;
        while(cur != null)&#123;
            System.out.print(cur+&quot; ~&quot;);
            cur = cur.next;
        &#125;
        System.out.println();
    &#125;
    
    
    
&#125;
</code></pre>
<p>当我们使用HashTable时，我们使用的时HashTable而不是LinkedList，所以要再创建一个HashTable类</p>
<pre><code class="java">class HashTable&#123;
    private int size;
    List[] table; //这个就是哈希表中的数组
    HashTable(int size)&#123;
        //根据传进去的size我们定义hashtable的大小
        this.size =size;
        table  = new List[size];
        //初始化table数组，因为前面虽然创建，但是没有初始化，编译器会识别为null
        for(int i=0;i&lt; size;i++) &#123;
            table[i] = new List();
        &#125;
    &#125;
    
    public void add(NameNode sb) &#123;
        int no = fintable(sb.num);
        table[no].add(sb);
    &#125;
    
    public void print() &#123;
        for(int i=0;i&lt;size;i++) &#123;
            System.out.print(&quot;第&quot;+(i+1)+&quot;行： &quot;);
            table[i].print();
        &#125;
    &#125;
    
    public void delete(NameNode node) &#123;
        int no = fintable(node.num);
        table[no].delete(node);
    &#125;
    
    //散列函数，最简单的散列函数就是取模，%
    public int fintable(int num) &#123;
        return num % size;
    &#125;
    
    
&#125;
</code></pre>
<p>测试类</p>
<p>写一个循环，让用户选择是要Add，Delete，还是print</p>
<pre><code class="java">public class HashTableDemo1 &#123;
    public static void main(String[] args) &#123;
        HashTable table = new HashTable(5);
        Scanner scanner = new Scanner(System.in);
        String input=&quot;&quot;;
        while(input !=&quot;exit&quot;) &#123;
            System.out.println(&quot;Add 添加用户&quot;);
            System.out.println(&quot;Print 打印用户&quot;);
            System.out.println(&quot;Delete 删除用户&quot;);
            System.out.println(&quot;Exit 退出&quot;);
            input = scanner.next();
            switch (input) &#123;
            case &quot;Add&quot;:
                System.out.print(&quot;用户ID：&quot;);
                int id = scanner.nextInt();
                System.out.print(&quot;用户姓名：&quot;);
                String name = scanner.next();
                table.add(new NameNode(id, name));
                System.out.println();
                break;
            case &quot;Print&quot;:
                System.out.println(&quot;列表如下&quot;);
                table.print();
                System.out.println();
                break;
            case &quot;Delete&quot;:
                System.out.print(&quot;删除用户的ID： &quot;);
                int num = scanner.nextInt();
                table.delete(new NameNode(num, &quot;&quot;));
                System.out.println();
                break;
            case &quot;Exit&quot;:
                scanner.close();
                System.exit(1);
                break;
            default:
                break;
            &#125;
            
        &#125;
    &#125;
&#125;
</code></pre>
<h1 id="数据结构：树"><a href="#数据结构：树" class="headerlink" title="数据结构：树"></a>数据结构：树</h1><p>我们在使用其他数据结构，例如数组和链表多少会有些缺陷；数组虽然可以通过下标快速定位到数据，但是在增删数据会有缺陷，因为数组大小一开始就固定好了，当数组满时在增添需要开辟更大的空间然后复制内容，这样会浪费空间且麻烦；同样链表也有缺陷，虽然链表增删快且方便，但是为了查找一个数据我们需要遍历整个链表去寻找，这样速度可能会比较慢。为了解决这些问题，大佬们创建了树，如下：</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E6%A0%91.jpg"></p>
<p>上面的树是二叉树，树的一种；其继承了二分查找与链表的优点：易增删，查找快</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>空树：没有任何结点</p>
<p>叶/叶结点：位于末梢的结点</p>
<p>父结点：后面继承了结点的结点</p>
<p>兄弟结点：拥有相同的父结点</p>
<p>深度：树的层数，以上面图为例，深度为4，有4层</p>
<p>节点：等于结点，英文名 Node</p>
<p>完全二叉树：对于k层的完全二叉树，节点数的范围2^ (k - 1) -1 &lt; N&lt; 2^k - 1;</p>
<h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>二叉树顾名思义，有2个叉的树，基本思路与树相同</p>
<p>二叉树遍历分为前序，中序还有后序；</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210309162811510.png" alt="image-20210309162811510"></p>
<p>前序：遍历先中间，左边再右边</p>
<p>ABDHECFG</p>
<p>中序：遍历先左边，中间再右边</p>
<p>HDBEAFCG</p>
<p>后序：遍历先左边，右边再中间</p>
<p>HDEBFGCA</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先需要创建一个树结点</p>
<p>前序、中序、后序的区别在于打印的不同</p>
<pre><code class="java">class TreeNode_1&#123;
    char word;
    TreeNode_1 left;
    TreeNode_1 right;
    TreeNode_1(char word)&#123;
        this.word = word;
    &#125;
    @Override
    public String toString() &#123;
        // TODO Auto-generated method stub
        return word+&quot;&quot;;
    &#125;
    
    //前序遍历
    public void preOrder() &#123;
        System.out.print(this);
        if(this.left != null) &#123;
            this.left.preOrder();
        &#125;
        if(this.right != null) &#123;
            this.right.preOrder();
        &#125;
    &#125;
    
    //中序遍历
    public void infixOrder() &#123;
        //先向左递归
        if(this.left !=null) &#123;
            this.left.infixOrder();
        &#125;
        //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个
        System.out.print(this);
        
        //然后递归右结点
        if(this.right!=null) &#123;
            this.right.infixOrder();
        &#125;
    &#125;
    
    //后序遍历
    public void postOrder() &#123;
        if(this.left != null) &#123;
            this.left.postOrder();
        &#125;
        
        if(this.right != null) &#123;
            this.right.postOrder();
        &#125;
        System.out.print(this);
    &#125;
    
&#125;
</code></pre>
<p>建立一个二叉树类</p>
<pre><code class="java">class BinaryTree_1&#123;
    private TreeNode_1 root;
    BinaryTree_1()&#123;
        root = null;
    &#125;
    BinaryTree_1(TreeNode_1 root)&#123;
        this.root =root;
    &#125;
    
    public boolean isempty() &#123;
        return root == null;
    &#125;
&#125;
</code></pre>
<p>二叉树的遍历方法，前，中，后序遍历</p>
<pre><code class="java">    //前序遍历
    public void preOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.preOrder();
        System.out.println();
    &#125;
    
    //中序遍历
    public void infixOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.infixOrder();
        System.out.println();
    &#125;
    
    //后序遍历
    public void postOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.postOrder();
        System.out.println();
    &#125;
</code></pre>
<p>添加元素</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210309162811510.png"></p>
<p>在上面一个二叉树中，我们从上往下，从左往右判断是否应该添加元素</p>
<p>先添加元素A，由于开始为空，root结点直接指向A</p>
<p>读取A，判断A左和右侧是否为null, 左侧为null，就添加B，右侧为null，就添加C</p>
<p>我们要一层一层往下读取，这个就是：广度优先遍历（层次遍历）【横向为广度，纵向为深度】</p>
<p>怎么才能确保先取出A，再取出B，接着取出C呢？</p>
<p>这个需要用到队列</p>
<p>假设这个树最初有0个元素，我们要增添A,B,C,D</p>
<p>第1次</p>
<p>初始为空，root直接指向A</p>
<p>先把root加入到队列中,   [ A ]</p>
<p>弹出队列中第一个元素，此时是A</p>
<p>遍历如果A的左边为null, A.left指向添加的元素</p>
<p>再次循环，第2次</p>
<p>初始为1，把root加入到队列中[ A ]</p>
<p>弹出第一个元素A</p>
<p>A左边不为null, 把左边的元素压入 [B]</p>
<p>再判断A右边是否为null，右边是null,A.right 指向C</p>
<p>循环，第3次</p>
<p>初始为1，把root加入到队列中[ A ]</p>
<p>弹出第一个元素A</p>
<p>A左边不为null, 把左边的元素压入 [B]</p>
<p>再判断A右边是否为null，右边是C, 把C压入队列 [ B, C]</p>
<p>pop弹出队列第一个元素，B</p>
<p>判断B左侧是否为null, 是null, B.left 指向D</p>
<p>……</p>
<p>下面是add方法代码实现</p>
<pre><code class="java">public void add(TreeNode_1 node) &#123;
    if(isempty()) &#123;
        root = node;
        return;
    &#125;
    LinkedList&lt;TreeNode_1&gt; queue = new LinkedList&lt;&gt;();
    queue.add(root);
    while(!queue.isEmpty()) &#123;
        TreeNode_1 cur = queue.pop();
        if(cur.left == null) &#123;
            cur.left = node;
            return;
        &#125;else &#123;
            queue.add(cur.left);
        &#125;
        if(cur.right == null) &#123;
            cur.right = node;
            return;
        &#125;else &#123;
            queue.add(cur.right);
        &#125;
    &#125;
&#125;
</code></pre>
<p>查找元素</p>
<pre><code class="java">//前序遍历
public boolean preSearch(TreeNode_1 node) &#123;
    boolean rst =false;
    System.out.println(this+&quot; &quot;+node);
    if(this.word == node.word) &#123;
        return true;
    &#125;

    if(this.left != null) &#123;
        rst = this.left.preSearch(node);
    &#125;

    if(rst == true) &#123;
        return rst;
    &#125;

    if(this.right != null) &#123;
        rst = this.right.preSearch(node);
    &#125;


    return rst;
&#125;

//中序遍历
public boolean infixSearch(TreeNode_1 node) &#123;
    boolean rst =false;
    //先向左递归
    if(this.left !=null) &#123;
        rst = this.left.infixSearch(node);
    &#125;
    if(rst == true) &#123;
        return rst;
    &#125;
    //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个
    System.out.println(this+&quot; &quot;+node);
    if(this.word == node.word) &#123;
        return true;
    &#125;

    //然后递归右结点
    if(this.right!=null) &#123;
        rst = this.right.infixSearch(node);
    &#125;
    return rst;
&#125;

//后序遍历
public boolean postSearch(TreeNode_1 node) &#123;
    boolean rst = false;
    if(this.left != null) &#123;
        rst = this.left.postSearch(node);
    &#125;
    if(rst == true) &#123;
        return rst;
    &#125;
    if(this.right != null) &#123;
        rst = this.right.postSearch(node);
    &#125;
    System.out.println(this+&quot; &quot;+node);
    if(this.word == node.word) &#123;
        rst = true;
    &#125;

    return rst;
&#125;
</code></pre>
<p>最终</p>
<pre><code class="java">package DataStructure;

import java.util.LinkedList;

public class BinaryTreeDemo1 &#123;
    public static void main(String[] args) &#123;
        BinaryTree_1 tree = new BinaryTree_1();
        String words =&quot;ABCDEFGH&quot;;
        for(char i : words.toCharArray()) &#123;
            tree.add(new TreeNode_1(i));
        &#125;
        System.out.println(&quot;前序遍历&quot;);
        tree.preOrder();
        System.out.println(&quot;中序遍历&quot;);
        tree.infixOrder();
        System.out.println(&quot;后序遍历&quot;);
        tree.postOrder();
        
        System.out.println(&quot;前序查找&quot;);
        System.out.println(tree.preSearch(new TreeNode_1(&#39;B&#39;)));
        System.out.println(&quot;中序查找&quot;);
        System.out.println(tree.infixSearch(new TreeNode_1(&#39;B&#39;)));
        System.out.println(&quot;后序查找&quot;);
        System.out.println(tree.postSearch(new TreeNode_1(&#39;B&#39;)));
        
    &#125;
    
    
&#125;

class TreeNode_1&#123;
    char word;
    TreeNode_1 left;
    TreeNode_1 right;
    TreeNode_1(char word)&#123;
        this.word = word;
    &#125;
    @Override
    public String toString() &#123;
        // TODO Auto-generated method stub
        return word+&quot;&quot;;
    &#125;
    
    //前序遍历
    public void preOrder() &#123;
        System.out.print(this);
        if(this.left != null) &#123;
            this.left.preOrder();
        &#125;
        if(this.right != null) &#123;
            this.right.preOrder();
        &#125;
    &#125;
    
    //中序遍历
    public void infixOrder() &#123;
        //先向左递归
        if(this.left !=null) &#123;
            this.left.infixOrder();
        &#125;
        //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个
        System.out.print(this);
        
        //然后递归右结点
        if(this.right!=null) &#123;
            this.right.infixOrder();
        &#125;
    &#125;
    
    //后序遍历
    public void postOrder() &#123;
        if(this.left != null) &#123;
            this.left.postOrder();
        &#125;
        
        if(this.right != null) &#123;
            this.right.postOrder();
        &#125;
        System.out.print(this);
    &#125;
    
    
    //前序遍历
        public boolean preSearch(TreeNode_1 node) &#123;
            boolean rst =false;
            System.out.println(this+&quot; &quot;+node);
            if(this.word == node.word) &#123;
                return true;
            &#125;
            
            if(this.left != null) &#123;
                rst = this.left.preSearch(node);
            &#125;
            
            if(rst == true) &#123;
                return rst;
            &#125;
            
            if(this.right != null) &#123;
                rst = this.right.preSearch(node);
            &#125;
            
            
            return rst;
        &#125;
        
        //中序遍历
        public boolean infixSearch(TreeNode_1 node) &#123;
            boolean rst =false;
            //先向左递归
            if(this.left !=null) &#123;
                rst = this.left.infixSearch(node);
            &#125;
            if(rst == true) &#123;
                return rst;
            &#125;
            //走到左边最后一个打印,走完回溯到倒数第二个结点，打印倒数第二个
            System.out.println(this+&quot; &quot;+node);
            if(this.word == node.word) &#123;
                return true;
            &#125;
            
            //然后递归右结点
            if(this.right!=null) &#123;
                rst = this.right.infixSearch(node);
            &#125;
            return rst;
        &#125;
        
        //后序遍历
        public boolean postSearch(TreeNode_1 node) &#123;
            boolean rst = false;
            if(this.left != null) &#123;
                rst = this.left.postSearch(node);
            &#125;
            if(rst == true) &#123;
                return rst;
            &#125;
            if(this.right != null) &#123;
                rst = this.right.postSearch(node);
            &#125;
            System.out.println(this+&quot; &quot;+node);
            if(this.word == node.word) &#123;
                rst = true;
            &#125;
            
            return rst;
        &#125;
    
&#125;


class BinaryTree_1&#123;
    private TreeNode_1 root;
    BinaryTree_1()&#123;
        root = null;
    &#125;
    BinaryTree_1(TreeNode_1 root)&#123;
        this.root =root;
    &#125;
    
    public boolean isempty() &#123;
        return root == null;
    &#125;
    
    
    
    public void add(TreeNode_1 node) &#123;
        if(isempty()) &#123;
            root = node;
            return;
        &#125;
        LinkedList&lt;TreeNode_1&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        while(!queue.isEmpty()) &#123;
            TreeNode_1 cur = queue.pop();
            if(cur.left == null) &#123;
                cur.left = node;
                return;
            &#125;else &#123;
                queue.add(cur.left);
            &#125;
            if(cur.right == null) &#123;
                cur.right = node;
                return;
            &#125;else &#123;
                queue.add(cur.right);
            &#125;
        &#125;
    &#125;
    
    //前序遍历
    public void preOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.preOrder();
        System.out.println();
    &#125;
    
    //中序遍历
    public void infixOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.infixOrder();
        System.out.println();
    &#125;
    
    //后序遍历
    public void postOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return;
        &#125;
        this.root.postOrder();
        System.out.println();
    &#125;
    
    
    //前序查找
    public boolean preSearch(TreeNode_1 node) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return false;
        &#125;
        return this.root.preSearch(node);
    &#125;
    
    //中序查找
    public boolean infixSearch(TreeNode_1 node) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return false;
        &#125;
        return this.root.infixSearch(node);
    &#125;
    
    //后序查找
    public boolean postSearch(TreeNode_1 node) &#123;
        if(isempty()) &#123;
            System.out.println(&quot;树为空&quot;);
            return false;
        &#125;
        return this.root.postSearch(node);

    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210309220309950.png" alt="image-20210309220309950"></p>
<h3 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h3><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210310213638706.png" alt="image-20210310213638706"></p>
<p>我们将二叉树的结点以数组的形式储存，虽然结点在数组中保存，但是我们仍然可以像树一样遍历数组（前序遍历、中序遍历、后序遍历）</p>
<p>顺序存储二叉树的特点</p>
<ol>
<li>通常是完全二叉树</li>
<li>第n个元素的左子节点为2*n+1</li>
<li>第n个元素的右子节点为2*n+2</li>
<li>第n个元素的父节点为（n-1）/2 (取整)</li>
</ol>
<p>举例：第0个元素的左子节点序号为1，第0个元素的右子节点序号为2， 第1个元素的父节点0，0 = (1-1) /2,同样第2个元素的父节点0, 0 = (2-1) /2</p>
<p>代码</p>
<pre><code class="java">package DataStructure;

public class ArrayBinaryTreeDemo1 &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1,2,3,4,5,6,7&#125;; //定义一个顺序数组
        System.out.println(&quot;前序遍历&quot;);
        preOrder(arr, 0); //这个0指的是根的位置
        System.out.println(&quot;\n&quot;+&quot;中序遍历&quot;);
        infixOrder(arr, 0);
        System.out.println(&quot;\n&quot;+&quot;后序遍历&quot;);
        postOrder(arr, 0);
        
    &#125;
    
    //完成顺序存储二叉树的前序遍历
    public static void preOrder(int[] arr, int index) &#123;
        if(arr == null || arr.length == 0) &#123;
            System.out.println(&quot;数组为空&quot;);
            return;
        &#125;
        System.out.print(arr[index]);
        //向左递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +1);
        &#125;
        //向右递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +2);
        &#125;
        
    &#125;
    
    //中序遍历
    public static void infixOrder(int[] arr, int index) &#123;
        if(arr == null || arr.length == 0) &#123;
            System.out.println(&quot;数组为空&quot;);
            return;
        &#125;
        
        //向左递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +1);
        &#125;
        System.out.print(arr[index]);
        //向右递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +2);
        &#125;
    &#125;
    
    //后序遍历
    public static void postOrder(int[] arr, int index) &#123;
        if(arr == null || arr.length == 0) &#123;
            System.out.println(&quot;数组为空&quot;);
            return;
        &#125;
        
        //向左递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +1);
        &#125;
    
        //向右递归
        if(2*index +2 &lt; arr.length) &#123;
            preOrder(arr, 2*index +2);
        &#125;
        
        System.out.print(arr[index]);
    &#125;
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210310230156086.png" alt="image-20210310230156086"></p>
<h2 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用堆这种数据结构而设计的排序算法，堆排序是一种选择排序，它的时间复杂度为 O(nlogn),是不稳定的排序。我们使用树的思想来进行数组的排序，数组与树之间的转换，参考上面顺序存储二叉树</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>当完全二叉树的每个结点的值都大于或等于其左右孩子结点的值，我们称为大顶堆。若每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210310144214297.png" alt="image-20210310144214297"></p>
<p>大顶堆的图如上，小顶堆就是和大顶堆相反，小的在上，大的在下</p>
<p>一般使用大顶堆对数据进行升序排列，使用小顶堆进行降序排列</p>
<p>排序操作时操作的一直都是数组，但是为了方便理解，以树的形式来演示。</p>
<p>大顶堆特点：arr[i] &gt;= arr[2<em>i +1] &amp;&amp; arr[i] &gt;= arr[2</em>i +2]</p>
<ol>
<li>第n个元素大于等于其左子节点即第2*n+1个元素</li>
<li>第n个元素大于等于其右子节点即第2*n+2个元素</li>
</ol>
<p>小顶堆特点：arr[i] &lt;= arr[2<em>i +1] &amp;&amp; arr[i] &lt;= arr[2</em>i +2]</p>
<ol>
<li>第n个元素小于等于其左子节点即第2*n+1个元素</li>
<li>第n个元素小于等于其右子节点即第2*n+2个元素</li>
</ol>
<h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><ol>
<li>将待排序数列构建成一个大顶堆</li>
<li>此时序列最大值再根节点</li>
<li>将根节点与数组最后一个数进行交换</li>
<li>将剩余的n-1个数再次形成一个大顶堆，依次循环</li>
<li><strong>注意</strong>：堆排序不需要创建树，我们执行排序只是利用树的思路来解决数组的排序问题，整个过程都在处理数组</li>
</ol>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>大顶堆的构建需要从下往上最下面index应该是倒数第二行第一个结点(父结点)</p>
<p>我们从下往上的顺序是：3 -&gt; 2-&gt;1,从而构建大顶堆</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210311161053589.png" alt="image-20210311161053589"></p>
<p>图解</p>
<p>第一个大顶堆</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210311161012291.png" alt="image-20210311161012291"></p>
<p>root根与最后一个交换</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210311161423085.png" alt="image-20210311161423085"></p>
<p>从剩下的n-1个数组中再找出最大的</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210311161541322.png" alt="image-20210311161541322"></p>
<p>再次循环</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210311161615463.png" alt="image-20210311161615463"></p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class HeapSorting &#123;

    public static void main(String[] args) &#123;
        int[] arr = &#123;35, 10, 25, 15, 30, 40, 20, 50, 45&#125;;
//        int[] arr = &#123;101,34,119,1&#125;;
        Sort(arr);
        System.out.println(Arrays.toString(arr));
    &#125;
    
    
    public static void Sort(int[] arr) &#123;
        int temp;
        
        //由下往上构建大顶堆,i指的是倒数位于中间的结点元素
        for(int i=arr.length/2 -1;i&gt;-1;i--) &#123;
            heap(arr, i, arr.length);
        &#125;
        
        //进行arr.length-1次循环
        for(int j=arr.length-1; j&gt;0; j-- ) &#123;
            //交换数组元素，第一个（本循环中最大的）与最后一个交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            //排除最后一个再次构建大顶堆
            heap(arr, 0, j);
        &#125;
    &#125;
    
    //建立大顶堆
    public static void heap(int[] arr, int index, int len) &#123;
        int temp = arr[index]; //用temp储存最顶端的值

        //for循环只要k值即小于len的时候，才能开始遍历数组
        //bigger = bigger*2+1 指向左遍历
        for(int bigger=2*index+1; bigger &lt;len; bigger = bigger *2+ 1) &#123;
            //三个数进行比较，左、中、右，默认左边大于右边
            // 如果右边大于左边，且右边有值时
            //右边是index*2 +2 = bigger +1
            if(bigger+1 &lt; len &amp;&amp;arr[bigger] &lt; arr[bigger+1]) &#123;
                bigger++; //更大的是右边
            &#125;
            
            //如果此时左边或者右边中更大的数大于中间的数
            if(arr[bigger] &gt; temp) &#123;
                //中间的数与最大的数交换位置
                arr[index] = arr[bigger];
                //用index记下最大的数原来的下标，方便向下查找比较
                index =bigger;
            &#125;else &#123;
                break;
            &#125;
        &#125;
        
        //最后再交换最小的数
        arr[index] =temp;
        
        

    &#125;

&#125;
</code></pre>
<h2 id="赫夫曼树（Huffman-Tree）"><a href="#赫夫曼树（Huffman-Tree）" class="headerlink" title="赫夫曼树（Huffman Tree）"></a>赫夫曼树（Huffman Tree）</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ol>
<li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的WPL(Weighted path length) 最小，它就是Huffman Tree，同时也称最优二叉树</li>
</ol>
<p><em>WPL是指所有叶子结点的带权路径之和</em></p>
<ol start="2">
<li>Huffman Tree是带权路径长度最短的树，权值较大的结点离根较近</li>
<li>Huffman Tree的值都放在叶子结点上</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210313154401138.png" alt="image-20210313154401138"></p>
<p>上面这张图的WPL是<br>$$<br>10<em>3+30</em>2+25<em>2+20</em>2 = 180<br>$$</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210313184403163.png" alt="image-20210313184403163"></p>
<pre><code class="java">package DataStructure;

import java.util.ArrayList;
import java.util.Collections;

public class HuffmanTreeDemo1 &#123;
    public static void main(String[] args) &#123;
        int[] arr = &#123;1, 3, 6, 7, 8, 13, 29&#125;;
        ArrayList&lt;HuffmanNode&gt; nodes = new ArrayList&lt;&gt;(); 
        for(int i:arr) &#123;
            nodes.add(new HuffmanNode(i));
        &#125;
        Collections.sort(nodes);
        CrtTree(nodes);
        System.out.println(&quot;前序遍历&quot;);
        preOrder(nodes.get(0));

    &#125;
    
    public static void CrtTree(ArrayList&lt;HuffmanNode&gt; nodes) &#123;
        while(nodes.size() &gt;1) &#123;
            HuffmanNode leftNode = nodes.get(0);
            HuffmanNode rightNode = nodes.get(1);
            HuffmanNode parent = new HuffmanNode(leftNode.value +rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);
            Collections.sort(nodes);
        &#125;
        System.out.println(nodes.get(0));
    &#125;
    
    public static void preOrder(HuffmanNode root) &#123;
        System.out.println(root);
        if(root.left != null) &#123;
            preOrder(root.left);
        &#125;
        if(root.right != null) &#123;
            preOrder(root.right);
        &#125;
    &#125;
&#125;

//为了使Node对象支持排序
class HuffmanNode implements Comparable&lt;HuffmanNode&gt;&#123;
    int value;
    HuffmanNode left;
    HuffmanNode right;
    HuffmanNode(int num)&#123;
        value = num;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;HuffmanNode [value=&quot; + value + &quot;]&quot;;
    &#125;

    @Override
    public int compareTo(HuffmanNode node) &#123;
        // TODO Auto-generated method stub
        return this.value - node.value;
    &#125;
    
    
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210313184501417.png" alt="image-20210313184501417"></p>
<h3 id="赫夫曼编码（Huffman-Coding）"><a href="#赫夫曼编码（Huffman-Coding）" class="headerlink" title="赫夫曼编码（Huffman Coding）"></a>赫夫曼编码（Huffman Coding）</h3><p>赫夫曼编码常用于通信领域，由于其优异的编码方式，可以提高传输效率</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>我们要将“hello world”进行数据传输，首先我们要把字母转成对应的ASC字母表</p>
<p>104 101 108 108 110 32 119 114 111 114 108 100</p>
<p>然后把对应的十进制数字转为二进制</p>
<p>110 1000 110 0101 110 1100 110 1100 110 1110 10 0000 111 0111 111 0010 110 1111 111 0010 110 1100 110 0100</p>
<p>可以发现转为二进制传输非常长，假如内容更多，对应的二进制内容也会更长，传输效率会下降</p>
<p>我们将上面的内容换成赫夫曼编码</p>
<p>赫夫曼编码的前提是拥有一个赫夫曼树，统一向左为0，向右为1，我们统计每个字符出现的次数，其出现的次数为权，下面有一张图来解释</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210313201131542.png" alt="image-20210313201131542"></p>
<p>赫夫曼编码中每个字符没有重复的码，保证了唯一性</p>
<p>将”hello world”按照赫夫曼编码: 11011101010010000001000101100</p>
<p>注意，赫夫曼树的排序方法不同可能会导致对应的赫夫曼编码不同（几个数权值一样），但是最终大小都是一样</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>1）创建一个结点，储存数据和对应的权值</p>
<p>2）将内容数据转成byte[ ] 数组</p>
<p>3）统计byte数组中每个字符出现的次数，转存到map中</p>
<p>4）构建赫夫曼树，（根据前面得到的map的data和对应的权值来构建Node），把Node加入到List中进行排序</p>
<p>5）构建好的赫夫曼树返回的是一个根节点</p>
<p>6）根据根节点我们要遍历，获取对应的密码，向左为0，向右为1，把对应的密码存入到Map中</p>
<p>7）按照之前的byte[ ]数组，我们与密码一起匹配（压缩）转换成新的byte[ ]数组，这个数组存储的就是赫夫曼码</p>
<p><strong>编码</strong></p>
<p>1） 节点构建</p>
<p>此节点继承Comparable接口，有利于树的比较</p>
<pre><code class="java">//Node节点，储存数据与权值
class Node implements Comparable&lt;Node&gt;&#123;
    Byte data;
    int weight;
    Node left;
    Node right;
    Node(Byte data, int value)&#123;
        this.data =  data;
        weight = value;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Node [data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;;
    &#125;

    @Override
    public int compareTo(Node o) &#123;
        return this.weight - o.weight;
    &#125;
&#125;
</code></pre>
<p>2）</p>
<p>把字符串内容转为Byte类型数组</p>
<pre><code class="java">byte[] arr = msg.getBytes();
</code></pre>
<p>3）</p>
<p>统计每个字符出现的次数，储存在Map中</p>
<p>【h:1 , e:1, l:3, o:2, w:1, r:1, d:1】</p>
<pre><code class="java">//统计每个字母出现的次数
    private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123;
        HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;();
        for(byte i:arr) &#123;
            Byte data = new Byte(i);
            if(!map.containsKey(data)) &#123;
                map.put(data, 1);
            &#125;
            else &#123;
                map.replace(data, map.get(data), map.get(data)+1);
            &#125;
        &#125;
        return map;
    &#125;
</code></pre>
<p>4）</p>
<p>按照这些字符出现的次数，我们进行排序，然后构建赫夫曼树</p>
<pre><code class="java">//构建赫夫曼树，返回根节点
    private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123;
        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
        for(Byte i:map.keySet()) &#123;
            nodes.add(new Node(i, map.get(i)));
        &#125;
        Collections.sort(nodes);
        while(nodes.size() &gt; 1) &#123;
            Node leftNode = nodes.get(0);
            Node rightNode =nodes.get(1);
            Node parentNode = new Node(null, leftNode.weight+rightNode.weight);
            parentNode.left = leftNode;
            parentNode.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parentNode);
            Collections.sort(nodes);
        &#125;
        return nodes.get(0);
    &#125;
</code></pre>
<p>5）</p>
<p>构建好树之后，我们要对树进行遍历，向左为0，向右为1，像这样</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210314123026917.png" alt="image-20210314123026917"></p>
<p>最终可以得到</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210314123040990.png" alt="image-20210314123040990"></p>
<p>由于权值相同，得出的code可能会与上面展示的不一样</p>
<p>我们将转好的密码存入Map</p>
<pre><code class="java">//得出密码，赫夫曼码
    private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123;
        if(root.left != null) &#123;
            buf.append(0);
            password(root.left, buf, map);
        &#125;
        if(root.left == null &amp;&amp; root.right == null) &#123;
            map.put(root.data, buf.toString());
            buf.deleteCharAt(buf.length()-1);
            return null;
        &#125;
        
        if(root.right != null) &#123;
            buf.append(1);
            password(root.right, buf, map);
        &#125;
//        if(buf.length()&gt;0)
        try &#123;
            buf.deleteCharAt(buf.length()-1);
        &#125;catch(Exception e) &#123;
            
        &#125;
        
        
        return map;
    &#125;
</code></pre>
<p>6）按照密码进行字符串对应的byte[ ]数组压缩，返回的是byte[ ]数组</p>
<pre><code class="java">//数组转换成赫夫曼编码格式
    private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123;
        StringBuilder meg =new StringBuilder();
        for(int i=0;i&lt;arr.length;i++) &#123;
             meg.append(dic.get(arr[i]));
        &#125;
//        System.out.println(meg);
        //转成byte数组
        //1 byte 等于8 bits, 0001001是bits,要转成byte 
        int len;
        if(meg.length()%8==0) &#123;
            len = meg.length()/8;
        &#125;else &#123;
            len = meg.length()/8+1;
        &#125;
        byte[] codes =new byte[len];
        //把刚才存好的字符串，8位8位读取，添加进byte数组中
        int count=0;
        for(int j=0;j&lt;meg.length();j+=8)&#123;
            String temp;
            if(j+8 &gt; meg.length()) &#123;
                temp = meg.substring(j);
            &#125;
            else
                temp = meg.substring(j, j+8);
            
            //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型
            codes[count] = (byte)Integer.parseInt(temp, 2);
            
            count++;
        &#125;
        return codes;
    &#125;
</code></pre>
<p><strong>最终</strong></p>
<p>只要调用Zip函数，向Zip函数传入字符串参数，就能得到相应的赫夫曼编码数组</p>
<pre><code class="java">    //赫夫曼编码
    public static byte[] Zip(String msg) &#123;
        byte[] arr = msg.getBytes();
        HashMap&lt;Byte, Integer&gt; map = Count(arr);
        Node root = HuffmanTree(map);
        StringBuffer buf=new StringBuffer();
        HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;();
        password(root, buf,Dic);
//        for(Byte i:Dic.keySet()) &#123;
//            System.out.println((char)(byte)i+&quot;:&quot;+Dic.get(i));
//        &#125;
        
        return UpdateCode(arr,Dic);
    &#125;
    
    //统计每个字母出现的次数
    private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123;
        HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;();
        for(byte i:arr) &#123;
            Byte data = new Byte(i);
            if(!map.containsKey(data)) &#123;
                map.put(data, 1);
            &#125;
            else &#123;
                map.replace(data, map.get(data), map.get(data)+1);
            &#125;
        &#125;
        return map;
    &#125;
    
    //构建赫夫曼树，返回根节点
    private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123;
        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
        for(Byte i:map.keySet()) &#123;
            nodes.add(new Node(i, map.get(i)));
        &#125;
        Collections.sort(nodes);
        while(nodes.size() &gt; 1) &#123;
            Node leftNode = nodes.get(0);
            Node rightNode =nodes.get(1);
            Node parentNode = new Node(null, leftNode.weight+rightNode.weight);
            parentNode.left = leftNode;
            parentNode.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parentNode);
            Collections.sort(nodes);
        &#125;
        return nodes.get(0);
    &#125;
    
    //得出密码，赫夫曼码
    private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123;
        if(root.left != null) &#123;
            buf.append(0);
            password(root.left, buf, map);
        &#125;
        if(root.left == null &amp;&amp; root.right == null) &#123;
            map.put(root.data, buf.toString());
            buf.deleteCharAt(buf.length()-1);
            return null;
        &#125;
        
        if(root.right != null) &#123;
            buf.append(1);
            password(root.right, buf, map);
        &#125;
//        if(buf.length()&gt;0)
        try &#123;
            buf.deleteCharAt(buf.length()-1);
        &#125;catch(Exception e) &#123;
            
        &#125;
        
        
        return map;
    &#125;
    
    //数组转换成赫夫曼编码格式
    private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123;
        StringBuilder meg =new StringBuilder();
        for(int i=0;i&lt;arr.length;i++) &#123;
             meg.append(dic.get(arr[i]));
        &#125;
//        System.out.println(meg);
        //转成byte数组
        //1 byte 等于8 bits, 0001001是bits,要转成byte 
        int len;
        if(meg.length()%8==0) &#123;
            len = meg.length()/8;
        &#125;else &#123;
            len = meg.length()/8+1;
        &#125;
        byte[] codes =new byte[len];
        //把刚才存好的字符串，8位8位读取，添加进byte数组中
        int count=0;
        for(int j=0;j&lt;meg.length();j+=8)&#123;
            String temp;
            if(j+8 &gt; meg.length()) &#123;
                temp = meg.substring(j);
            &#125;
            else
                temp = meg.substring(j, j+8);
            
            //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型
            codes[count] = (byte)Integer.parseInt(temp, 2);
            
            count++;
        &#125;
        return codes;
    &#125;
</code></pre>
<h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><p>上面讲的是编码，下面的程序是解码程序</p>
<p>解码与编码相反</p>
<p>1）把得到的byte[ ]数组转为2进制，一个一个读取，存入到一个字符串中</p>
<p>2）按照字符串和之前的密码本进行匹配，最后就得出原数据</p>
<pre><code class="java">public static void Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123;
        //反向查询解码
        HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;();
//        System.out.println(msg);
        System.out.println(&quot;Huffman decode&quot;);
        for(Byte word:dic.keySet()) &#123;
            map.put(dic.get(word), word);
        &#125;
        
    
        int count =1;
        String value;
        //匹配对应的字符
        for(int i=0;i&lt;msg.length();i+= value.length()) &#123;
            while(true) &#123;
                value = msg.substring(i, i+count);
                if(map.containsKey(value)) &#123;
                    System.out.print((char)(byte)map.get(value));
                    count =1;
                    break;
                &#125;
                count ++;
            &#125;
        &#125;
        
    &#125;
    
    //把byte数组转为二进制类型
    public static String Unzip(byte[] msg) &#123;
        StringBuilder container = new StringBuilder();
        for(int i=0;i&lt;msg.length;i++) &#123;
            
            int value =new Byte(msg[i]);
            String temp =Integer.toBinaryString(value);
            //判断最后一位是否为8bit长度，如果不是，直接加进去
            if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123;
                container.append(temp);
            &#125;
            else &#123;
                if(temp.length()&gt;24)
                    container.append(temp.substring(24));
                else &#123;
                    for(int j=0;j&lt;(8-temp.length());j++) &#123;
                        container.append(&quot;0&quot;);
                    &#125;
                    container.append(temp);
                &#125;
            &#125;
//            System.out.println(temp);
            
                
            
        &#125;
        return container.toString();
    &#125;
</code></pre>
<p>压缩+解码</p>
<pre><code class="java">package HuffmanCoding;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;


public class HuffmanCodingDemo1 &#123;

    public static void main(String[] args) &#123;
        String msg =&quot;hello world my friend, this is peterbear&quot;;
        
        byte[] arr = msg.getBytes();
        HashMap&lt;Byte, Integer&gt; map = Count(arr);
        Node root = HuffmanTree(map);
        StringBuffer buf=new StringBuffer();
        HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;();
        
        System.out.println(&quot;Huffman Code&quot;);;
        byte[] code = Zip(msg);
        System.out.println(Arrays.toString(code));
        
        Decode(Unzip(code),password(root, buf,Dic));
    &#125;
    
    
    
    
    //赫夫曼编码
    public static byte[] Zip(String msg) &#123;
        byte[] arr = msg.getBytes();
        HashMap&lt;Byte, Integer&gt; map = Count(arr);
        Node root = HuffmanTree(map);
        StringBuffer buf=new StringBuffer();
        HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;();
        password(root, buf,Dic);
//        for(Byte i:Dic.keySet()) &#123;
//            System.out.println((char)(byte)i+&quot;:&quot;+Dic.get(i));
//        &#125;
        
        return UpdateCode(arr,Dic);
    &#125;
    
    //统计每个字母出现的次数
    private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123;
        HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;();
        for(byte i:arr) &#123;
            Byte data = new Byte(i);
            if(!map.containsKey(data)) &#123;
                map.put(data, 1);
            &#125;
            else &#123;
                map.replace(data, map.get(data), map.get(data)+1);
            &#125;
        &#125;
        return map;
    &#125;
    
    //构建赫夫曼树，返回根节点
    private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123;
        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
        for(Byte i:map.keySet()) &#123;
            nodes.add(new Node(i, map.get(i)));
        &#125;
        Collections.sort(nodes);
        while(nodes.size() &gt; 1) &#123;
            Node leftNode = nodes.get(0);
            Node rightNode =nodes.get(1);
            Node parentNode = new Node(null, leftNode.weight+rightNode.weight);
            parentNode.left = leftNode;
            parentNode.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parentNode);
            Collections.sort(nodes);
        &#125;
        return nodes.get(0);
    &#125;
    
    //得出密码，赫夫曼码
    private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123;
        if(root.left != null) &#123;
            buf.append(0);
            password(root.left, buf, map);
        &#125;
        if(root.left == null &amp;&amp; root.right == null) &#123;
            map.put(root.data, buf.toString());
            buf.deleteCharAt(buf.length()-1);
            return null;
        &#125;
        
        if(root.right != null) &#123;
            buf.append(1);
            password(root.right, buf, map);
        &#125;
//        if(buf.length()&gt;0)
        try &#123;
            buf.deleteCharAt(buf.length()-1);
        &#125;catch(Exception e) &#123;
            
        &#125;
        
        
        return map;
    &#125;
    
    //数组转换成赫夫曼编码格式
    private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123;
        StringBuilder meg =new StringBuilder();
        for(int i=0;i&lt;arr.length;i++) &#123;
             meg.append(dic.get(arr[i]));
        &#125;
//        System.out.println(meg);
        //转成byte数组
        //1 byte 等于8 bits, 0001001是bits,要转成byte 
        int len;
        if(meg.length()%8==0) &#123;
            len = meg.length()/8;
        &#125;else &#123;
            len = meg.length()/8+1;
        &#125;
        byte[] codes =new byte[len];
        //把刚才存好的字符串，8位8位读取，添加进byte数组中
        int count=0;
        for(int j=0;j&lt;meg.length();j+=8)&#123;
            String temp;
            if(j+8 &gt; meg.length()) &#123;
                temp = meg.substring(j);
            &#125;
            else
                temp = meg.substring(j, j+8);
            
            //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型
            codes[count] = (byte)Integer.parseInt(temp, 2);
            
            count++;
        &#125;
        return codes;
    &#125;
    
    public static void Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123;
        //反向查询解码
        HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;();
//        System.out.println(msg);
        System.out.println(&quot;Huffman decode&quot;);
        for(Byte word:dic.keySet()) &#123;
            map.put(dic.get(word), word);
        &#125;
        
        int count =1;
        String value;
        
        for(int i=0;i&lt;msg.length();i+= value.length()) &#123;
            while(true) &#123;
                value = msg.substring(i, i+count);
                if(map.containsKey(value)) &#123;
                    System.out.print((char)(byte)map.get(value));
                    count =1;
                    break;
                &#125;
                count ++;
            &#125;
        &#125;
        
    &#125;
    
    //把byte数组转为二进制类型
    private static String Unzip(byte[] msg) &#123;
        StringBuilder container = new StringBuilder();
        for(int i=0;i&lt;msg.length;i++) &#123;
            
            int value =new Byte(msg[i]);
            String temp =Integer.toBinaryString(value);
            //判断最后一位是否为8bit长度，如果不是，直接加进去
            if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123;
                container.append(temp);
            &#125;
            else &#123;
                if(temp.length()&gt;24)
                    container.append(temp.substring(24));
                else &#123;
                    for(int j=0;j&lt;(8-temp.length());j++) &#123;
                        container.append(&quot;0&quot;);
                    &#125;
                    container.append(temp);
                &#125;
            &#125;
//            System.out.println(temp);
            
                
            
        &#125;
        return container.toString();
    &#125;
    
    
    //前序遍历
    public static void preOrder(Node root) &#123;
        System.out.println(root);
        if(root.left != null) &#123;
            preOrder(root.left);
        &#125;
        if(root.right != null) &#123;
            preOrder(root.right);
        &#125;
    &#125;
    
    //中序遍历
    public static void infixOrder(Node root) &#123;
        
        if(root.left != null) &#123;
            infixOrder(root.left);
        &#125;
        System.out.println(root);
        if(root.right != null) &#123;
            infixOrder(root.right);
        &#125;
    &#125;

&#125;


//Node节点，储存数据与权值
class Node implements Comparable&lt;Node&gt;&#123;
    Byte data;
    int weight;
    Node left;
    Node right;
    Node(Byte data, int value)&#123;
        this.data =  data;
        weight = value;
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Node [data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;;
    &#125;

    @Override
    public int compareTo(Node o) &#123;
        return this.weight - o.weight;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210314124906781.png" alt="image-20210314124906781"></p>
<h3 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h3><p>内容和上面差不多，唯一的区别在于文件压缩需要考虑IO，压缩数据时要使用对象流写入，读取时也需要，写入时要将密码也写入</p>
<pre><code class="java">package HuffmanCoding;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;


public class HuffmanFileZip &#123;

    public static void main(String[] args) &#123;
        String input =&quot;C:\\Users\\23881\\Desktop\\Self_study\\Java基础\\HuffmanCoding\\music.mp3&quot;;
        String output =&quot;C:\\Users\\23881\\Desktop\\Self_study\\Java基础\\HuffmanCoding\\压缩\\store.zip&quot;;
        Zip(input, output);
        input = output;
        output = &quot;C:\\Users\\23881\\Desktop\\Self_study\\Java基础\\HuffmanCoding\\解压\\music.mp3&quot;;
        UnZipFile(input, output);
        
    &#125;
    
    
    
    
    //赫夫曼编码
    public static void Zip(String input, String output) &#123;
        FileInputStream file=null;
        ObjectOutputStream oop=null;
        FileOutputStream out=null;
        byte[] arr;
        try &#123;
            file= new FileInputStream(input);
            arr = new byte[file.available()];
            file.read(arr);
            
            HashMap&lt;Byte, Integer&gt; map = Count(arr);
            Node root = HuffmanTree(map);
            StringBuffer buf=new StringBuffer();
            //密码就存在Dic字典中
            HashMap&lt;Byte, String&gt; Dic = new HashMap&lt;&gt;();
            
            password(root, buf,Dic);
            byte[] rst = UpdateCode(arr,Dic);
            //输出流
            out = new FileOutputStream(output);
            //与输出流关联对象流,便于恢复数据
            oop = new ObjectOutputStream(out);
            //把编码后的数据写入压缩文件
            oop.writeObject(rst);
            
            //同时我们还要把赫夫曼编码也写入文件中
            oop.writeObject(Dic);
            System.out.println(&quot;压缩完成&quot;);
        &#125; catch (IOException e) &#123;
            // TODO Auto-generated catch block
            System.out.println(&quot;此路径为空&quot;);
        &#125;finally&#123;
            try &#123;
                file.close();
                out.close();
                oop.close();
            &#125; 
            catch (IOException e) &#123;
                
            &#125;
        &#125;
    &#125;
    
    //统计每个字母出现的次数
    private static HashMap&lt;Byte, Integer&gt; Count(byte[] arr) &#123;
        HashMap&lt;Byte, Integer&gt; map = new HashMap&lt;&gt;();
        for(byte i:arr) &#123;
            Byte data = new Byte(i);
            if(!map.containsKey(data)) &#123;
                map.put(data, 1);
            &#125;
            else &#123;
                map.replace(data, map.get(data), map.get(data)+1);
            &#125;
        &#125;
        return map;
    &#125;
    
    //构建赫夫曼树，返回根节点
    private static Node HuffmanTree(HashMap&lt;Byte, Integer&gt; map) &#123;
        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;();
        for(Byte i:map.keySet()) &#123;
            nodes.add(new Node(i, map.get(i)));
        &#125;
        Collections.sort(nodes);
        while(nodes.size() &gt; 1) &#123;
            Node leftNode = nodes.get(0);
            Node rightNode =nodes.get(1);
            Node parentNode = new Node(null, leftNode.weight+rightNode.weight);
            parentNode.left = leftNode;
            parentNode.right = rightNode;
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parentNode);
            Collections.sort(nodes);
        &#125;
        return nodes.get(0);
    &#125;
    
    //得出密码，赫夫曼码
    private static HashMap&lt;Byte, String&gt; password(Node root,StringBuffer buf,HashMap&lt;Byte, String&gt; map) &#123;
        if(root.left != null) &#123;
            buf.append(0);
            password(root.left, buf, map);
        &#125;
        if(root.left == null &amp;&amp; root.right == null) &#123;
            map.put(root.data, buf.toString());
            buf.deleteCharAt(buf.length()-1);
            return null;
        &#125;
        
        if(root.right != null) &#123;
            buf.append(1);
            password(root.right, buf, map);
        &#125;

        try &#123;
            buf.deleteCharAt(buf.length()-1);
        &#125;catch(Exception e) &#123;
            
        &#125;
        
        
        return map;
    &#125;
    
    //数组转换成赫夫曼编码格式
    private static byte[] UpdateCode(byte[] arr, HashMap&lt;Byte, String&gt; dic) &#123;
        StringBuilder meg =new StringBuilder();
        for(int i=0;i&lt;arr.length;i++) &#123;
             meg.append(dic.get(arr[i]));
        &#125;
//        System.out.println(meg);
        //转成byte数组
        //1 byte 等于8 bits, 0001001是bits,要转成byte 
        int len;
        if(meg.length()%8==0) &#123;
            len = meg.length()/8;
        &#125;else &#123;
            len = meg.length()/8+1;
        &#125;
        byte[] codes =new byte[len];
        //把刚才存好的字符串，8位8位读取，添加进byte数组中
        int count=0;
        for(int j=0;j&lt;meg.length();j+=8)&#123;
            String temp;
            if(j+8 &gt; meg.length()) &#123;
                temp = meg.substring(j);
            &#125;
            else
                temp = meg.substring(j, j+8);
            
            //将对应的字符串,转为2进制编码，再将对应的2进制编码转为byte类型
            codes[count] = (byte)Integer.parseInt(temp, 2);
            
            count++;
        &#125;
        return codes;
    &#125;
    
    
    public static void UnZipFile(String input, String output) &#123;
        System.out.println(input);
        
        FileInputStream file=null;
        FileOutputStream Outfile =null;
        ObjectInputStream ZipFile=null;
        try &#123;
            file = new FileInputStream(input);
            Outfile =new FileOutputStream(output);
            ZipFile = new ObjectInputStream(file);
            byte[] huffmanBytes = (byte[])ZipFile.readObject();
            HashMap&lt;Byte, String&gt; dic = (HashMap&lt;Byte, String&gt;)ZipFile.readObject();
            Outfile.write(Decode(Change(huffmanBytes),dic));
            
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;  finally&#123;
            try &#123;
                ZipFile.close();
                Outfile.close();
            &#125; catch (IOException e) &#123;
                // TODO Auto-generated catch block
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    
    
    private static byte[] Decode(String msg, HashMap&lt;Byte, String&gt; dic) &#123;
        //反向查询解码
        HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;();
        ArrayList&lt;Byte&gt; list = new ArrayList&lt;&gt;();
        System.out.println(&quot;Huffman decode&quot;);
        for(Byte word:dic.keySet()) &#123;
            map.put(dic.get(word), word);
        &#125;
        
        int count =1;
        String value;
        
        for(int i=0;i&lt;msg.length();i+= value.length()) &#123;
            while(true) &#123;
                value = msg.substring(i, i+count);
                if(map.containsKey(value)) &#123;
                    list.add(map.get(value));
                    count =1;
                    break;
                &#125;
                count ++;
            &#125;
        &#125;
        
        byte[] arr = new byte[list.size()];
        for(int i=0;i&lt;arr.length;i++) &#123;
            arr[i] = list.get(i);
        &#125;
        return arr;
        
    &#125;

    //把byte数组转为二进制类型
    private static String Change(byte[] msg) &#123;
        StringBuilder container = new StringBuilder();
        for(int i=0;i&lt;msg.length;i++) &#123;
            
            int value =new Byte(msg[i]);
            String temp =Integer.toBinaryString(value);
            //判断最后一位是否为8bit长度，如果不是，直接加进去
            if(i==msg.length-1 &amp;&amp; temp.length()&lt;24) &#123;
                container.append(temp);
            &#125;
            else &#123;
                if(temp.length()&gt;24)
                    container.append(temp.substring(24));
                else &#123;
                    for(int j=0;j&lt;(8-temp.length());j++) &#123;
                        container.append(&quot;0&quot;);
                    &#125;
                    container.append(temp);
                &#125;
            &#125;
    
            
        &#125;
        return container.toString();
    &#125;
    

&#125;

</code></pre>
<h2 id="BST二叉排序树"><a href="#BST二叉排序树" class="headerlink" title="BST二叉排序树"></a>BST二叉排序树</h2><p>前面也提到了二叉树拥有数组和链表的2种优点，增删快，查询快，最典型的便是二叉排序树</p>
<p>添加二叉树结点时，我们要进行比较，小的放左边，大的放右边</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210318214038670.png" alt="image-20210318214038670"></p>
<p>当我们查找特定的值时，就像二分查找一样，十分迅速；我们想要删除一个结点，也可以像链表一样。</p>
<p><strong>注意：</strong></p>
<p>二叉排序树的难点在于删除的部分，我们需要考虑如何找到其父结点与对应的节点，然后怎么处理剩余的节点</p>
<p>二叉排序树，我实现了增删查的功能</p>
<p>树节点</p>
<pre><code class="java">class Node&#123;
    int num;
    Node left;
    Node right;
    public Node(int num) &#123;
        super();
        this.num = num;
    &#125;
    
    public void add(Node node) &#123;
        
        if(this.num &gt; node.num) &#123;
            if(this.left == null) &#123;
                this.left = node; 
                return;
            &#125;else &#123;
                //向左遍历
                this.left.add(node);
            &#125;
            
        &#125;else &#123;
            if(this.right == null) &#123;
                this.right = node;
                return;
            &#125;else &#123;
                //向右遍历
                this.right.add(node);
            &#125;
        &#125;
    &#125;
    
    public Node Search(Node node) &#123;
        if(this.num == node.num) &#123;
            return this;
        &#125;
        if(node.num &lt;this.num) &#123;
            if(this.left == null) &#123;
                return null;
            &#125;
            return this.left.Search(node);
        &#125;else &#123;
            if(this.right == null) &#123;
                return null;
            &#125;
            return this.right.Search(node);
        &#125;
    &#125;
    
    public Node Parent(Node node) &#123;
        if(this.left != null &amp;&amp; this.left.num == node.num|| this.right != null &amp;&amp; this.right.num == node.num) &#123;
            return this;
        &#125;else &#123;
            if(this.left != null &amp;&amp; node.num &lt; this.left.num ) &#123;
                return this.left.Parent(node);
            &#125;else if( this.right != null&amp;&amp;node.num &gt; this.right.num ) &#123;
                return this.right.Parent(node);
            &#125;else &#123;
                return null;//没有父结点
            &#125;
        &#125;
        
    &#125;
    
    
    public void infixOrder() &#123;
        if(this.left != null) &#123;
            this.left.infixOrder();
        &#125;
        
        System.out.print(this+&quot; &quot;);
        
        if(this.right != null) &#123;
            this.right.infixOrder();
        &#125;
    &#125;
    
    @Override
    public String toString() &#123;
        return num+&quot;&quot;;
    &#125;
    
&#125;
</code></pre>
<p>在树结点中有2几个方法是配合二叉排序树类一起使用的，他们都使用了递归的方法，这样可以方便遍历</p>
<p>二叉排序树</p>
<pre><code class="java">class BinarySortTree&#123;
    private Node root = null;
    
    public boolean isempty() &#123;
        return root == null;
    &#125;
    
    public void add(Node node) &#123;
        if(isempty()) &#123;
            root = node;
        &#125;else &#123;
            root.add(node);
        &#125;
    &#125;
    
    //删除节点
    public void delete(Node node) &#123;
//树为空
        if(root == null) &#123;
            System.out.println(&quot;tree is empty&quot;);
            return;
//只有一个节点
        &#125;else if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.num  == node.num) &#123;
            root = null;
            return;
        &#125;
//目标节点未找到
        Node target = root.Search(node);
        if(target == null) &#123;
            System.out.println(&quot;未找到相关结点&quot;);
            return;
        &#125;
        
//寻找父结点        
        Node Parent = root.Parent(node);
        //发现父结点为头节点
        if(Parent == null) &#123;
            Node cur = root.left;
            root = root.right; //把root指向root的右侧
            if(root == null) &#123;
                root = cur; //发现右侧是空，指向左侧
                return;
            &#125;
            //左侧不为null
            if(root.left != null)
                root.add(cur);
            return;
        &#125;
        
        //子结点在父结点左侧
        if(Parent.left.num == target.num) &#123;
            Parent.left = target.right;
            if(target.left != null)
                root.add(target.left);
        &#125;else &#123;
            //子节点在父结点右侧
            Parent.right = target.right;
            if(target.left != null)
                root.add(target.left);
        &#125;
        
//        System.out.println(target);
//        System.out.println(targetParent);
        
    &#125;
    //中序遍历
    public void infixOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;Root is empty&quot;);
        &#125;else &#123;
            root.infixOrder();
            System.out.println();
        &#125;
    &#125;
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210318215854307.png" alt="image-20210318215854307"></p>
<h2 id="AVL-tree平衡二叉树"><a href="#AVL-tree平衡二叉树" class="headerlink" title="AVL tree平衡二叉树"></a>AVL tree平衡二叉树</h2><p>AVL tree可以说是BST 二叉排序树的优化，假如我们一直往BST 树中添加大的值，BST树就会像链表一样，添加效率甚至低于链表（多了几步判断），为了避免这样的事情发生，大佬们把BST进行了优化，变成AVL tree。</p>
<p>由于发现平衡二叉树的人名字中有AVL这几个字母，所以平衡二叉树简称AVL tree</p>
<p>AVL tree基于BST tree进行优化，在添加时进行树的高度的检测，如果左子树的高度比右子树的高度大1，进行右旋转；反之右子树的高度比左子树的高度大1，进行左旋转。（3+1）/2 =2</p>
<p>新增添的功能：</p>
<ol>
<li>检测左右树的高度</li>
<li>左旋转</li>
<li>右旋转</li>
</ol>
<h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><pre><code class="java">class Node&#123;
    //左子树的高度
    public int leftHeight() &#123;
        //判断左边节点是否为null, 如果是，则返回0，如果不是，返回左边的高度
        return this.left == null ? 0:this.left.height();
    &#125;
    //右子树的高度
    public int rightHeight() &#123;
        //判断右边节点是否为null, 如果是，则返回0，如果不是，返回右边的高度
        return this.right == null ? 0:this.right.height();
    &#125;

    //树的高度
    public int height() &#123;
        //从所选节点开始，选取左右节点中高度最大的数值作为树的高度
        return Math.max(this.left == null ? 0: this.left.height(), this.right == null? 0: this.right.height())+1;//为了判断高度，要进行递归，左子树向左递归，右子树向右递归，最后+1是要加上原来的根节点
    &#125;
&#125;
</code></pre>
<h3 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h3><p>右子树的高度比左子树的高度大1</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321121620909.png" alt="image-20210321121620909"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>复制此时的根节点，创建head_node 节点</li>
<li>把head_node左节点指向原左子节点</li>
<li>把head_node右节点指向原右子节点的左子节点</li>
<li>复制原右子节点，创建right_node节点</li>
<li>把right_node在右节点指向原右子节点右子节点</li>
<li>把right_node的左子节点指向head_node</li>
<li>最后把root节点指向此时的right_node节点</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321121800574.png" alt="image-20210321121800574"></p>
<p>最后</p>
<p>就像把树向左旋转以此达到左右子树高度相同的效果，</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321122713371.png" alt="image-20210321122713371"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class AVLtree&#123;
    //左旋转
    public Node leftRotate(Node head) &#123;
        Node head_node = new Node(head.num);
        head_node.left = head.left;
        head_node.right = head.right.left;
        
        Node right_node = new Node(root.right.num);
        right_node.right = head.right.right;
        right_node.left = head_node;
        head = right_node;
        return head;
    &#125;
    
&#125;
</code></pre>
<h3 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h3><p>左子树的高度比右子树的高度大1</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321122351686.png" alt="image-20210321122351686"></p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>复制头（根）节点，创建一个新的节点head_node</li>
<li>把head_node左节点指向原头节点的左节点的右子节点</li>
<li>把head_node右节点指向原头节点的右子节点</li>
<li>复制原头节点的左子节点，创建一个新的节点left_node</li>
<li>把left_node左节点指向原头节点的左子节点的左子节点</li>
<li>把left_node的右节点指向head_node</li>
<li>最后把root根节点指向head_node</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321122621350.png" alt="image-20210321122621350"></p>
<p>最后效果</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321124041090.png" alt="image-20210321124041090"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">    //右旋转
    public Node rightRotate(Node head) &#123;
        Node head_node = new Node(head.num);
        head_node.right = head.right;
        head_node.left = head.left.right;
        
        Node left_node = new Node(head.left.num);
        left_node.left = head.left.left;
        left_node.right = head_node;
        head = left_node;
        return head;
    &#125;
</code></pre>
<h3 id="结合左旋转与右旋转"><a href="#结合左旋转与右旋转" class="headerlink" title="结合左旋转与右旋转"></a>结合左旋转与右旋转</h3><p>把左旋转与右旋转加入到AVL tree的add方法中</p>
<pre><code class="java">//添加节点
    public void add(Node node) &#123;
        if(isempty()) &#123;
            root = node;
        &#125;else &#123;
            root.add(node);
        &#125;
        if(rightHeight() -leftHeight() &gt;1) &#123;
            root = leftRotate(root); //传入的是头节点
        &#125;else if(leftHeight() - rightHeight() &gt;1) &#123;
            root = rightRotate(root);
        &#125;
    &#125;
</code></pre>
<p>但是还有一个问题，当左子节点的右子节点高度大于其左子节点时，即使进行右旋转，还是无法将树的两边平衡，如图：</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321124445330.png" alt="image-20210321124445330"></p>
<p>进行右旋转</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321124731525.png" alt="image-20210321124731525"></p>
<p>为了解决这个问题</p>
<ol>
<li>要先将左子节点进行左旋转</li>
<li>再将树进行右旋转</li>
</ol>
<p>最后</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321125031823.png" alt="image-20210321125031823"></p>
<pre><code class="java">    //添加节点
    public void add(Node node) &#123;
        if(isempty()) &#123;
            root = node;
        &#125;else &#123;
            root.add(node);
        &#125;
        if(rightHeight() -leftHeight() &gt;1) &#123;
            //右子树的左子树高度大于其右子树的高度
            if(root.left != null &amp;&amp;root.left.leftHeight() - root.left.rightHeight()&gt;0) &#123;
                //先右旋转
                root.right = rightRotate(root.right);
            &#125;
            root = leftRotate(root);
        &#125;else if(leftHeight() - rightHeight() &gt;1) &#123;
            //左子树的右子树高度大于其左子树的高度
            if(root.left != null &amp;&amp;root.left.rightHeight() - root.left.leftHeight()&gt;0) &#123;
                //先左旋转
                root.left = leftRotate(root.left);
            &#125;
            root = rightRotate(root);
        &#125;
    &#125;
</code></pre>
<h3 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h3><pre><code class="java">package Trees;

public class AVLTreeDemo1 &#123;
    public static void main(String[] args) &#123;
        AVLtree tree = new AVLtree();
//        int[] arr = &#123;4,3,6,5,7,8&#125;;
//        int[] arr = &#123;10,12,8,9,7,6&#125;;
        int[] arr = &#123;10,11,7,6,8,9&#125;;
        for(int i:arr) &#123;
            tree.add(new Node(i));
        &#125;
//        System.out.println(&quot;删除前&quot;);
//        System.out.printf(&quot;树的高度：%d\n&quot;,tree.height());
//        tree.infixOrder();
//        tree.delete(new Node(7));
//        System.out.println(&quot;删除后&quot;);
//        tree.infixOrder();
        System.out.printf(&quot;树的高度：%d\n&quot;,tree.height());
        System.out.printf(&quot;树的左子树高度：%d\n&quot;,tree.leftHeight());
        System.out.printf(&quot;树的右子树高度：%d\n&quot;,tree.rightHeight());
        tree.infixOrder();
    &#125;
&#125;

class AVLtree&#123;
    private Node root = null;
    
    public boolean isempty() &#123;
        return root == null;
    &#125;

    public int height() &#123;
        return root.height();
    &#125;
    
    public int leftHeight() &#123;
        return root.leftHeight();
    &#125;
    
    public int rightHeight() &#123;
        return root.rightHeight();
    &#125;

    //左旋转
    public Node leftRotate(Node head) &#123;
        Node head_node = new Node(head.num);
        head_node.left = head.left;
        head_node.right = head.right.left;
        
        Node right_node = new Node(root.right.num);
        right_node.right = head.right.right;
        right_node.left = head_node;
        head = right_node;
        return head;
    &#125;
    
    //右旋转
    public Node rightRotate(Node head) &#123;
        Node head_node = new Node(head.num);
        head_node.right = head.right;
        head_node.left = head.left.right;
        
        Node left_node = new Node(head.left.num);
        left_node.left = head.left.left;
        left_node.right = head_node;
        head = left_node;
        return head;
    &#125;
    
    
    //添加节点
    public void add(Node node) &#123;
        if(isempty()) &#123;
            root = node;
        &#125;else &#123;
            root.add(node);
        &#125;
        if(rightHeight() -leftHeight() &gt;1) &#123;
            //右子树的左子树高度大于其右子树的高度
            if(root.left != null &amp;&amp;root.left.leftHeight() - root.left.rightHeight()&gt;0) &#123;
                //先右旋转
                root.right = rightRotate(root.right);
            &#125;
            root = leftRotate(root);
        &#125;else if(leftHeight() - rightHeight() &gt;1) &#123;
            //左子树的右子树高度大于其左子树的高度
            if(root.left != null &amp;&amp;root.left.rightHeight() - root.left.leftHeight()&gt;0) &#123;
                //先左旋转
                root.left = leftRotate(root.left);
            &#125;
            root = rightRotate(root);
        &#125;
    &#125;
    
    
    //删除
    public void delete(Node node) &#123;
        if(root == null) &#123;
            System.out.println(&quot;tree is empty&quot;);
            return;
        &#125;else if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.num  == node.num) &#123;
            root = null;
            return;
        &#125;
        Node target = root.Search(node);
        if(target == null) &#123;
            System.out.println(&quot;未找到相关结点&quot;);
            return;
        &#125;
        
        
        Node Parent = root.Parent(node);
        if(Parent == null) &#123;//为头节点
            Node cur = root.left;
            root = root.right;
            if(root == null) &#123;
                root = cur;
                return;
            &#125;
            if(root.left != null)
                root.add(cur);
            return;
        &#125;
        if(Parent.left.num == target.num) &#123;
            Parent.left = target.right;
            if(target.left != null)
                root.add(target.left);
        &#125;else &#123;
            Parent.right = target.right;
            if(target.left != null)
                root.add(target.left);
        &#125;
        
//        System.out.println(target);
//        System.out.println(targetParent);
        
    &#125;
    
    public void infixOrder() &#123;
        if(isempty()) &#123;
            System.out.println(&quot;Root is empty&quot;);
        &#125;else &#123;
            root.infixOrder();
            System.out.println();
        &#125;
    &#125;
&#125;

class Node&#123;
    int num;
    Node left;
    Node right;
    public Node(int num) &#123;
        super();
        this.num = num;
    &#125;
    
    public int leftHeight() &#123;
        return this.left == null ? 0:this.left.height();
    &#125;
    
    public int rightHeight() &#123;
        return this.right == null ? 0:this.right.height();
    &#125;
    
    public int height() &#123;
        return Math.max(this.left == null ? 0: this.left.height(), this.right == null? 0: this.right.height())+1;
    &#125;
    
    public void add(Node node) &#123;
        
        if(this.num &gt; node.num) &#123;
            if(this.left == null) &#123;
                this.left = node; 
                return;
            &#125;else &#123;
                //向左遍历
                this.left.add(node);
            &#125;
            
        &#125;else &#123;
            if(this.right == null) &#123;
                this.right = node;
                return;
            &#125;else &#123;
                //向右遍历
                this.right.add(node);
            &#125;
        &#125;
    &#125;
    
    public Node Search(Node node) &#123;
        if(this.num == node.num) &#123;
            return this;
        &#125;
        if(node.num &lt;this.num) &#123;
            if(this.left == null) &#123;
                return null;
            &#125;
            return this.left.Search(node);
        &#125;else &#123;
            if(this.right == null) &#123;
                return null;
            &#125;
            return this.right.Search(node);
        &#125;
    &#125;
    
    public Node Parent(Node node) &#123;
        if(this.left != null &amp;&amp; this.left.num == node.num|| this.right != null &amp;&amp; this.right.num == node.num) &#123;
            return this;
        &#125;else &#123;
            if(this.left != null &amp;&amp; node.num &lt; this.left.num ) &#123;
                return this.left.Parent(node);
            &#125;else if( this.right != null&amp;&amp;node.num &gt; this.right.num ) &#123;
                return this.right.Parent(node);
            &#125;else &#123;
                return null;//没有父结点
            &#125;
        &#125;
        
    &#125;
    
    
    public void infixOrder() &#123;
        if(this.left != null) &#123;
            this.left.infixOrder();
        &#125;
        
        System.out.print(this+&quot; &quot;);
        
        if(this.right != null) &#123;
            this.right.infixOrder();
        &#125;
    &#125;
    
    @Override
    public String toString() &#123;
        return num+&quot;&quot;;
    &#125;
    
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210321125404279.png" alt="image-20210321125404279"></p>
<h1 id="数据结构：-图"><a href="#数据结构：-图" class="headerlink" title="数据结构： 图"></a>数据结构： 图</h1><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326221246196.png" alt="image-20210326221246196"></p>
<p>图也是数据结构中的一种，YYSY真的经典，学习图可以参考二叉树和二维数组；</p>
<p>直接讲图论可能会十分抽象，毕竟是看文字；数据结构中的图和现实生活中的地铁交通图很类似，如下</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326222530755.png" alt="image-20210326222530755"></p>
<p>我们每一个交通枢纽可以看作是一个顶点，就像上图的A, B, C,D， 从一个枢纽（交叉口）到另一个交叉口之间的线（边）就像上面A,B,C顶点间的线，【用地铁这个解释，应该好理解一点】</p>
<h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><p>顶点Vertex：对象，一个一个存储的小圆点</p>
<p>边Edge：顶点间的连线</p>
<p>无向图：一个顶点与另一个顶点之间的边没有指向，边没有方向</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326223846947.png" alt="image-20210326223846947"></p>
<p>有向图：顶点与顶点间指向有方向</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326223815831.png" alt="image-20210326223815831"></p>
<p>有权图：顶点间的边上有数值</p>
<p>无权图：顶点间的边上没有数值</p>
<h2 id="图的创建"><a href="#图的创建" class="headerlink" title="图的创建"></a>图的创建</h2><p>图在程序中有2种实现方法：邻接矩阵和邻接表</p>
<p><strong>邻接矩阵</strong>：我们根据顶点的个数构建一个二维数组，这个二维数组的横向index与纵向index分别代表对应的顶点，二维数组（矩阵）中存储0或1，0代表2个顶点没有连接，1代表有连接</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327100219549.png" alt="image-20210327100219549"></p>
<p><strong>邻接表</strong>：就像HashTable一样，邻接表由数组与链表一起构成， 数组中的每个index代表不同的顶点，链表中存储的数字是顶点对应的下标</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327101116954.png" alt="image-20210327101116954"></p>
<p><strong>邻接表与邻接矩阵</strong>：很明显，在顶点数量较少的情况下，使用邻接表可以节省更多的空间</p>
<p>下面以邻接矩阵为例，实现图</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>图的主要方法：</p>
<ol>
<li>返回顶点个数</li>
<li>返回有多少条边</li>
<li>获取根据下标获取顶点</li>
<li>添加新的顶点</li>
<li>给新的顶点建立边</li>
<li>显示图</li>
</ol>
<pre><code class="java">package Graphs;

import java.util.ArrayList;
import java.util.LinkedList;

public class Graph &#123;
    private ArrayList&lt;String&gt; vertexList;
    private int[][] edges;
    private int numOfEdges;//边的数目
    
    /**
     * 
     * @param n 传入顶点个数
     */
    Graph(int n)&#123;
        edges = new int[n][n]; //以二维邻接矩阵来构建图 
        vertexList = new ArrayList&lt;&gt;(n);//用于存储顶点信息
        numOfEdges =0;
    &#125;
    
    /**
     * 
     * @return 有多少个顶点
     */
    public int VertexNum() &#123;
        return vertexList.size();
    &#125;
    
    /**
     * 
     * @return 有多少条边
     */
    public int EdgeLength() &#123;
        return numOfEdges;
    &#125;
    
    /**
     * 
     * @param index 传入下标
     * @return 返回对应的顶点
     */
    public String GetVertex(int index) &#123;
        return vertexList.get(index);
    &#125;
    
    /**
     * 
     * @param v1
     * @param v2
     * @return 返回2个顶点的权值
     */
    public int GetWeight(int v1, int v2) &#123;
        return edges[v1][v2];
    &#125;
    
    /**
     * 插入节点
     * @param vertex
     */
    public void InsertVertex(String vertex) &#123;
        vertexList.add(vertex);
    &#125;
    
    /**
     * 
     * @param v1 点1的下标，第几个顶点
     * @param v2 点2的下标，第几个顶点
     * @param weight 表示点1与点2是否相互连接
     */
    public void InsertEdge(int v1, int v2, int weight) &#123;
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    &#125;
    
    //显示邻接矩阵图
    public void ShowGraph() &#123;
        System.out.print(&quot;  &quot;);
        for(int i=0;i&lt;VertexNum();i++)
            System.out.print(vertexList.get(i)+&quot; &quot;);
        System.out.println();
        for(int j=0;j&lt;edges.length;j++) &#123;
            System.out.print(vertexList.get(j));
            for(int k=0;k&lt;edges[0].length;k++) &#123;
                System.out.print(&quot; &quot;+edges[j][k]);
            &#125;
            System.out.println();
        &#125;
    &#125;
    
&#125;
</code></pre>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>我们来实现这一张图：</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326221246196.png" alt="image-20210326221246196"></p>
<pre><code class="java">        Graph graph = new Graph(5);
        String[] arr = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;
        for(String i:arr)
            graph.InsertVertex(i);
        
        graph.InsertEdge(0, 1, 1); //将A与B建立连接
        graph.InsertEdge(0, 2, 1); 
        graph.InsertEdge(2, 3, 1);
        graph.InsertEdge(0, 4, 1);
        graph.InsertEdge(1, 2, 1);
        graph.InsertEdge(2, 4, 1);
        graph.ShowGraph();
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326224407251.png" alt="image-20210326224407251"></p>
<p>在图中有2个经典的遍历方法：深度优先与广度优先</p>
<h2 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h2><p>深度优先：depth first search</p>
<p>利用递归的思想，每次搜索都选取得到的数据中的第一个，一直到最深处，再回溯，判断剩下的有没有被遍历，如果没有，接着深入遍历</p>
<p>这个和二叉树在某些程度上有相似性</p>
<p>我们根据上面这张图来进行深度优先遍历分析</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326221246196.png" alt="image-20210326221246196"></p>
<p>我们先从顶点A开始，查找与A有所连接的顶点，选取第1个进行深度遍历， 进入B，查找与B连接的顶点，这个顶点之前没有遍历过，找到C；进入C遍历，C先发现D，对D进行打印输出后，发现D没有下一个连接，于是返回C顶点；C选取第二个E进行操作，打印E后，发现与E连接的之前都遍历过，于是返回C，返回B，返回A，结束</p>
<p>下面是分析图</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327102703120.png" alt="image-20210327102703120"></p>
<p>为了实现这些操作，我们需要一个boolean数组，来存储顶点是否被遍历过</p>
<p>boolean[ ]  isVisited = new boolean[ VertexNum()];</p>
<pre><code class="java">    /**
     * 
     * @param index 传入指定的index
     * 1. 打印出头顶点
     * 2. 将头顶点isVisited设为true
     * 3. 遍历查找与头顶点相连的顶点且not visited
     * 4. 如果查找到，立马将找到的这个index传入进行递归
     * 
     * 
     */
    
    //deep first search, 深度优先遍历
    public void DFS(int index) &#123;
        System.out.print(GetVertex(index)+&quot; &quot;);
        isVisited[index] = true;
        for(int j=0;j&lt;VertexNum();j++) 
            if(edges[index][j]&gt;0 &amp;&amp; !isVisited[j])
                DFS(j);
        
    &#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327103126805.png" alt="image-20210327103126805"></p>
<h2 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h2><p>广度优先：broad first search</p>
<p>直白点说，广度优先是横着走，横着遍历，继续拿上面的图举例</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210326221246196.png" alt="image-20210326221246196"></p>
<p>我们要先读取A顶点， 打印A，找出与A顶点相连的顶点，发现有B, C, E，将这些点标明isVisited， 把这些顶点存储到容器中（使用队列实现）；从队列中弹出B，打印B，查找与B相连的顶点，若此顶点没有被加入到队列中，压入队列，此时我们发现都在，弹出C， D与C相连且未在队列中， 把D压入队列；弹出E，没有满足条件的其他顶点；弹出D，同上；当队列为空，程序结束</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327104729421.png" alt="image-20210327104729421"></p>
<pre><code class="java">    /**
     * 广度优先使用队列完成
     * 先入队列，isvisited设置为true
     * 进入循环，若队列为空，停止循环
     * 循环中，先弹出一个，打印出来
     * 根据这个顶点查找与其连接，且没有入队列的
     * 如果发现，入队列，isVisited为true
     * 直到循环结束
     * @param index 指向的顶点
     */
    //BFS 广度优先broad first search
    public void BFS(int index) &#123;
        queue.add(index);
        isVisited[index] = true;
        while(!queue.isEmpty()) &#123;
            index = queue.pop();
            
            System.out.print(GetVertex(index)+&quot; &quot;);
            for(int j=0;j&lt;VertexNum();j++) &#123;
                if(edges[index][j] &gt;0 &amp;&amp; !isVisited[j]) &#123;
                    queue.add(j);
                    isVisited[j] = true;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327104800210.png" alt="image-20210327104800210"></p>
<h2 id="总和"><a href="#总和" class="headerlink" title="总和"></a>总和</h2><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="java">package Graphs;

public class Graph_Test &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Graph graph = new Graph(5);
        String[] arr = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;&#125;;
        for(String i:arr)
            graph.InsertVertex(i);
        
        graph.InsertEdge(0, 1, 1);
        graph.InsertEdge(0, 2, 1);
        graph.InsertEdge(2, 3, 1);
        graph.InsertEdge(0, 4, 1);
        graph.InsertEdge(1, 2, 1);
        graph.InsertEdge(2, 4, 1);
        graph.ShowGraph();
        System.out.println(&quot;深度优先&quot;);
        graph.DFS(0);
        graph.ClearVisit();
        System.out.println(&quot;\n广度优先&quot;);
        graph.BFS(0);
    &#125;

&#125;
</code></pre>
<h3 id="图类"><a href="#图类" class="headerlink" title="图类"></a>图类</h3><pre><code class="java">package Graphs;

import java.util.ArrayList;
import java.util.LinkedList;

public class Graph &#123;
    private ArrayList&lt;String&gt; vertexList;
    LinkedList&lt;Integer&gt; queue;
    private int[][] edges;
    private int numOfEdges;//边的数目
    boolean[] isVisited; 
    
    /**
     * 
     * @param n 传入顶点个数
     */
    Graph(int n)&#123;
        edges = new int[n][n]; //以二维邻接矩阵来构建图 
        vertexList = new ArrayList&lt;&gt;(n);//用于存储顶点信息
        queue = new LinkedList&lt;&gt;();
         isVisited= new boolean[n];
        numOfEdges =0;
    &#125;
    
    /**
     * 
     * @return 有多少个顶点
     */
    public int VertexNum() &#123;
        return vertexList.size();
    &#125;
    
    /**
     * 
     * @return 有多少条边
     */
    public int EdgeLength() &#123;
        return numOfEdges;
    &#125;
    
    /**
     * 
     * @param index 传入下标
     * @return 返回对应的顶点
     */
    public String GetVertex(int index) &#123;
        return vertexList.get(index);
    &#125;
    
    /**
     * 
     * @param v1
     * @param v2
     * @return 返回2个顶点的权值
     */
    public int GetWeight(int v1, int v2) &#123;
        return edges[v1][v2];
    &#125;
    
    /**
     * 插入节点
     * @param vertex
     */
    public void InsertVertex(String vertex) &#123;
        vertexList.add(vertex);
    &#125;
    
    /**
     * 
     * @param v1 点1的下标，第几个顶点
     * @param v2 点2的下标，第几个顶点
     * @param weight 表示点1与点2是否相互连接
     */
    public void InsertEdge(int v1, int v2, int weight) &#123;
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    &#125;
    
    /**
     * 
     * @param index 传入指定的index
     * 1. 打印出头顶点
     * 2. 将头顶点isVisited设为true
     * 3. 遍历查找与头顶点相连的顶点且not visited
     * 4. 如果查找到，立马将找到的这个index传入进行递归
     * 
     * 
     */
    
    //deep first search, 深度优先遍历
    public void DFS(int index) &#123;
        System.out.print(GetVertex(index)+&quot; &quot;);
        isVisited[index] = true;
        for(int j=0;j&lt;VertexNum();j++) 
            if(edges[index][j]&gt;0 &amp;&amp; !isVisited[j])
                DFS(j);
        
    &#125;
    
    /**
     * clear isVisited数组
     */
    //清空visited记录
    public void ClearVisit() &#123;
        isVisited= new boolean[VertexNum()];
    &#125;

    

    /**
     * 广度优先使用队列完成
     * 先入队列，isvisited设置为true
     * 进入循环，若队列为空，停止循环
     * 循环中，先弹出一个，打印出来
     * 根据这个顶点查找与其连接，且没有入队列的
     * 如果发现，入队列，isVisited为true
     * 直到循环结束
     * @param index 指向的顶点
     */
    //BFS 广度优先broad first search
    public void BFS(int index) &#123;
        queue.add(index);
        isVisited[index] = true;
        while(!queue.isEmpty()) &#123;
            index = queue.pop();
            
            System.out.print(GetVertex(index)+&quot; &quot;);
            for(int j=0;j&lt;VertexNum();j++) &#123;
                if(edges[index][j] &gt;0 &amp;&amp; !isVisited[j]) &#123;
                    queue.add(j);
                    isVisited[j] = true;
                &#125;
            &#125;
        &#125;
    &#125;
    
    //显示邻接矩阵图
    public void ShowGraph() &#123;
        System.out.print(&quot;  &quot;);
        for(int i=0;i&lt;VertexNum();i++)
            System.out.print(vertexList.get(i)+&quot; &quot;);
        System.out.println();
        for(int j=0;j&lt;edges.length;j++) &#123;
            System.out.print(vertexList.get(j));
            for(int k=0;k&lt;edges[0].length;k++) &#123;
                System.out.print(&quot; &quot;+edges[j][k]);
            &#125;
            System.out.println();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210327103234045.png" alt="image-20210327103234045"></p>
<h1 id="常用数据结构CRUD时间复杂度总结"><a href="#常用数据结构CRUD时间复杂度总结" class="headerlink" title="常用数据结构CRUD时间复杂度总结"></a>常用数据结构CRUD时间复杂度总结</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="Add-O-n"><a href="#Add-O-n" class="headerlink" title="Add:O(n)"></a>Add:O(n)</h3><p>添加时会根据指定的index下标去添加，找到下标后，添加然后移位，同样会花费O(n)的时间，有时Array容量不够，我们还需要扩大Array的容量，所以add最坏时间复杂度是O(n)</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509124701152.png" alt="image-20210509124701152"></p>
<h3 id="Set-O-1-与-Get-O-1"><a href="#Set-O-1-与-Get-O-1" class="headerlink" title="Set:O(1) 与 Get:O(1)"></a>Set:O(1) 与 Get:O(1)</h3><p>Get 与 Set 在进行时，都可以根据下标快速找到位置，所以时间复杂度为O(1)</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509124608575.png" alt="image-20210509124608575"></p>
<h3 id="Remove-O-n"><a href="#Remove-O-n" class="headerlink" title="Remove:O(n)"></a>Remove:O(n)</h3><p>当删除时，由于是ArrayList，需要将后面的内容一个一个向前移动1格，时间复杂度为O(n)</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509124423161.png" alt="image-20210509124423161"></p>
<h2 id="ArraySet"><a href="#ArraySet" class="headerlink" title="ArraySet"></a>ArraySet</h2><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509130909389.png" alt="image-20210509130909389"></p>
<h3 id="Contain-O-n"><a href="#Contain-O-n" class="headerlink" title="Contain:O(n)"></a>Contain:O(n)</h3><p>contain方法用于判断是否存在此元素，由于是无序array，我们需要从头到尾进行遍历，所以为O(n)</p>
<h3 id="Add-O-n-1"><a href="#Add-O-n-1" class="headerlink" title="Add:O(n)"></a>Add:O(n)</h3><p>由于是Set，我们在插入元素时，需要考虑插入的元素是否重复，所以要先调用contain方法判断，然后把元素插入到尾部；因为是array，当room满时，需要ensure capacity扩大容量，此时时间复杂度为O(n)</p>
<h3 id="Remove-O-n-1"><a href="#Remove-O-n-1" class="headerlink" title="Remove:O(n)"></a>Remove:O(n)</h3><p>和arrayList相比，虽然arraySet的remove方法只是将要删除的元素与最后一个进行替换，把最后一个删除，但是在寻找的过程中，时间复杂度依然是O(n)</p>
<h2 id="ArraySortedSet"><a href="#ArraySortedSet" class="headerlink" title="ArraySortedSet"></a>ArraySortedSet</h2><p>这个集合是ArraySet的升级版，当我们存入数据到集合中，我们要对其进行排序，升序或降序</p>
<h3 id="Contain-O-logN"><a href="#Contain-O-logN" class="headerlink" title="Contain:O(logN)"></a>Contain:O(logN)</h3><p>由于是有序的数组，我们可以使用二分查找(Binary Search)算法来查询是否存在，二分查找算法时间复杂度为O(logN)</p>
<h3 id="Add-O-n-2"><a href="#Add-O-n-2" class="headerlink" title="Add:O(n)"></a>Add:O(n)</h3><p>虽然说在ArraySortedSet中，查找相同的时间为log(n)，但是当我们添加新的元素后，有可能破坏整个数组的order，所以add后还需要进行排序，可以用冒泡排序，从后往前比较，直到最佳，此时的时间复杂度为O(n)；</p>
<ul>
<li>有些人可能会说冒泡排序时间复杂度不是O(n^2)吗？</li>
</ul>
<p>其实当我们添加新的元素后，除去新的元素，原数组依然是有序的，我们从后往前，这样最坏时间就是O(n);</p>
<ul>
<li>为什么不用快排？</li>
</ul>
<p>注意，快排最优也仅仅是O(NlogN),在现在这种情境下时间复杂度远远大于冒泡排序</p>
<h3 id="Remove-O-n-2"><a href="#Remove-O-n-2" class="headerlink" title="Remove:O(n)"></a>Remove:O(n)</h3><p>和上面的添加一样，查找时虽然为O(logN)，其最终的最坏时间复杂度依然为O(n),因为需要进行排序最终结果和Add相同：O(n)</p>
<h2 id="SingleLinkedList"><a href="#SingleLinkedList" class="headerlink" title="SingleLinkedList"></a>SingleLinkedList</h2><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509142042381.png" alt="image-20210509142042381"></p>
<h3 id="Add-O-n-3"><a href="#Add-O-n-3" class="headerlink" title="Add:O(n)"></a>Add:O(n)</h3><p>add方法同样要添加到对应的下标，由于是链表，需要从head开头遍历到对应的下标，所以最坏时间复杂度为O(n)</p>
<h3 id="Remove-O-n-3"><a href="#Remove-O-n-3" class="headerlink" title="Remove:O(n)"></a>Remove:O(n)</h3><p>删除分为按下标删除与按内容删除，按index下标删除，需要从头遍历至对应下标，所以最坏时间复杂度与add一样O(n)；按内容删除由于要从头开始匹配相应的内容，最坏时间复杂度依然是O(n)，综上O(n)</p>
<h3 id="Get-O-n-与-Set-O-n"><a href="#Get-O-n-与-Set-O-n" class="headerlink" title="Get:O(n) 与 Set:O(n)"></a>Get:O(n) 与 Set:O(n)</h3><p>为了获取指定下标元素，依然要从头遍历到尾部，所以Get与Set都是O(n)</p>
<h2 id="ArrayStack-1"><a href="#ArrayStack-1" class="headerlink" title="ArrayStack"></a>ArrayStack</h2><h3 id="Push-一般为O-1-但特殊为O-n"><a href="#Push-一般为O-1-但特殊为O-n" class="headerlink" title="Push: 一般为O(1)但特殊为O(n)"></a>Push: 一般为O(1)但特殊为O(n)</h3><p>使用数组来模拟stack，一般入栈都是O(1),但当栈满时需要扩容ensure capacity,导致时间复杂度变为O(n)</p>
<h3 id="Pop-O-1"><a href="#Pop-O-1" class="headerlink" title="Pop: O(1)"></a>Pop: O(1)</h3><p>出栈，都是temp = array[count] = null; count –;  return temp; 所以最坏时间复杂度仅仅是O(1)</p>
<h2 id="LinkedStack"><a href="#LinkedStack" class="headerlink" title="LinkedStack"></a>LinkedStack</h2><h3 id="Pop-O-1-与-Push-O-1"><a href="#Pop-O-1-与-Push-O-1" class="headerlink" title="Pop: O(1) 与 Push:O(1)"></a>Pop: O(1) 与 Push:O(1)</h3><p>stack的操作都是在头部进行，无需遍历，所以是O(1)</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509143147526.png" alt="image-20210509143147526"></p>
<h2 id="LinkedQueue"><a href="#LinkedQueue" class="headerlink" title="LinkedQueue"></a>LinkedQueue</h2><h3 id="Pop-O-1-与-Push-O-1-1"><a href="#Pop-O-1-与-Push-O-1-1" class="headerlink" title="Pop:O(1) 与 Push:O(1)"></a>Pop:O(1) 与 Push:O(1)</h3><p>用2个指针，一个指头，一个指尾，队列是先进先出，出队列pop时操作front指针，时间复杂度为O(1);入队列时操作尾部back指针,时间复杂度为O(1)</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509143313700.png" alt="image-20210509143313700"></p>
<h2 id="Linked-Set"><a href="#Linked-Set" class="headerlink" title="Linked Set"></a>Linked Set</h2><h3 id="contains-O-n"><a href="#contains-O-n" class="headerlink" title="contains:O(n)"></a>contains:O(n)</h3><p>链式存储，在寻找对应结点时都需要从头到尾，时间复杂度都为O(n)</p>
<h3 id="add-O-n-与-remove-O-n"><a href="#add-O-n-与-remove-O-n" class="headerlink" title="add:O(n) 与 remove:O(n)"></a>add:O(n) 与 remove:O(n)</h3><p>由于查找重复元素时间复杂度为O(n)，导致add与remove也是O(n)</p>
<h2 id="BSTtree"><a href="#BSTtree" class="headerlink" title="BSTtree"></a>BSTtree</h2><p>一般情况</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E6%A0%91.jpg"></p>
<p>特殊情况</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509145854486.png" alt="image-20210509145854486"></p>
<h3 id="add-一般O-logN-最坏O-N"><a href="#add-一般O-logN-最坏O-N" class="headerlink" title="add:一般O(logN), 最坏O(N)"></a>add:一般O(logN), 最坏O(N)</h3><p>一般通过比较然后寻找最终的位置，这种比较是O(logN), 但是当整个树变为一条线时，我们要寻找对应的位置，需要遍历整个树才能找到，所以最坏为O(n)</p>
<h3 id="remove-一般O-logN-最坏O-N"><a href="#remove-一般O-logN-最坏O-N" class="headerlink" title="remove: 一般O(logN), 最坏O(N)"></a>remove: 一般O(logN), 最坏O(N)</h3><p>remove的情况与add插入情况一样，当整个树变为一条线时，其最坏时间复杂度也会变为O(N)</p>
<h1 id="Disjoint-Set并查集"><a href="#Disjoint-Set并查集" class="headerlink" title="Disjoint Set并查集"></a>Disjoint Set并查集</h1><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210501132259731.png" alt="image-20210501132259731"></p>
<h2 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h2><p>并查集是一种数据结构，其实现简单，仅仅需要几行代码与一个数组就可以实现；</p>
<ol>
<li>创建一个数组，用于储存每个顶点的父结点，默认都是自己</li>
<li>union合并方法，用于将2个顶点合并在一起</li>
<li>find方法，用于寻找最终的根节点</li>
</ol>
<p>克鲁斯卡尔算法中就运用到并查集的知识，用于寻找2个顶点之间是否构成回路</p>
<p>我们自动生成迷宫时，也会需要使用disjoint方法，当入口与出口构成回路时，我们就完成了迷宫的设计</p>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="java">private int s[];
public Disjoint1(int numElements) &#123;
    s = new int[numElements];
    for(int i=0;i&lt;s.length;i++)
        s[i] = -1; //初始化默认每个点的根节点就是自己，即-1

&#125;
</code></pre>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code class="java">//非递归版本
public int find(int x) &#123;
    int temp=x;
    while(s[temp]!=-1)
        temp = s[temp];
    return temp;
&#125;
</code></pre>
<pre><code class="java">//递归版本
public int find(int x) &#123;
    if(s[x] &lt;0)
        return x;
    else &#123;
        return find(s[x]); 
    &#125;
&#125;
</code></pre>
<h3 id="并"><a href="#并" class="headerlink" title="并"></a>并</h3><pre><code class="java">public void union(int root1, int root2) &#123;
    if(s[root2]&lt;s[root1]) //root2 is depper
        s[root1] = root2; //make root2 new root
    else &#123;
        if(s[root1] == s[root2]) 
            s[root1] --;  //Update height if same
        s[root2] = root1; //make root1 new root

    &#125;

&#125;
</code></pre>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>对于路径压缩，我们是在find函数中进行修改，当我们寻找到一个顶点的根节点后，在递归时，我们把剩下的顶点的根节点都设为最后一个顶点的根节点，这样可以简化下次递归的深度</p>
<pre><code class="java">public int find(int x) &#123;
    if(s[x] &lt;0)
        return x;
    else &#123;
        return s[x] = find(s[x]); //path compression, decrease the running time
    &#125;
&#125;
</code></pre>
<p>当然，这种方法也有个缺点，如下图</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210501132306016.png" alt="image-20210501132306016"></p>
<p>我们如果使用find(4),这样可以使整个树扁平化</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210501132444325.png" alt="image-20210501132444325"></p>
<p>但是如果我们使用find(3)，最后只能使包含3在内的之前的顶点扁平化</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210501132545706.png" alt="image-20210501132545706"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="判断是否构成环路"><a href="#判断是否构成环路" class="headerlink" title="判断是否构成环路"></a>判断是否构成环路</h3><p>传入一个二维数组，包含这张图的信息</p>
<p>每个顶点对应的下标按照英文字母的顺序排列，从0开始</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210501144130550.png" alt="image-20210501144130550"></p>
<pre><code class="java">package DisjointSet;

public class CircleJudge &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[][] a= &#123;
                &#123;0, 1&#125;,
                &#123;0, 2&#125;,
                &#123;0, 4&#125;,
                &#123;1, 2&#125;,
                &#123;2, 4&#125;,
                &#123;2, 3&#125;,
        &#125;;
        isCircle(a, 5);
    &#125;
    
    private static int[] p;
    
    /*查找root*/
    private static int find(int x) &#123;
        if(p[x] &lt;0)
            return x;
        else &#123;
            return p[x] = find(p[x]);
        &#125;
    &#125;
    
    
    /*合并,前提是没构成环路*/
    //构成环路返回true
    private static boolean union(int i, int j) &#123;
        int x=find(i);
        int y =find(j);
        if(x!=y) &#123;
            if(p[y] &lt; p[x])
                p[x]= y;
            else &#123;
                p[y] =x;
            &#125;
            return false;
        &#125;else &#123;
            return true;
        &#125;
    &#125;
    
    public static void isCircle(int[][] a, int len) &#123;
        /*初始化*/
        p = new int[len];
        for(int i=0;i&lt;p.length;i++)
            p[i]=-1;
        
        
        boolean rst;
        for(int[] i:a) &#123;
            rst = union(i[0],i[1]);
            if(rst) &#123;
                System.out.println(&quot;These data include circle&quot;);
                break;
            &#125;
        &#125;
        
    &#125;

&#125;
</code></pre>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><pre><code class="java">package algorithm;

import java.util.Collections;
import java.util.LinkedList;

/**
 * Kruskar算法
 * 1. 创建每条边的List
 * 2. 把边添加进List
 * 3. 对List排序
 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路
 * @author 23881
 *
 */
public class KruskalAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        
//        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;;
//        int[][] weight= &#123;
//                &#123;0,3,3,7&#125;,
//                &#123;3,0,2,4&#125;,
//                &#123;3,2,0,6&#125;,
//                &#123;7,4,6,0&#125;
//        &#125;;
        
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] weight= &#123;
                &#123;0,12,0,0,0,16,14&#125;,
                &#123;12,0,10,0,0,7,0&#125;,
                &#123;0,10,0,3,5,6,0&#125;,
                &#123;0,0,3,0,4,0,0&#125;,
                &#123;0,0,5,4,0,2,8&#125;,
                &#123;16,7,6,0,2,0,9&#125;,
                &#123;14,0,0,0,8,9,0&#125;
        &#125;;
        
        Kruskar(data, weight);
        

    &#125;
    
    public static void Kruskar(String[] data, int[][] weight) &#123;
        boolean[][] isVisited = new boolean[data.length][data.length];
        LinkedList&lt;Edge&lt;String&gt;&gt; list =  new LinkedList&lt;&gt;();
        LinkedList&lt;Edge&lt;String&gt;&gt; result =  new LinkedList&lt;&gt;();
        for(int i=0;i&lt;weight.length;i++) &#123;
            for(int j=0;j&lt;weight.length;j++) &#123;
                if(isVisited[i][j] == false&amp;&amp; isVisited[j][i] == false &amp;&amp; weight[i][j] != 0) &#123;
                    list.add(new Edge&lt;String&gt;(i, j, weight[i][j]));
                    isVisited[i][j] = true;
                    isVisited[j][i] = true;
                &#125;
            &#125;
        &#125;
        
        Collections.sort(list);
        for(Edge&lt;String&gt; e:list) 
            System.out.println(e.print(data));
        System.out.println();
        
        int[] ends = new int[data.length];
        for(Edge&lt;String&gt; e:list) &#123;
            if(result.size() == data.length-1)
                break;
            
            
            //克鲁斯卡尔算法精髓, Disjoint Set
            int m = GetEnd(ends, e.x);
            int n = GetEnd(ends, e.y);
            //判断终点是否是一样的，即是否形成回路
            if(m !=n) &#123;
                ends[m]=n;
                result.add(e);
            &#125;
                
            
            
            
        &#125;
        
        for(Edge&lt;String&gt; e:result) 
            System.out.println(e.print(data));
    

        
        
    &#125;
    
    /**
     * 获取对应下标的终点
     * @param ends
     * @param i
     * @return
     */
    private static int GetEnd(int[] ends, int i) &#123;
        while(ends[i] !=0)
            i = ends[i];
        return i;
    &#125;
    
    private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123;
        public int x;
        public int y;
        public int weight;
        Edge(int a, int b, int w)&#123;
            x = a;
            y = b;
            weight = w;
        &#125;
        
        public String print(E[] data) &#123;
            return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight;
        &#125;

        @Override
        public int compareTo(Edge&lt;String&gt; e) &#123;
            // TODO Auto-generated method stub
            return weight -e.weight;
        &#125;
        
    &#125;

&#125;
</code></pre>
<h1 id="算法：递归"><a href="#算法：递归" class="headerlink" title="算法：递归"></a>算法：递归</h1><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>递归是一种常见的算法，由递归书写的代码较为简洁，一般用于处理有规律的循环问题，与for类似。直白点说，递归就是函数自己调用自己；在使用递归时，注意留出口（递归循环结束），否则程序会无限递归下去，最终ERROR。当然因为递归表示比较简洁，理解起来也是算法的一大难点。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>下面写2个关于递归的例子：</p>
<ol>
<li>打印3！(3的阶乘)</li>
<li>从0到9报数</li>
</ol>
<pre><code class="java">//计算阶乘
package DataStructure;

public class FactorialWithRecursion &#123;
    public static void main(String[] args) &#123;
        System.out.println(factorial(3));
    &#125;
    public static int factorial(int n) &#123;
        if (n == 1) &#123;//出口
        return n;
        &#125;
        return n*factorial(n-1);
            
    &#125;
&#125;
</code></pre>
<p>递归的本质还是栈，当要运行一道程序时，java虚拟机会在栈中开辟一道空间</p>
<p>下面用一张图来说明这几行代码</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210224183503805.png" alt="image-20210224183503805"></p>
<p>假如我们没有给出对应的出口，n==1,编译器会报错</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210224183613709.png" alt="image-20210224183613709"></p>
<p>从0到9报数</p>
<pre><code class="java">package DataStructure;

public class RecursionDemo2 &#123;
    public static void main(String[] args) &#123;
        System.out.println(print(9));
    &#125;
    public static int print(int num) &#123;
        if(num==0) &#123;
            return 0;
        &#125;
        System.out.println(print(num-1));
        return num;
        
    &#125;
&#125;
</code></pre>
<h5 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h5><p>排列：上，下，左，右</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210225114403789.png" alt="image-20210225114403789"></p>
<p>很明显，上下左右的排列可以用递归来完成</p>
<ol>
<li>需要2个容器，一个容器temp来存储暂时读取的字符，还有一个list用来存储最终结果</li>
<li>每次把字符存入temp时，要考虑temp中是否包含此字符，(用for遍历)如果有，跳过添加</li>
<li>当暂时存储的容器temp为4时，把此时temp中的字符串存入list，然后返回</li>
<li>返回后要将temp最后一个元素清除，例如：此时temp是“上下左右”，添加进list后，去除temp最后一个元素，temp就是“上下左”，由于此时for已循环，回到上一个递归：temp为“上下右”</li>
</ol>
<p>暂时容器使用stringbuffer</p>
<p>最终容器使用arraylist</p>
<pre><code class="java">package DataStructure;

import java.util.ArrayList;

public class DirectionRecursion &#123;
    public static void main(String[] args) &#123;
        char[] directions = &#123;&#39;上&#39;,&#39;下&#39;,&#39;左&#39;,&#39;右&#39;&#125;;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 
        test(list, directions, new StringBuffer());
        Iterator&lt;String&gt; itr = list.iterator();
        int count = 0;
        while(itr.hasNext()) &#123;
            System.out.println(itr.next());
            count+=1;
        &#125;
        System.out.println(&quot;一共有&quot;+count+&quot;种可能&quot;);
        
    &#125;
    public static void test(ArrayList&lt;String&gt; list,char[] directions,StringBuffer temp) &#123;
        
        if(temp.length() == directions.length) &#123;
            list.add(temp.toString());
            return;
        &#125;
        
        for(int i=0;i&lt;directions.length;i++) &#123;
            if(temp.toString().indexOf(directions[i])!=-1) continue;
            temp.append(directions[i]);
            test(list, directions, temp);
            temp.deleteCharAt(temp.length()-1);
            
        &#125;
        
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210225113653927.png" alt="image-20210225113653927"></p>
<h3 id="利用递归解决迷宫问题"><a href="#利用递归解决迷宫问题" class="headerlink" title="利用递归解决迷宫问题"></a>利用递归解决迷宫问题</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>问题：小球在迷宫中运动，怎样到达终点</p>
<ol>
<li>使用二维数组先创建迷宫</li>
<li>创建一个boolean方法，接收map和初始位置i, j</li>
<li>数字1表示墙，数字2表示可以走的点，数字3表示不能走的点</li>
</ol>
<p>当小球寻路时（下-&gt;右-&gt;左-&gt;上），我们需要用递归的方法：</p>
<p>先判断小球是否已经到达终点，到达终点，返回true</p>
<p>没有就进入寻路的递归中：我们假设下一步能走的通，即map[i] [j] =2； 先向下走得通，返回true，直到走不通，将走不通的点标为3，返回false（返回上一个位置）；向下继续走不通，就向右走，循环递归，直到走不通为止；</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">package DataStructure;

public class MazeRecursionDemo &#123;
    public static void main(String[] args) &#123;
        // 构建地图
        int[][] map = new int[10][10];
        for (int a = 0; a &lt; map[0].length; a++) &#123;
            map[0][a] = 1;
            map[map.length - 1][a] = 1;
        &#125;
        for (int b = 0; b &lt; map.length; b++) &#123;
            map[b][0] = 1;
            map[b][map[0].length - 1] = 1;
        &#125;
        map[1][5] = 1;
        map[2][5] = 1;
        map[3][5] = 1;
        map[3][1] = 1;
        map[3][2] = 1;
        map[3][3] = 1;
        map[5][3] = 1;
        map[5][4] = 1;
        map[5][5] = 1;
        map[5][6] = 1;
        map[5][7] = 1;
        map[5][8] = 1;
        System.out.println(&quot;\t地图&quot;);
        for (int i = 0; i &lt; map.length; i++) &#123;
            for (int j = 0; j &lt; map[0].length; j++) &#123;
                System.out.print(map[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        tryWay(map, 1,1);
        System.out.println();
        System.out.println(&quot;\t路线&quot;);
        for (int i = 0; i &lt; map.length; i++) &#123;
            for (int j = 0; j &lt; map[0].length; j++) &#123;
                System.out.print(map[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;

    &#125;

    public static boolean tryWay(int[][] map, int i, int j) &#123;
        //如果到达终点，直接返回true，程序结束
        if (map[8][8] == 2) &#123;
            return true;
        &#125; 
        //没有到达终点
        else &#123;
            //如果所在位置之前没有走过，之前走过标为2，也不能走
            if(map[i][j] ==0) &#123;
                //假设能走通
                map[i][j] = 2;
                //向下走得通
                if (tryWay(map, i+1, j)) &#123;
                    return true;
                &#125; 
                //向右走得通
                else if (tryWay(map, i, j+1)) &#123;
                    return true;
                &#125; 
                //向左走得通
                else if (tryWay(map, i, j - 1)) &#123;
                    return true;
                &#125;
                //向上走得通
                else if (tryWay(map, i-1, j)) &#123;
                    return true;
                &#125;
                //上下左右都走不通
                else &#123;
                    //表示这个点不能走，返回上一个节点
                    map[i][j] = 3;
                    return false;
                &#125;
            &#125;
            //所在位置是墙，或不能走的位置，或已经走过的地方
            else &#123;
                //map[i][j] =1或2或3
                return false; //返回false，返回上一个节点位置
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210226192618665.png" alt="image-20210226192618665"></p>
<h4 id="迷宫最优解（目前）"><a href="#迷宫最优解（目前）" class="headerlink" title="迷宫最优解（目前）"></a>迷宫最优解（目前）</h4><p>小球在迷宫中移动，其走的路径长短很大一部分与其设定的方向有关，当我们开始递归时，小球的方向就已经确定下来，所以为了找出小球按照哪种方向形式走才能达到最小路径，我们需要使用排列组合；通过“上下左右”的排列组合，得出所有方向，然后在程序中我们要小球按照我们给出的方向行走，最终统计步数，相比较得出最佳方向</p>
<p>“上下左右”的排列组合上文已经给出解法，下面我们要与前面的迷宫程序相结合</p>
<p>因为小球在迷宫中走的方向都是我们设定好的，所以在递归时我们要加上一个String direction</p>
<pre><code class="java">for(int a=0;a&lt;4;a++) &#123;
    //由于一定要判断上下左右的方向，但是顺序不同，我用一个for循环来读取direction中的四个方向
    switch (direction.charAt(a)) &#123;
        case &#39;上&#39;:
            //向上走得通
            if (tryWay(map, i-1, j,direction)) &#123;
                return true;
            &#125;
            break;
        case &#39;下&#39;:
            //向下走得通
            if (tryWay(map, i+1, j, direction)) &#123;
                return true;
            &#125; 
            break;
        case &#39;左&#39;:
            //向左走得通
            if (tryWay(map, i, j - 1, direction)) &#123;
                return true;
            &#125;
            break;
        case &#39;右&#39;:
            //向右走得通
            if (tryWay(map, i, j+1, direction)) &#123;
                return true;
            &#125; 
            break;

        default:
            break;
    &#125;
&#125;
</code></pre>
<h5 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h5><pre><code class="java">package DataStructure;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;


public class MazeRecursionDemo2 &#123;
    public static void main(String[] args) &#123;
        // 构建地图
        int[][] map = new int[10][10];
        InitMap(map); //地图初始化
        System.out.println(&quot;\t地图&quot;);
        PrintMap(map);
        
        //求出最短路径
        char[] directions = &#123;&#39;上&#39;,&#39;下&#39;,&#39;左&#39;,&#39;右&#39;&#125;;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        Search(list, directions, new StringBuffer());
        
        //Map是用来储存此时的方向与小球运动步数的
        HashMap&lt;String, Integer&gt; dic = new HashMap&lt;&gt;();
        
        Iterator&lt;String&gt; itr = list.iterator();
        while(itr.hasNext()) &#123;
            String move = itr.next();
            //寻路
            tryWay(map, 1,1,move);
            //统计方向与步数
            dic.put(move, Count(map));
            //完了要将map还原（初始化）
            InitMap(map);
        &#125;
        System.out.println();
        System.out.println(&quot;所有方向可能性与步数&quot;);
        //集合的打印
        for(Entry&lt;String, Integer&gt; i : dic.entrySet()) &#123;
            System.out.println(&quot;\t&quot;+i.getKey()+&quot;----&quot;+i.getValue());
        &#125;
        
        //在集合中比较大小
        Collection&lt;Integer&gt; values = dic.values();
        int smallest = Collections.min(values);
        
        System.out.println();
        System.out.println(&quot;最优的路径----步数：&quot;+smallest);
        for(Entry&lt;String, Integer&gt; i : dic.entrySet()) &#123;
            if(i.getValue() == smallest) &#123;
                System.out.println(&quot;\t&quot;+i.getKey());
                tryWay(map, 1,1,i.getKey());
                PrintMap(map);
                InitMap(map);
            &#125;
        &#125;
        
        
    &#125;
    
    //打印地图
    public static void PrintMap(int[][] map) &#123;
        for (int i = 0; i &lt; map.length; i++) &#123;
            for (int j = 0; j &lt; map[0].length; j++) &#123;
                System.out.print(map[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
    
    //初始化地图
    public static void InitMap(int[][] map) &#123;
        for (int i = 0; i &lt; map.length; i++) &#123;
            for (int j = 0; j &lt; map[0].length; j++) &#123;
                map[i][j] =0;
            &#125;
        &#125;
        for (int a = 0; a &lt; map[0].length; a++) &#123;
            map[0][a] = 1;
            map[map.length - 1][a] = 1;
        &#125;
        for (int b = 0; b &lt; map.length; b++) &#123;
            map[b][0] = 1;
            map[b][map[0].length - 1] = 1;
        &#125;
        map[1][5] = 1;
        map[2][5] = 1;
        map[3][5] = 1;
        map[3][1] = 1;
        map[3][2] = 1;
        map[3][3] = 1;
        map[5][3] = 1;
        map[5][4] = 1;
        map[5][5] = 1;
        map[5][6] = 1;
        map[5][7] = 1;
        map[5][8] = 1;
    &#125;
    
    //统计小球走的路径距离
    public static int Count(int[][] map) &#123;
        int cnt=0;
        for (int i = 0; i &lt; map.length; i++) &#123;
            for (int j = 0; j &lt; map[0].length; j++) &#123;
                if(map[i][j] ==2 ||map[i][j] ==3) &#123;
                    cnt++;
                &#125;
            &#125;
        &#125;
        return cnt;
    &#125;
    
    //使用递归改变方向（上下左右的排列组合）
    public static void Search(ArrayList&lt;String&gt; list,char[] directions,StringBuffer sb) &#123;
        if(sb.length() == directions.length) &#123;
            list.add(sb.toString());
            
            return;
        &#125;
        for(int i=0;i&lt;directions.length;i++) &#123;
            if(sb.toString().indexOf(directions[i])!=-1) continue;
            sb.append(directions[i]);
            Search(list, directions, sb);
            sb.deleteCharAt(sb.length()-1);
            
        &#125;
        
    &#125;
    
    
    //使用递归寻找出口
    public static boolean tryWay(int[][] map, int i, int j, String direction) &#123;
        //如果到达终点，直接返回true，程序结束
        if (map[8][8] == 2) &#123;
            return true;
        &#125; 
        //没有到达终点
        else &#123;
            //如果所在位置之前没有走过，之前走过标为2，也不能走
            if(map[i][j] ==0) &#123;
                //假设能走通
                map[i][j] = 2;
                for(int a=0;a&lt;4;a++) &#123;
                    switch (direction.charAt(a)) &#123;
                    case &#39;上&#39;:
                        //向上走得通
                        if (tryWay(map, i-1, j,direction)) &#123;
                            return true;
                        &#125;
                        break;
                    case &#39;下&#39;:
                        //向下走得通
                        if (tryWay(map, i+1, j, direction)) &#123;
                            return true;
                        &#125; 
                        break;
                    case &#39;左&#39;:
                        //向左走得通
                        if (tryWay(map, i, j - 1, direction)) &#123;
                            return true;
                        &#125;
                        break;
                    case &#39;右&#39;:
                        //向右走得通
                        if (tryWay(map, i, j+1, direction)) &#123;
                            return true;
                        &#125; 
                        break;
                    
                    default:
                        break;
                    &#125;
                &#125;
                
                
                //上下左右都走不通
                //表示这个点不能走，返回上一个节点
                map[i][j] = 3;
                return false;
                
            &#125;
            //所在位置是墙，或不能走的位置，或已经走过的地方
            else &#123;
                //map[i][j] =1或2或3
                return false; //返回false，返回上一个节点位置
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210227142025240.png" alt="image-20210227142025240"></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210227142039257.png" alt="image-20210227142039257"></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>题目：需要在8*8的棋盘上摆棋子，每行摆一个，每个棋子不能在同一列或同一对角线上</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210226192021931.png" alt="image-20210226192021931"></p>
<p>需要用到回溯思想，比如第4行的棋子不能放在和第3行棋子的同一列上，为了避免这样，第4行的棋子在第四行上一个一个试，假如都不可以，回到第3行，更改第3行的棋子位置，再尝试第4行，戒指第5行，不行就往回</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><pre><code class="java">package DataStructure;

public class EightGueenDemo &#123;
    //定义一个max表示一共有多少个皇后
    int max =8;
    //定义一个一维数组，数组下标表示第几行，下标对应的数表示第几列
    int[] array =new int[max];
    int count=0;
    public static void main(String[] args) &#123;
        EightGueenDemo queen = new EightGueenDemo();
        queen.check(0);
        System.out.printf(&quot;一共有%d种可能&quot;,queen.count);

    &#125;
    
    //打印数组
    public void print() &#123;
        for(int i=0;i&lt;array.length;i++) &#123;
            System.out.print(array[i]+&quot; &quot;);
        &#125;
        System.out.println();
    &#125;
    
    //判断是否安全(冲突)
    //n表示第n个皇后
    public boolean safe(int n) &#123;
        for(int i=0;i&lt;n;i++) &#123;
            //表示在同一列或同一斜线
            if(array[i] ==array[n] || Math.abs(n-i)==Math.abs(array[n] - array[i])) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
    
    //编写方法，放置第n个皇后
    public void check(int n) &#123;
        if(n==max) &#123;
            print();
            count++;
            return;
        &#125;
        //一共要放8个皇后，8个循环递归，
        for(int i=0;i&lt;max;i++) &#123;
            //先把该皇后放在第n行第i列
            array[n] =i;
            //是否冲突
            if(safe(n)) &#123;
                //如果不冲突，接着放第n+1个皇后，递归
                check(n+1);
            &#125;
            //如果冲突，i++,将皇后在第n行向后移动一位，直到不冲突
        &#125;
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210226192101084.png" alt="image-20210226192101084"></p>
<h1 id="算法：排序算法"><a href="#算法：排序算法" class="headerlink" title="算法：排序算法"></a>算法：排序算法</h1><h2 id="最优"><a href="#最优" class="headerlink" title="最优"></a>最优</h2><p>有一句谚语：“All roads lead to Rome.” 面对一个编程问题时，我们有多种方法来实现；</p>
<p>但是怎样才能判断哪种方法才是最优的呢？</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/u=1304647842,610354735&fm=26&gp=0.jpg"></p>
<p>我们运行程序，当然希望程序越快，占内存越小；但是速度与空间，就像杠杆中的力臂与力，两者必须做出取舍。如果选择速度快，即时间复杂度小，程序所占内存空间的大小就会增加；而希望程序占内存小，程序运行的速度也会随之受影响。</p>
<p>当然，现如今大家考虑最优一般是从速度（时间复杂度）的角度出发。</p>
<h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>时间频度，一个算法中的语句执行的次数称为时间频度，记作T(n)</p>
<p>随着程序规模的变大，时间频度的常数项、低次项、系数可以忽略</p>
<h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><p>同样是计算100以内数的和，我们有2种实现方法</p>
<pre><code class="java">int total =0;
//1， for循环相加
int end=100;
for(int i=1;i&lt;=end;i++)&#123;
    total += i;
&#125;

//2，利用等差数列公式
total =(1+end)*end /2;
</code></pre>
<p>第一种方法的时间频度：T(n) = n+1  //因为进入循环+判断</p>
<p>第二种方法的时间频度：T(n) = 1 //直接计算得出结果</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度，也叫大O时间复杂度，表示方法是O(n)</p>
<p>由于程序规模的变大，时间频度有些地方可以忽略，从而产生了时间复杂度</p>
<p>例如，T(n) = n^2 +7n+6 ; T(n) = 3n^2 +2n+2</p>
<p>两者虽然时间频度不同，但是时间复杂度确实一样，都是O(n^2)</p>
<table>
<thead>
<tr>
<th>常见的时间复杂度</th>
<th>阶</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>常数阶</td>
<td>O(1)</td>
<td>12</td>
</tr>
<tr>
<td>对数阶</td>
<td>O(logn)</td>
<td>5log2n+20</td>
</tr>
<tr>
<td>平方阶(双层for循环)</td>
<td>O(n^2)</td>
<td>3n^2+2n+1</td>
</tr>
<tr>
<td>线性阶</td>
<td>O(n)</td>
<td>2n+3</td>
</tr>
<tr>
<td>线性对数阶</td>
<td>O(nlogn)</td>
<td>2n+3nlog2n+19</td>
</tr>
<tr>
<td>立方阶(三层for循环)</td>
<td>O(n^3)</td>
<td>6n^3+2n^2+3n+4</td>
</tr>
<tr>
<td>指数阶(要尽量避免)</td>
<td>O(2^n)</td>
<td>2^n+3</td>
</tr>
<tr>
<td>k次方阶</td>
<td>O(n^k)</td>
<td>n^k</td>
</tr>
</tbody></table>
<p>时间复杂度排序，由小变大：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(n^k) &lt; O(2^n)</p>
<h2 id="冒泡排序（Bubble-Sorting）"><a href="#冒泡排序（Bubble-Sorting）" class="headerlink" title="冒泡排序（Bubble Sorting）"></a>冒泡排序（Bubble Sorting）</h2><p>用2个指针比较2个数，从左往右，如果第1个大于第2个，两个数交换位置</p>
<p>因为排序的数字是一个一个累加的，所以称之为冒泡排序</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210228221715602.png" alt="image-20210228221715602"></p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210228222824017.png" alt="image-20210228222824017"></p>
<ol>
<li>将指针从左往右遍历，需要一次for循环</li>
<li>至多遍历4次，才能达到最终的顺序，还需要for循环</li>
</ol>
<p>第1次遍历完后，数组最后一个元素可以不用比较了， 所以for循环大小-1，也就是说：</p>
<p>第一次 —- array.length -1</p>
<p>第二次 —- array.length -2</p>
<p>第三次 —- array.length -3</p>
<p>第四次 —- array.length -4</p>
<p>所以：</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class BubbleSorting &#123;
    public static void main(String[] args) &#123;
        int[] array = &#123;3, 9, -1, 10, -2&#125;;
        int tmp =0;
        for(int i=array.length-1; i&gt;0; i--) &#123;
            for(int j=0;j&lt;i;j++) &#123;
                if(array[j] &gt; array[j+1]) &#123;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] =tmp;
                &#125;
            &#125;
        &#125;
        System.out.println(Arrays.toString(array));
    &#125;
&#125;
</code></pre>
<p>冒泡排序优化</p>
<p>假设给出的数组原来就是有序的，或仅仅经过2次就正序了，我们可以直接跳出循环，中止程序</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class BubbleSorting &#123;
    public static void main(String[] args) &#123;
//        int[] array = &#123;3, 9, -1, 10, -2&#125;;
        int[] array = &#123;3,2,6,4,5&#125;;
        int tmp =0;
        boolean flag=false; //flag判断是否进行了排序交换
        for(int i=array.length-1; i&gt;0; i--) &#123;
            for(int j=0;j&lt; i;j++) &#123;
                if(array[j] &gt; array[j+1]) &#123;
                    tmp = array[j];
                    array[j] = array[j+1];
                    array[j+1] =tmp;
                    flag = true;
                &#125;
            &#125;
            System.out.println(&quot;第&quot;+(array.length-i)+&quot;次遍历&quot;);
            System.out.println(Arrays.toString(array));
            if(!flag) &#123;
                break;
            &#125;else &#123;
                flag = false; //用于判断下一次有没有交换，如果没有，表示数据已正序
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210228225103859.png" alt="image-20210228225103859"></p>
<p>第1次遍历在交换顺序，第2次遍历判断是否正序</p>
<p>因为有2个嵌套式的循环，冒泡排序的时间复杂度是n^2</p>
<h2 id="选择排序（Select-Sorting）"><a href="#选择排序（Select-Sorting）" class="headerlink" title="选择排序（Select Sorting）"></a>选择排序（Select Sorting）</h2><p>选择排序和冒泡排序很像，但是两者还是有所区别</p>
<p>在选择排序中，我们要选择最小的数据，并把最小的数据放到整个数组最前面</p>
<p>当我们遍历数组查找最小元素时，我们仅仅记下最小元素下标，只有当前数组遍历结束时，数组才会发生交换，效率相比于冒泡排序（每次遍历都要相互交换）大大提高。</p>
<pre><code class="java">int[] array = &#123;101,34,119,1&#125;;
//第一轮将最小的移到最前面 1, 34, 119, 101
//第二轮将剩下的最小的移到前面 1, 34, 119, 101
//第三轮将剩下的最小的移到前面 1，34，101，119
</code></pre>
<p>从上我们可以看出，每次循环遍历后，初始位置都会向后挪1位（因为最小的已经在前面了）</p>
<p>我们依次比较剩下的数，所以需要array.length-1次才能将数从小到大依次移到前面</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class SelectionSorting &#123;

    public static void main(String[] args) &#123;
        int[] array = &#123;101,34,119,1&#125;;
        
        for(int i=0;i&lt;array.length-1;i++) &#123;
            int smallest=i;
            for(int j=i;j&lt;array.length;j++) &#123;
                if(array[j]&lt; array[smallest]) &#123;
                    smallest = j;//我们仅仅记下最小元素下标
                &#125;
            &#125;
            
            //结束遍历后才能发生交换
            if(i!=smallest) &#123;
                int temp = array[i];
                array[i] = array[smallest];
                array[smallest] = temp;
            &#125;
            System.out.println(&quot;第&quot;+(i+1)+&quot;轮循环：&quot;+Arrays.toString(array));
        &#125;
        
        
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210301133320597.png" alt="image-20210301133320597"></p>
<h2 id="插入排序（Insert-Sorting）"><a href="#插入排序（Insert-Sorting）" class="headerlink" title="插入排序（Insert Sorting）"></a>插入排序（Insert Sorting）</h2><p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png"></p>
<p>第1轮：我们从第2个数开始，把第2个数和前面的数进行比较，从右往左，如果第2个数小于第1个数，两者交换位置</p>
<p>第2轮：我们从第3个数开始，把第3个数和前面的数进行比较（0，1），如果第3个数小于第2个数，两者交换，如果交换后，第1个数比交换后的第2个数大，继续交换，直至到最后</p>
<p>……</p>
<p>第n轮：从第n+1个数开始，把第n+1个数和前面的数(n个数)进行比较，找个合适的地方插入（这就是插入排序）</p>
<p>一共有array.length-1轮</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class InsertSorting &#123;

    public static void main(String[] args) &#123;
        int[] array = &#123; 93, 54, 77, 31, 44, 226, 55 &#125;;
        int temp;
        //换位法
        for (int i = 1; i &lt; array.length; i++) &#123;
            for (int j = i; j &gt; 0; j--) &#123;
                if (array[j] &lt; array[j - 1]) &#123;
                    temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                &#125;else &#123;
                    break;
                &#125;
            &#125;
//移位法
//            temp = array[i];
//            int j =i;
//            while(j&gt;0 &amp;&amp; temp&lt;array[j-1]) &#123;
//                array[j] = array[j - 1];
//                j--;
//            &#125;
//            
//            if (j != i) &#123;
//                array[j] = temp;
//            &#125;
            System.out.println(&quot;第&quot; + i + &quot;轮：&quot; + Arrays.toString(array));
        &#125;

    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210301163004626.png" alt="image-20210301163004626"></p>
<h2 id="希尔排序（Shell-Sorting）"><a href="#希尔排序（Shell-Sorting）" class="headerlink" title="希尔排序（Shell Sorting）"></a>希尔排序（Shell Sorting）</h2><p>希尔排序是由希尔所发现的，所以命名为Shell Sorting. 希尔排序本质上还是插入排序Insert Sorting, 但是希尔排序运行效率相比上面大大提升。</p>
<p>第一轮：</p>
<p>排序前要先给数据分组，让数组的长度/2，即array.length /2, 得出的是组中数据的间隔。我们在分好的组内进行插入排序，间距此时是array.length 除以2。第1组插入排序进行完后，移入第2组，依次进行，直到最后一组。</p>
<p>第二轮：</p>
<p>总体和上面一样，但是每组数据的间隔是之前的一半，(array.length/2)/2</p>
<p>…</p>
<p>直到最后一轮，步数为1，普通的插入排序，但是遍历次数减少</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3017381794,2063417424&fm=26&gp=0.jpg" alt="点击查看源网页"></p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class ShellSorting &#123;

    public static void main(String[] args) &#123;
        int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;;
        
        int length = array.length;
        int temp;
        //步长
        for(int step = length/2;step &gt;0; step /=2) &#123;
            //插入算法循环次数
            for(int i=step;i&lt;length;i++) &#123;
                //控制插入算法的比较和交换
                //移位法
                temp = array[i];
                int j =i;
                if(array[j] &lt; array[j-step]) &#123;
                    while(j&gt;=step &amp;&amp; temp&lt;array[j-step]) &#123;
                        array[j] = array[j - step];
                        j-=step;
                    &#125;
                &#125;
                
                array[j] = temp;
                
                
                /**
                 * 换位法
                for(int j=i;j&gt;=step;j-=step) &#123;
                    if(array[j]&lt;array[j-step]) &#123;
                        temp = array[j];
                        array[j] = array[j-step];
                        array[j-step] = temp;
                    &#125;
                    else
                        break;
                &#125;
                */
            &#125;
            System.out.println(Arrays.toString(array));
        &#125;
        
                

    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210303112332749.png" alt="image-20210303112332749"></p>
<h2 id="快速排序（Quick-Sorting）"><a href="#快速排序（Quick-Sorting）" class="headerlink" title="快速排序（Quick Sorting）"></a>快速排序（Quick Sorting）</h2><p>快速排序是一种非常经典的排序算法，它的运行效率非常高，当然快排属于空间换时间的一类，因为要使用递归。</p>
<p>For very small arrays (<em>N</em> ≤ 20), quicksort does not perform as well as insertion sort </p>
<p>注意，快排在数字很多的时候才会展现其有时，当数据很少，例如小于20时，快排并不比插入排序好多少</p>
<p>基本思路：</p>
<p>选取数组最中间的数为基数（以这个数为基准），用2个指针分别从最左边和最右边读取数据，将小于基数的数放在左边，大于基数的数放在右边。最后排完，小于的都在左侧，大的都在右侧。我们继续进行递归，由于此时左侧和右侧的指针都指向基数，为了分别进行左排序递归和右排序递归，左侧指针右移1格，右指针左移1格。</p>
<p>图解：</p>
<p>（哎，图片不清晰）</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210303153253353.png" alt="image-20210303153253353"></p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class QuickSorting2 &#123;
    public static void main(String[] args) &#123;
//        int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;;
        int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;;
        QuickSort(array, 0, array.length-1);
        System.out.println(Arrays.toString(array));
    &#125;
    
    public static void QuickSort(int[] array, int left, int right) &#123;
        int l =left;
        int r =right;
        int temp;
        int pivot = array[(left+right)/2];
        while(l&lt;r) &#123;
            //左边往右走
            while(array[l]&lt;pivot) &#123;
                l+=1;
            &#125;
            //右边往左走
            while(array[r]&gt;pivot) &#123;
                r -=1;
            &#125;
            if(l&gt;=r) &#123;
                break;
            &#125;
            
            temp =array[l];
            array[l]=array[r];
            array[r] = temp;
            
            //交换后发现array[l] == pivot的值 r--;前移
            if(array[l] == pivot) &#123;
                r -=1;
            &#125;
            
            //交换后发现array[r] == pivot的值 l++;前移
            if(array[r] == pivot) &#123;
                l +=1;
            &#125;
            
        &#125;
        
        //递归
        if(left&lt;r) &#123;
            QuickSort(array, left, r-1);
        &#125;
        if(right&gt;l) &#123;
            QuickSort(array, l+1, right);
        &#125;
    &#125;
&#125;
</code></pre>
<p>以第一个数为基准的快速排序</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class QuickSorting3 &#123;

    public static void main(String[] args) &#123;
        int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;;
        Sort(array, 0, array.length-1);
        System.out.println(Arrays.toString(array));
    &#125;
    
    public static void Sort(int[] array, int left, int right) &#123;
        int l = left;
        int r = right;
        int pivot = array[left]; //以第一个数为基准
        while(true) &#123;
            while(array[r] &gt;= pivot&amp;&amp;l&lt;r) &#123;
                r-=1;
            &#125;
            if(l&lt;r) &#123;
                array[l] =array[r];
                l+=1;
            &#125;
            while(array[l] &lt;= pivot&amp;&amp;l&lt;r) &#123;
                l +=1;
            &#125;
            if(l&lt;r) &#123;
                array[r] = array[l];
                r -=1;
            &#125;
            if(l==r) &#123;
                array[l] = pivot;
                break;
            &#125;
        &#125;
        
        if(left&lt;r) &#123;
            Sort(array, left, r-1);
        &#125;
        
        if(right &gt; l) &#123;
            Sort(array, l+1, right);
        &#125;
    &#125;

&#125;
</code></pre>
<p>关于Pivot我们也可以根据数组中位数来定，pivot选好对程序的复杂度有直观影响</p>
<p>就像Mark 的 Data Structure And Algorithm Analysis In Java书中写的</p>
<blockquote>
<p>Although the algorithm as described works no matter which element is chosen as the pivot, some choices are obviously better than others. </p>
<p>The median of a group of <em>N</em> numbers is the [*N/*2]th largest number. The best choice of pivot would be the median of the array</p>
</blockquote>
<p>这里贴出Mark的源码</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class QuickSorting4 &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;;
        quicksort(array);
        System.out.println(Arrays.toString(array));
    &#125;
    
    public static void quicksort(int[] a) &#123;
        quicksort(a, 0, a.length-1);
    &#125;
    
    private static void swapReference(int[] a, int n, int m) &#123;
        int temp = a[n];
        a[n] = a[m];
        a[m] = temp;
    &#125;
    
    private static int median3(int[] a, int left, int right) &#123;
        int center =(left+right)/2;
        if(a[center] &lt; a[left])
            swapReference(a, left, center);
        if(a[right] &lt; a[left])
            swapReference(a, left, right);
        if(a[right]&lt;a[center])
            swapReference(a, center, right);
        
        swapReference(a, center, right-1);
        return a[right-1];
    &#125;
    
    private static final int CUTOFF =10;
    
    private static void quicksort(int[] a, int left, int right) &#123;
        if(left + CUTOFF &lt;= right) &#123;
            int pivot = median3(a, left, right);
            
            int i = left;
            int j = right-1;
            while(true) &#123;
                while(a[i] &lt; pivot) &#123;
                    i++;
                &#125;
                    
                while(a[j]&gt;pivot) &#123;
                    j--;
                &#125;
                    
                
                if(i&lt;j)
                    swapReference(a, i, j);
                else &#123;
                    break;
                &#125;
                

            &#125;
            
            swapReference(a, i, right-1);
            
            quicksort(a, left, i-1);
            quicksort(a, i+1, right);
        
            
        &#125;else &#123;
            InsertSorting.insertsort(a, left, right);
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="归并排序（Merge-Sorting）"><a href="#归并排序（Merge-Sorting）" class="headerlink" title="归并排序（Merge Sorting）"></a>归并排序（Merge Sorting）</h2><p>归并排序和上面的快速排序思想上类似，都用到了经典的分治算法(divide and conquer),即先将复杂的问题划分divide成小的问题然后递归求解，然后再conquer（把各个划分阶段的答案修补在一起）</p>
<p>Divide</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210304125300389.png" alt="image-20210304125300389"></p>
<p>Conquer</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210304130026195.png" alt="image-20210304130026195"></p>
<p>为了方便操作，我们传进去的数组会被复制，输出的是一个新的数组，这个数组就是排序好的数组</p>
<p>Divide分的时候要采用递归，每次分2份，直到数组每个元素都被分别分在1个数组中</p>
<p>当递归完后，回溯时从最后一个数组开始，即一个一个元素的数组，返回上一层，将此时的数组赋给left或right，接着调用Conquer，把2个数组排序放入一个新的数组，然后再返回，依次进行，直到全部排序完成</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class MergeSorting &#123;
    public static void main(String[] args) &#123;
//        int[] array = &#123;59,48,75,107,86,23,37,59,65,14 &#125;;
        int[] array = &#123;77,26,93,17,54,31,44,55,20 &#125;;
        MergeSort(array);
        System.out.println(Arrays.toString(array));
        
    &#125;
    
    public static void MergeSort(int[] arr)&#123;
        int[] temp = new int[arr.length];
        Divide(arr, temp, 0, arr.length-1);
    &#125;
    
    private static void Divide(int[] arr, int[] temp, int left, int right)&#123;
        int pivot = (left+right)/2;
        if(left&lt;right)&#123;
            Divide(arr, temp, left, pivot);
            Divide(arr, temp, pivot+1, right);
            Conquer(arr, temp, left, pivot+1, right);
        &#125;
    &#125;
    
    private static void Conquer(int[] arr, int[] temp, int leftPos, int rightPos, int rightEnd)&#123;
        int nums = rightEnd - leftPos +1;
        int leftEnd = rightPos -1;
        int cur = leftPos;
        
        while(leftPos&lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)&#123;
            if(arr[leftPos].compareTo(arr[rightPos])&lt;0)
                temp[cur++] = arr[leftPos++];
            if(arr[leftPos].compareTo(arr[rightPos])&gt;0)
                 temp[cur++] = arr[rightPos++];
            else&#123;
                temp[cur++] = arr[leftPos++];
                temp[cur++] = arr[rightPos++];
            &#125;
        &#125;
        
        while(leftPos&lt;=leftEnd)&#123;
             temp[cur++] = arr[leftPos++];
        &#125;
        
        while(rightPos &lt;= rightEnd)&#123;
             temp[cur++] = arr[rightPos++];
        &#125;
        
        for(int i=0;i&lt;nums;i++, rightEnd--)
            arr[rightEnd] = temp[rightEnd];
        
    &#125;
</code></pre>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>前面在二叉树时讲了，这里就只贴部分代码</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class HeapSorting2 &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Integer[] arr = &#123; 35, 10, 25, 15, 30, 40, 20, 50, 45 &#125;;
        HeapSorting(arr);
        System.out.println(Arrays.toString(arr));
    &#125;
    
    /**
     * internal method for heapsort
     * @param i the index of an item in the heap
     * @return the index of the left child
     */
    private static int leftChild(int i) &#123;
        return 2*i +1;
    &#125;
    
    /**
     * Internal method for heapsort that is used in deleteMax and buildHeap
     * @param &lt;AnyType&gt; anyType is a generic type
     * @param a an array of comparable items
     * @param i the position from which to precolate down
     * @param n the logic size of the binary heap
     */
    private static &lt;AnyType extends Comparable &lt;? super AnyType&gt;&gt; void precDown(AnyType[] a, int i, int n) &#123;
        int child;
        AnyType temp;
        for(temp =a[i]; leftChild(i) &lt; n;i=child) &#123;
            child = leftChild(i);
            //找出三个中最大的
            if(child != n-1 &amp;&amp; a[child].compareTo(a[child+1])&lt;0) //判断左边小于右边
                child++;
            if(temp.compareTo(a[child])&lt;0) //判断父结点是否小于子节点
                a[i] =a[child];
            else &#123;
                break;
            &#125;
        &#125;
        a[i] =temp;
    &#125;
    
    /**
     * 
     * @param &lt;AnyType&gt;
     * @param a an array of Comparable items
     * @param b the top item of the heap
     * @param c the bottom item of the heap
     */
    private static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void SwapReference (AnyType[] a, int b, int c) &#123;
        AnyType temp = a[b];
        a[b] = a[c];
        a[c] = temp;
    &#125; 
    
    /**
     * Standard heapsort
     * @param &lt;AnyType&gt;
     * @param a an array of Comparable items
     */
    public static &lt;AnyType extends Comparable&lt;? super AnyType&gt;&gt; void HeapSorting(AnyType[] a) &#123;
        for(int i=a.length/2; i &gt;=0 ;i--) &#123; /*Build Heap*/
            precDown(a, i, a.length);
        &#125;
        
        for(int i=a.length-1; i&gt;0;i--) &#123;
            SwapReference(a, 0, i); /*Delete the Max*/
            precDown(a, 0, i);
        &#125;
        
    &#125;

&#125;
</code></pre>
<h2 id="基数排序（Radix-Sorting）"><a href="#基数排序（Radix-Sorting）" class="headerlink" title="基数排序（Radix Sorting）"></a>基数排序（Radix Sorting）</h2><p>基数排序是特殊的桶排序</p>
<p>步骤：</p>
<ol>
<li>先将数组按个位排序分类，分好后一个一个放入原数组</li>
<li>再把数组按照十位排序分类，同上</li>
<li>直到分到原数组中最大数的位数，例如最大数是3789，我们最后就要按照千位来排序</li>
</ol>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.png"></p>
<p>由小到大，这样依次我们就完成对数组的排序</p>
<pre><code class="java">package Sorting;

import java.util.Arrays;

public class RedixSorting &#123;

    public static void main(String[] args) &#123;
        int[] array = &#123;77,26,93,17,54,107,31,44,55,20 &#125;;
        RadixSort(array);
        System.out.println(Arrays.toString(array));
    &#125;
    
    
    public static void RadixSort(int[] array) &#123;
        //找出最大的一位
        int Max =0;
        for(int i=0;i&lt;array.length;i++) &#123;
            if(array[Max] &lt;array[i]) &#123;
                Max =i;
            &#125;
        &#125;
        
        //得出最大一位的个数
        int count=0;
        int temp =array[Max];
        while(temp&gt;0) &#123;
            temp /= 10;
            count++;
        &#125;
        for(int j=0;j&lt;count;j++) &#123;
            busket(array, pow(10,j));
        &#125;
        
        
    &#125;
    
    //计算一个数的几次方
    public static int pow(int num, int exp) &#123;
        if(exp==0) &#123;
            return 1;
        &#125;
        for(int i=0;i&lt;exp-1;i++) &#123;
            num *= num;
        &#125;
        return num;
    &#125;
    
    public static void busket(int[] array, int digit) &#123;
        //创建一个桶用来记录数据
        int[][] bucket = new int[10][array.length];
        
        //创建一个数组来记录每个桶里面元素的个数
        int[] itemNum = new int[10];
        
        for(int i=0;i&lt;array.length;i++) &#123; 
        
            int no = array[i]/digit%10; //哪一个桶
            bucket[no][itemNum[no]] = array[i] +10;
            itemNum[no] +=1;
        &#125;
        
        
        int index=0;
        for(int j=0;j&lt;10;j++) &#123;
            for(int k=0;k&lt;bucket.length;k++) &#123;
                if(bucket[j][k] !=0) &#123;
                    array[index] = bucket[j][k]-10;
                    bucket[j][k] =0;
                    index++;
                &#125;
                else &#123;
                    break;
                &#125;
            &#125;
            itemNum[j] =0;
        &#125;
        index =0;
        
        
    &#125;

&#125;
</code></pre>
<h2 id="排序算法的时间复杂度比较"><a href="#排序算法的时间复杂度比较" class="headerlink" title="排序算法的时间复杂度比较"></a>排序算法的时间复杂度比较</h2><table>
<thead>
<tr>
<th>排序法</th>
<th>平均时间</th>
<th>最差情况</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>交换</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>选择</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>插入</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>基数</td>
<td>O(logR B)</td>
<td>O(logR B)</td>
</tr>
<tr>
<td>Shell</td>
<td>O(nlogn)</td>
<td>O(n^s) 1&lt;s&lt;2</td>
</tr>
<tr>
<td>快排</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>归并</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>堆</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
</tr>
</tbody></table>
<p>术语：</p>
<p>稳定：两个数据在排序后任然保持之前的相对前后位置</p>
<p>时间复杂度：算法运行所消耗的时间</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p>
<p>测试程序</p>
<pre><code class="java">package Sorting;

import java.text.SimpleDateFormat;
import java.util.Date;

public class TestSortingTime &#123;
    public static void main(String[] args) &#123;
        int[] array = new int[80000];
        
        Init(array);
        System.out.println(&quot;BubbleSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        BubbleSorting(array);
        PrintTime(&quot;End: &quot;);
        System.out.println();

        Init(array);
        System.out.println(&quot;SelectionSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        SelectionSorting(array);
        PrintTime(&quot;End: &quot;);

        System.out.println();
        Init(array);
        System.out.println(&quot;InsertSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        InsertSorting(array);
        PrintTime(&quot;End: &quot;);
        
        System.out.println();
        Init(array);
        System.out.println(&quot;ShellSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        ShellSorting(array);
        PrintTime(&quot;End: &quot;);
        
        
        System.out.println();
        Init(array);
        System.out.println(&quot;QuickSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        QuickSort(array, 0, array.length-1);
        PrintTime(&quot;End: &quot;);
        
        System.out.println();
        Init(array);
        System.out.println(&quot;QuickSorting2&quot;);
        PrintTime(&quot;Start: &quot;);
        QuickSort2(array, 0, array.length-1);
        PrintTime(&quot;End: &quot;);
        
        System.out.println();
        Init(array);
        System.out.println(&quot;MergeSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        MergeSort(array);
        PrintTime(&quot;End: &quot;);
        
        System.out.println();
        Init(array);
        System.out.println(&quot;RedixSorting&quot;);
        PrintTime(&quot;Start: &quot;);
        RadixSort(array);
        PrintTime(&quot;End: &quot;);
    &#125;

    public static void Init(int[] array) &#123;
        for (int i = 0; i &lt; array.length; i++) &#123;
            array[i] = (int) (Math.random() * 80000);
        &#125;
    &#125;

    public static void PrintTime(String words) &#123;
        Date date1 = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);
        String time = sdf.format(date1);
        System.out.println(words + time);
    &#125;

    public static void BubbleSorting(int[] array) &#123;
        int tmp = 0;
        boolean flag = false; // flag判断是否进行了排序交换
        for (int i = array.length - 1; i &gt; 0; i--) &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                if (array[j] &gt; array[j + 1]) &#123;
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                    flag = true;
                &#125;
            &#125;
            if (!flag) &#123;
                break;
            &#125; else &#123;
                flag = false; // 用于判断下一次有没有交换，如果没有，表示数据已正序
            &#125;
        &#125;
    &#125;

    public static void SelectionSorting(int[] array) &#123;
        for (int i = 0; i &lt; array.length - 1; i++) &#123;
            int smallest = i;
            for (int j = i; j &lt; array.length; j++) &#123;
                if (array[j] &lt; array[smallest]) &#123;
                    smallest = j;
                &#125;
            &#125;
            if (i != smallest) &#123;
                int temp = array[i];
                array[i] = array[smallest];
                array[smallest] = temp;
            &#125;
        &#125;

    &#125;

    public static void InsertSorting(int[] array) &#123;
        int temp;
        for (int i = 1; i &lt; array.length; i++) &#123;
            for (int j = i; j &gt; 0; j--) &#123;
                if (array[j] &lt; array[j - 1]) &#123;
                    temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                &#125;else &#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    
    public static void ShellSorting(int[] array) &#123;
        int length = array.length;
        int temp;
        for(int step = length/2;step &gt;0; step /=2) &#123;
            for(int i=step;i&lt;length;i++) &#123;
                temp = array[i];
                int j =i;
                if(array[j] &lt; array[j-step]) &#123;
                    while(j&gt;=step &amp;&amp; temp&lt;array[j-step]) &#123;
                        array[j] = array[j - step];
                        j-=step;
                    &#125;
                &#125;
                if (j != i) &#123;
                    array[j] = temp;
                &#125;
//                for(int j=i;j&gt;=step;j-=step) &#123;
//                    if(array[j]&lt;array[j-step]) &#123;
//                        temp = array[j];
//                        array[j] = array[j-step];
//                        array[j-step] = temp;
//                    &#125;
//                    else
//                        break;
//                &#125;
            &#125;
        &#125;
    &#125;
    
    public static void QuickSort(int[] array, int left, int right) &#123;
        int l =left;
        int r =right;
        int temp;
        int pivot = array[(left+right)/2];
        while(l&lt;r) &#123;
            //左边往右走
            while(array[l]&lt;pivot) &#123;
                l+=1;
            &#125;
            //右边往左走
            while(array[r]&gt;pivot) &#123;
                r -=1;
            &#125;
            if(l&gt;=r) &#123;
                break;
            &#125;
            
            temp =array[l];
            array[l]=array[r];
            array[r] = temp;
            
            //不进行下面的操作程序会卡死
            //交换后发现array[l] == pivot的值 r--;前移
            if(array[l] == pivot) &#123;
                r -=1;
            &#125;
            
            //交换后发现array[r] == pivot的值 l++;前移
            if(array[r] == pivot) &#123;
                l +=1;
            &#125;
            
        &#125;
        
        if(left&lt;r) &#123;
            QuickSort(array, left, r-1);
        &#125;
        if(right&gt;l) &#123;
            QuickSort(array, l+1, right);
        &#125;
    &#125;
    
    public static void QuickSort2(int[] array, int left, int right) &#123;
        int l = left;
        int r = right;
        int pivot = array[left];
        while(true) &#123;
            while(array[r] &gt;= pivot&amp;&amp;l&lt;r) &#123;
                r-=1;
            &#125;
            if(l&lt;r) &#123;
                array[l] =array[r];
                l+=1;
            &#125;
            while(array[l] &lt;= pivot&amp;&amp;l&lt;r) &#123;
                l +=1;
            &#125;
            if(l&lt;r) &#123;
                array[r] = array[l];
                r -=1;
            &#125;
            if(l==r) &#123;
                array[l] = pivot;
                break;
            &#125;
        &#125;
        
        if(left&lt;r) &#123;
            QuickSort2(array, left, r-1);
        &#125;
        
        if(right &gt; l) &#123;
            QuickSort2(array, l+1, right);
        &#125;
    &#125;
    
    //归并排序
    public static void MergeSort(int[] arr) &#123;
        int[] arr2 = Divide(arr);
        for(int i=0;i&lt;arr2.length;i++) &#123;
            arr[i]=arr2[i];
        &#125;
    &#125;
    
    public static int[] Divide(int[] arr) &#123;
        int pivot = (arr.length)/2;
        if(pivot&gt;=1) &#123;
            int[] left = new int[pivot];
            int[] right = new int[arr.length-pivot];
            for(int i=0;i&lt;left.length;i++) &#123;
                left[i] = arr[i];
            &#125;
            for(int j=0;j&lt;right.length;j++) &#123;
                right[j]=arr[pivot+j];
            &#125;
            
            left = Divide(left);
            right = Divide(right);
        
            return Conquer(left, right);
        &#125;
        return arr;
    
    &#125;
    
    
    public static int[] Conquer(int[] arr1, int[] arr2) &#123;
        int[] temp = new int[arr1.length+arr2.length];
        int cur =0;
        int left =0;
        int right =0;
        while(true) &#123;
            if(arr1[left]&lt;arr2[right]) &#123;
                temp[cur] = arr1[left];
                cur++;
                left++;
            &#125;
            else if(arr1[left] &gt; arr2[right]) &#123;
                temp[cur] = arr2[right];
                cur++;
                right++;
            &#125;
            else &#123;
                temp[cur] =arr1[left];
                cur++;
                left++;
                temp[cur] = arr2[right];
                cur++;
                right++;
            &#125;
            if(left&gt;=arr1.length) &#123;
                for(int i=right;i&lt;arr2.length;i++) &#123;
                    temp[cur] = arr2[i];
                    cur++;
                &#125;
                break;
            &#125;
            else if(right&gt;=arr2.length)&#123;
                for(int i=left;i&lt;arr1.length;i++) &#123;
                    temp[cur] = arr1[i];
                    cur++;
                &#125;
                break;
            &#125;
        &#125;
        
        return temp;
    &#125;
    
    
    public static void RadixSort(int[] array) &#123;
        //找出最大的一位
        int Max =0;
        for(int i=0;i&lt;array.length;i++) &#123;
            if(array[Max] &lt;array[i]) &#123;
                Max =i;
            &#125;
        &#125;
        
        //得出最大一位的个数
        int count=0;
        int temp =array[Max];
        while(temp&gt;0) &#123;
            temp /= 10;
            count++;
        &#125;
        for(int j=0;j&lt;count;j++) &#123;
            busket(array, pow(10,j));
        &#125;
        
        
    &#125;
    
    //计算一个数的几次方
    public static int pow(int num, int exp) &#123;
        if(exp==0) &#123;
            return 1;
        &#125;
        for(int i=0;i&lt;exp-1;i++) &#123;
            num *= num;
        &#125;
        return num;
    &#125;
    
    public static void busket(int[] array, int digit) &#123;
        //创建一个桶用来记录数据
        int[][] bucket = new int[10][array.length];
        
        //创建一个数组来记录每个桶里面元素的个数
        int[] itemNum = new int[10];
        
        for(int i=0;i&lt;array.length;i++) &#123; 
        
            int no = array[i]/digit%10; //哪一个桶
            bucket[no][itemNum[no]] = array[i] +10;
            itemNum[no] +=1;
        &#125;
        
        int index=0;
        for(int j=0;j&lt;10;j++) &#123;
            for(int k=0;k&lt;bucket.length;k++) &#123;
                if(bucket[j][k] !=0) &#123;
                    array[index] = bucket[j][k] -10;
                    bucket[j][k] =0;
                    index++;
                &#125;
                else &#123;
                    break;
                &#125;
            &#125;
            itemNum[j] =0;
        &#125;
        index =0;
        
        
    &#125;
&#125;
</code></pre>
<p>​    </p>
<p>运行结果</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210304164908951.png" alt="image-20210304164908951"></p>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找的条件是必须在有序数组中</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210306194544964.png" alt="image-20210306194544964"></p>
<p>3种查询方法</p>
<ol>
<li>把数组复制再查询</li>
</ol>
<pre><code class="java">public static boolean search(int[] array, int num) &#123;
        int index = array.length/2;
        if(array.length &gt;=1)&#123;
            if(array[index] &gt; num) &#123;
                int[] left = Arrays.copyOfRange(array,0,index);
                return search(left, num);
            &#125;
            else if(array[index] &lt; num) &#123;
                int[] right = Arrays.copyOfRange(array, index+1, array.length);
                return search(right, num);
            &#125;
            else if(array[index] == num) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<ol start="2">
<li>数组不复制，对下标进行操作</li>
</ol>
<pre><code class="java">System.out.println(search(array, 31, 0, array.length-1));

public static boolean search(int[] array, int num, int left, int right) &#123;
        int index = (left+right)/2;
        if(left&gt;right) &#123;
            return false;
        &#125;
        print(array, left, right);
        if(array[index] &gt; num) &#123;
            return search(array, num, left, index-1);
        &#125;
        else if(array[index] &lt; num) &#123;
            return search(array, num, index+1, right);
        &#125;
        else
        &#123;
            return true;
        &#125;
        
        
    &#125;
</code></pre>
<ol start="3">
<li>非递归法</li>
</ol>
<pre><code class="java">public static boolean search(int[] array, int num) &#123;
        int left =0;
        int right = array.length-1;
        while(left &lt;= right) &#123;
            int mid = (left+right)/2;
            if(array[mid] == num) &#123;
                return true;
            &#125;
            else if(array[mid] &gt; num) &#123;
                right = mid -1;
            &#125;
            else &#123;
                left = mid+1;
            &#125;
        &#125;
        return false;
    &#125;
    
</code></pre>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>相比于二分查找，插值查找改变了查找的基数，假如差值大，基数就大，差值小，跨度就小。可以说插值查找就是二分查找的改进。</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/%E6%9F%A5%E5%80%BC%E6%9F%A5%E6%89%BE.jpg"></p>
<pre><code class="java">package Search;

public class InsertSearching &#123;
    public static void main(String[] args) &#123;
        int[] array = &#123;17, 20, 26, 31, 44,44, 54, 55, 77, 93&#125;;
        System.out.println(search(array, 1, 0, array.length-1));
        
    &#125;
    
    //递归版本
    public static boolean search(int[] array, int num, int left, int right) &#123;
        int index = left+(right-left)*(num-array[left])/(array[right]-array[left]);
        if(left&gt;right || index&lt;0) &#123;
            return false;
        &#125;
        if(array[index] &gt; num) &#123;
            return search(array, num, left, index-1);
        &#125;
        else if(array[index] &lt; num) &#123;
            return search(array, num, index+1, right);
        &#125;
        else
        &#123;
            return true;
        &#125;
    &#125;
    
&#125;
</code></pre>
<h1 id="程序员必会十大算法"><a href="#程序员必会十大算法" class="headerlink" title="程序员必会十大算法"></a>程序员必会十大算法</h1><h2 id="1-二分查找算法"><a href="#1-二分查找算法" class="headerlink" title="1. 二分查找算法"></a>1. 二分查找算法</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>二分查找是常见的查找算法，使用二分查找的前提是要拥有一组有序的数组，查找时我们根据数组下标，把数组一分为二，通过比较中间的数来确认目标的位置，如下图</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419111722840.png" alt="image-20210419111722840"></p>
<p>这样查找相比于一般的for循环遍历，效率大大提高，时间可达log(N)</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>二分查找有2种实现方法：递归版和非递归版</p>
<p><strong>非递归版</strong></p>
<pre><code class="java">//非递归版本
public static int search(int[] array, int num) &#123;
    int left =0; //left表示左侧下标
    int right = array.length-1; //right表示右侧下标
    while(left &lt;= right) &#123; //结束的条件是左边大于右边
        int mid = (left+right)/2; //我们假设中间的数是目标
        if(array[mid] == num) &#123; // 判断，是
            return mid; //返回下标
        &#125;
        else if(array[mid] &gt; num) &#123; //判断发现中间的数比目标数大
            right = mid -1; //把中间的数的下标设置为右边， 减1是因为mid已经判断过了，比num大
        &#125;
        else &#123; //若小，则设置为左边
            left = mid+1;//加1的原因和上面类似
        &#125;
    &#125;
    return -1; //找完后发现没有找到，返回-1
&#125;
</code></pre>
<p><strong>递归版本</strong></p>
<p>具体步骤和上面非递归版本类似，推荐非递归版本</p>
<pre><code class="java">//递归版本
public static boolean search(int[] array, int num, int left, int right) &#123;
    int index = (left+right)/2;
    if(left&gt;right) &#123;
        return -1;
    &#125;
    print(array, left, right);
    if(array[index] &gt; num) &#123;
        return search(array, num, left, index-1);
    &#125;
    else if(array[index] &lt; num) &#123;
        return search(array, num, index+1, right);
    &#125;
    else
    &#123;
        return index;
    &#125;


&#125;
</code></pre>
<h2 id="2-分治算法"><a href="#2-分治算法" class="headerlink" title="2. 分治算法"></a>2. 分治算法</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>分治算法，蕴含分而治之的思想，Divide and Conquer. 我们把难的问题逐个逐个拆分，拆分为小的问题，然后对于这个小的问题我们要给出解决办法，最后一步一步返回过去，将难的问题给解决，使用分治算法时，我们还利用了递归的思想，从拆分到组合</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们举汉诺塔的例子来讲分治算法</p>
<p>故事大家也都知道</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
</blockquote>
<p>64个盘看似很多，我们把这64个简化为3个</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419123047227.png" alt="image-20210419123047227"></p>
<p>3个盘，我们先把上面两个盘想办法<strong>从第1个柱子移到第2个柱子</strong></p>
<p>为了按照大小的顺序移动，先把第1个盘从第1个柱子移到第3个柱子，第2个盘从第1个柱子移到第2个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124339062.png" alt="image-20210419124339062"></p>
<p>接着把盘从第3个柱子移到第2个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124415703.png" alt="image-20210419124415703"></p>
<p>然后，把仅存在第1个柱子的盘移到第3个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124444560.png" alt="image-20210419124444560"></p>
<p>最后想办法把<strong>第2个柱子上的盘移到第3个柱子</strong></p>
<p>先把第2个柱子上的移到第1个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124656537.png" alt="image-20210419124656537"></p>
<p>再把最后一个移到第3个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124729238.png" alt="image-20210419124729238"></p>
<p><strong>最后一步</strong></p>
<p>把盘从第1个柱子移到第3个柱子</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419124828794.png" alt="image-20210419124828794"></p>
<p>假设有n个盘，3个柱A, B, C</p>
<ol>
<li>把n-1个盘从A到B</li>
<li>最后1个从A到C</li>
<li>再把n-1个盘从B移到C</li>
</ol>
<p>落实到代码</p>
<pre><code class="java">package algorithm;

public class HanoiTower &#123;
    static int count=0;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        move(3,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);
        System.out.println(count);
    &#125;
    
    public static void move(int num, char a, char b, char c) &#123;
        if(num==1) &#123;
            //只有1个盘，从A移动到C
            System.out.println(a+&quot;-&gt;&quot;+c);
            count++;
        &#125;
        else &#123;
            //把n-1个盘，从A移动到B
            move(num-1, a, c, b);//由于实参和形参的不同，我们可以改变实参以达到变换的目的
            System.out.println(a+&quot;-&gt;&quot;+c);
            count++;
            //再把剩下的从B移动到C
            move(num-1,b,a,c);
            
            
        &#125;
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419140825279.png" alt="image-20210419140825279"></p>
<h2 id="3-动态规划算法"><a href="#3-动态规划算法" class="headerlink" title="3. 动态规划算法"></a>3. 动态规划算法</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>和上面的分治算法有点类似，都是把复杂或大的问题拆解为小的问题，然后求解</p>
<p>不同在于，动态规划算法每一步和上一步之间有联系，所以动态规划算法适用于重叠的子问题求解</p>
<p>动态规划算法通常用于求解（最大值和最小值），在应用动态规划之前要分析能否把大问题拆解为小问题，然后每个小问题都是最优解。</p>
<p>动态规划算法从上往下分析问题，从下往上解决问题，先解决最小的问题，再解决最大问题。</p>
<p>常见的利用动态规划算法求解的莫过于背包问题（01背包问题）</p>
<p>去商店买东西，背包有固定的容量，我们每个物品有且只能装入1次，最后我们要挑选出价值最高的物品组合。</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419132120492.png" alt="image-20210419132120492"></p>
<p>为了获取每个子问题的最优解，我们用二维数组来解决背包问题</p>
<p>列表示背包容量</p>
<p>行表示对应的商品</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419132323341.png" alt="image-20210419132323341"></p>
<p>第1列我们也设置为0</p>
<p>用双重for循环，从左往右，从上往下</p>
<p>当然，由于我们第1行和第1列都设置为0，我们从第2列和第2行开始bag[1][1]</p>
<p>从左往右，判断背包容量是否可以装入吉他，不行读取上面1格的值，然后向后，发现2kg可以装入吉他，把吉他装入，设置为$200，</p>
<p>走到电脑这一行，1kg无法放下，读取上面1格的值，向后，还是不行，继续向后，直到能装下，4kg，和上一个做对比，看哪个最后的值大，把大的放入</p>
<p>最后一行是书， 与上文一样，直到bag容量为3kg时，我们先装入1本书，还剩余2kg，我们选取没加这本书的时候的最佳值，也就是书所在上一行，剩余容量所在的位置的值， 就是$200 + $100, 然后我们比较和上一行的大小</p>
<table>
<thead>
<tr>
<th></th>
<th>0 kg</th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
<td>$0</td>
</tr>
<tr>
<td>吉他</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$200</td>
</tr>
<tr>
<td>电脑</td>
<td>$0</td>
<td>$0</td>
<td>$200</td>
<td>$200</td>
<td>$300</td>
</tr>
<tr>
<td>书</td>
<td>$0</td>
<td>$100</td>
<td>$200</td>
<td>$200+$100</td>
<td>$300</td>
</tr>
</tbody></table>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们除了要知道背包能存入的最大值，还应该知道存入的是哪些物品，所以我们还需要一个二维数组用来表示存了哪些物品</p>
<pre><code class="java">int[][] path=new int[n+1][m+1];
</code></pre>
<p>存入path所在的位置为1， 没有就是默认的0</p>
<p>打印</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th><strong>1 kg</strong></th>
<th><strong>2 kg</strong></th>
<th><strong>3 kg</strong></th>
<th><strong>4 kg</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>吉他</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>电脑</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>书</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>打印从右下角开始向上读，如果此时的标记为1，打印这个下标对应商品的下标，横坐标减去这个商品对应的容量</p>
<pre><code class="java">//为了显示装入的物品有哪些
        
int i=path.length-1;
int j=path[0].length-1;
while(i&gt;0 &amp;&amp; j&gt;0) &#123;
    if(path[i][j]==1) &#123;
        System.out.printf(&quot;把%s放入背包\n&quot;,obj[i-1]);
        j -= w[i-1];
    &#125;
    i--;
&#125;
</code></pre>
<p><strong>最后</strong></p>
<pre><code class="java">package algorithm;

public class Dynamic_Programming_Bag2 &#123;
    public static void main(String[] args) &#123;
        String[] obj = &#123;&quot;Guitar&quot;,&quot;Computer&quot;,&quot;Book&quot;&#125;;
        int[] v= &#123;200,300,100&#125;;
        int[] w= &#123;2,4,1&#125;;
        int m =4;//背包的容量
        int n = w.length;//物品的个数
        
        //背包
        int[][] bag =new int[n+1][m+1];
        
        
        //存储数组
        int[][] path=new int[n+1][m+1];
        
        for(int i=0;i&lt;bag.length;i++)
            bag[i][0]=0;//第一列设置为0
        for(int i=0;i&lt;bag[0].length;i++)
            bag[0][i]=0;//第一行设置为0
        
        for(int i=1;i&lt;bag.length;i++) &#123;
            for(int j=1;j&lt;bag[0].length;j++) &#123;
                if(w[i-1]&gt;j) &#123;
                    //容量不满足，直接继承上面一个
                    bag[i][j] = bag[i-1][j];
                &#125;else &#123;
                    //容量满足，和上面一个对比，选取最佳的value
                    //装入i-1个商品，到剩余空间j-w[i]的最大值
//                    bag[i][j] = Math.max(bag[i-1][j], v[i-1]+bag[i-1][j-w[i-1]]);
                    if(bag[i-1][j]&lt;v[i-1]+bag[i-1][j-w[i-1]]) &#123;
                        bag[i][j] = v[i-1]+bag[i-1][j-w[i-1]];
                        //把当前情况记录到path
                        path[i][j]=1;
                    &#125;else &#123;
                        bag[i][j] = bag[i-1][j];
                    &#125;
                    
                &#125;
            &#125;
        &#125;
        
        
      
//打印背包的Table
        
        //i表示行
        //j表示列
        for(int i=0;i&lt;bag.length;i++) &#123;
            for(int j=0;j&lt;bag[0].length;j++) &#123;
                System.out.printf(bag[i][j]+&quot;\t&quot;);
            &#125;
            System.out.println();
        &#125;
        
        
//为了显示装入的物品有哪些
        
        int i=path.length-1;
        int j=path[0].length-1;
        while(i&gt;0 &amp;&amp; j&gt;0) &#123;
            if(path[i][j]==1) &#123;
                System.out.printf(&quot;把%s放入背包\n&quot;,obj[i-1]);
                j -= w[i-1];
            &#125;
            i--;
        &#125;
        
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419140711349.png" alt="image-20210419140711349"></p>
<h2 id="4-贪婪算法"><a href="#4-贪婪算法" class="headerlink" title="4. 贪婪算法"></a>4. 贪婪算法</h2><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p>贪婪算法，又称贪心算法，Greedy Algorithm。 在解决问题时，每次都选择最好的情况，用这种方法得出最后的解，注意：虽然贪婪算法每次都选最好的，但是最后的结果并不一定是最佳的</p>
<p>广播集合覆盖问题（贪心算法的应用）</p>
<p>我们要构建广播站，每个广播站覆盖的地区不一样，有些有交叉的地方，我们要用哪些广播站去覆盖全部地区。 </p>
<p>如图</p>
<table>
<thead>
<tr>
<th>地区： <strong>北京、上海、天津、广州、深圳、成都、杭州、大连</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>电台</td>
<td>覆盖数</td>
<td>地区</td>
</tr>
<tr>
<td>K1</td>
<td>3</td>
<td>北京、上海、天津</td>
</tr>
<tr>
<td>K2</td>
<td>3</td>
<td>广州、北京、深圳</td>
</tr>
<tr>
<td>K3</td>
<td>3</td>
<td>成都、上海、杭州</td>
</tr>
<tr>
<td>K4</td>
<td>2</td>
<td>上海、天津</td>
</tr>
<tr>
<td>K5</td>
<td>2</td>
<td>杭州、大连</td>
</tr>
</tbody></table>
<p>从电台里面选，哪些电台组合在一起就覆盖了全部地区？</p>
<p>首先，我们将每个电台与其覆盖的地区放入HashMap中， Key是电台名称， Value是储存此电台覆盖地区的HashSet。然后我们还要创建一个HashSet用来储存所有地区名称， 一个ArrayList储存最后的结果</p>
<p>我们构建一个循环，每次从循环找出地区数覆盖最多的电台，将这个电台加入到ArrayList中，然后从所有地区中清除这些地区，接着循环，当地区集合大小为0时停止。</p>
<p>这个看代码比较好理解</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        HashMap&lt;String, HashSet&lt;String&gt;&gt; radios = new HashMap&lt;&gt;();
        HashSet&lt;String&gt; k1 = new HashSet&lt;&gt;();
        k1.add(&quot;北京&quot;);
        k1.add(&quot;上海&quot;);
        k1.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; k2 = new HashSet&lt;&gt;();
        k2.add(&quot;广州&quot;);
        k2.add(&quot;北京&quot;);
        k2.add(&quot;深圳&quot;);
        
        HashSet&lt;String&gt; k3 = new HashSet&lt;&gt;();
        k3.add(&quot;成都&quot;);
        k3.add(&quot;上海&quot;);
        k3.add(&quot;杭州&quot;);
        
        HashSet&lt;String&gt; k4 = new HashSet&lt;&gt;();
        k4.add(&quot;上海&quot;);
        k4.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; k5 = new HashSet&lt;&gt;();
        k5.add(&quot;杭州&quot;);
        k5.add(&quot;大连&quot;);
        
        radios.put(&quot;k1&quot;, k1);
        radios.put(&quot;k2&quot;, k2);
        radios.put(&quot;k3&quot;, k3);
        radios.put(&quot;k4&quot;, k4);
        radios.put(&quot;k5&quot;, k5);
        
        HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;();
        allAreas.addAll(k1);
        allAreas.addAll(k2);
        allAreas.addAll(k3);
        allAreas.addAll(k4);
        allAreas.addAll(k5);
        
        ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();
        
        String MaxKey = null;
        while(!allAreas.isEmpty()) &#123;
            for(String key:radios.keySet()) &#123;
                HashSet&lt;String&gt; temp = radios.get(key);
                temp.retainAll(allAreas); //选取交集
                
                //必须交集大于0 或者 交集的大小大于最大的大小
                if( temp.size() &gt;0 &amp;&amp; (MaxKey == null || temp.size() &gt; radios.get(MaxKey).size())) &#123;
                    MaxKey = key; //才能赋值
                &#125;
            &#125;
            
            //当最大赋值不为NULL时，把答案添加进去，移除对应的地区
            if(MaxKey != null) &#123;
                result.add(MaxKey);
                allAreas.removeAll(radios.get(MaxKey));
            &#125;
            
        &#125;
        
        System.out.println(result);

    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419143839349.png" alt="image-20210419143839349"></p>
<h2 id="5-KMP算法"><a href="#5-KMP算法" class="headerlink" title="5. KMP算法"></a>5. KMP算法</h2><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><p>KMP算法是常见的匹配字符串的算法，起初由名字里含有K, M, P的3个人所创建。讨论KMP算法之前我们要先了解暴力匹配字符串算法</p>
<h3 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h3><p>为什么叫暴力匹配算法？这个方法虽然也是算法，也能帮我们解决问题，但是它的运行效率是比较低的。</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419150304534.png" alt="image-20210419150304534"></p>
<p>找出‘FFD’所匹配的字符串的下标</p>
<p>第一行字符串假设为s1</p>
<p>第二行是s2</p>
<p>在While循环中，用s2的下标向s1的下标进行匹配，若所指下标不匹配，s2向后挪动1格</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419150609480.png" alt="image-20210419150609480"></p>
<p>如此一直到s1上的FFD与s2上的FFD相互匹配，此时返回下标，当然这个下标应该要减去s2的长度</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419150742638.png" alt="image-20210419150742638"></p>
<h4 id="暴力匹配代码实现"><a href="#暴力匹配代码实现" class="headerlink" title="暴力匹配代码实现"></a>暴力匹配代码实现</h4><pre><code class="java">package algorithm;

public class ViolentMatching &#123;

    public static void main(String[] args) &#123;
        //暴力匹配算法 
        System.out.println(matching(&quot;ABCDBCEFFDHFCD&quot;,&quot;FFD&quot;));
        
    &#125;
    
    public static int matching(String str1, String str2) &#123;
        int i=0;
        int j=0;
        char[] s1 =str1.toCharArray();
        char[] s2 =str2.toCharArray();
        while(i&lt;s1.length &amp;&amp; j&lt;s2.length) &#123;
            if(s1[i] == s2[j]) &#123; //相匹配，两下标各向后移动1
                i++;
                j++;
            &#125;
            else &#123; //发现不匹配，s2的下标从头开始， s1的下标应该减去刚才匹配的长度然后+1
                
                i= i-j+1;
                j=0;
                
            &#125;
        &#125;
        
        //最后找到返回下标
        if(j==s2.length)
            return i-j;
        else &#123;
            return -1;
        &#125;
        
    &#125;

&#125;
</code></pre>
<p>在暴力匹配当中，s2每次只往后移动1格，有些之前匹配过的还要再匹配，一旦字符串较长时，匹配所需要的时间就会增加很多，所以我们需要用KMP算法来进行优化</p>
<pre><code class="java">String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;;
String str2 =&quot;ABCDABD&quot;;
</code></pre>
<p>KMP在实现匹配之前要根据s2的前后缀最大公共元素的长度来建立一个匹配池</p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>D</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>字串</strong></th>
<th><strong>前缀</strong></th>
<th><strong>后缀</strong></th>
<th><strong>最大公共长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>空</td>
<td>空</td>
<td>0</td>
</tr>
<tr>
<td>AB</td>
<td>A</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>ABC</td>
<td>A, AB</td>
<td>BC, C</td>
<td>0</td>
</tr>
<tr>
<td>ABCD</td>
<td>A,AB,ABC</td>
<td>BCD, CD, D</td>
<td>0</td>
</tr>
<tr>
<td>ABCDA</td>
<td>A,AB,ABC,ABCD</td>
<td>BCDA, CDA, DA, A</td>
<td>1</td>
</tr>
<tr>
<td>ABCDAB</td>
<td>A, AB, ABC, ABCD, ABCDA</td>
<td>BCDAB, CDAB, DAB, AB, B</td>
<td>2</td>
</tr>
<tr>
<td>ABCDABD</td>
<td>A, AB, ABC, ABCD, ABCDA, ABCDAB</td>
<td>BCDABD, CDABD, DABD, ABD, BD, D</td>
<td>0</td>
</tr>
</tbody></table>
<p>有了匹配表后，我们要对之前暴力匹配的算法进行更新</p>
<pre><code class="java">//若字符匹配不相等
//KMP算法核心
while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;
    j = map[j-1];
&#125;
//失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值
</code></pre>
<h3 id="KMP代码实现"><a href="#KMP代码实现" class="headerlink" title="KMP代码实现"></a>KMP代码实现</h3><pre><code class="java">package algorithm;


public class KMPAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String str1 =&quot;BBC ABCDAB ABCDABCDABDE&quot;;
        String str2 =&quot;ABCDABD&quot;;
        System.out.println(KMP(str1, str2, MatchMap(str2)));
    &#125;
    
    /**
     * 构建字符匹配表
     * @param dest 传入字符串 
     * @return 返回匹配后的数组
     */
    public static int[] MatchMap(String dest) &#123;
        int[] map = new int[dest.length()];
        map[0]=0;
        for(int i=1, j=0; i&lt;dest.length();i++) &#123;
            
            //KMP算法核心
            while(j &gt;0 &amp;&amp; dest.charAt(i)!=dest.charAt(j)) &#123;
                j = map[j-1];
            &#125;
            //部分匹配值+1
            if(dest.charAt(i)==dest.charAt(j)) &#123;
                j++;
            &#125;
            map[i] =j;
        &#125;
        return map;
    &#125;
    
    /**
     * 
     * @param st1 被匹配的长字符串
     * @param st2 拿来匹配的字符串
     * @param map 字符匹配表
     * @return 返回-1 或对应匹配的位置
     */
    public static int KMP(String st1, String st2, int[] map) &#123;
        for(int i=0, j=0;i&lt;st1.length();i++) &#123;
            //若字符匹配不相等
            //KMP算法核心
            while(j &gt;0 &amp;&amp; st1.charAt(i)!=st2.charAt(j)) &#123;
                j = map[j-1];
            &#125;
            
            //字符匹配相等
            if(st1.charAt(i)==st2.charAt(j)) &#123;
                j++;
            &#125;
            
            if(j &gt;= st2.length())
                return i-j+1;
        &#125;
        return -1;
    &#125;

&#125;
</code></pre>
<h2 id="6-Prim算法"><a href="#6-Prim算法" class="headerlink" title="6. Prim算法"></a>6. Prim算法</h2><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3><p>Prim算法用于解决修路最短路径问题，有7个村庄，要用路把它们连接，问怎么修路使总路程最短，且路可以到达每个村庄</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419184711756.png" alt="image-20210419184711756"></p>
<p>最小生成树问题</p>
<ol>
<li>这个问题要利用图的知识来求解</li>
<li>需要构建二维数组（邻接矩阵）来表示顶点间的关系</li>
<li>既然每个顶点只能访问一次，需要一个boolean 数组，来储存该顶点是否被访问过</li>
<li>最终边（路）的条数应该为顶点数-1</li>
<li>为了知道是哪2个顶点之间相互连接，我们要将顶点的数据（顶点是哪2个，边的权值是多少）存起来</li>
</ol>
<ol>
<li>图</li>
</ol>
<pre><code class="java">//使用静态内部类的形式来构建
private static class Graph&#123;
    public int vertex;
    public char[] data;
    int[][] weight;
    Graph(char[] d, int[][] w)&#123;
        vertex = d.length;
        data = d;
        weight = w;
    &#125;


&#125;
</code></pre>
<ol start="2">
<li>二维数组</li>
</ol>
<pre><code class="java">int [][] weight= &#123;
    &#123;0,5,7,0,0,0,2&#125;,
    &#123;5,0,0,9,0,0,3&#125;,
    &#123;7,0,0,0,8,0,0&#125;,
    &#123;0,9,0,0,0,4,0&#125;,
    &#123;0,0,8,0,0,5,4&#125;,
    &#123;0,0,0,4,5,0,6&#125;,
    &#123;2,3,0,0,4,6,0&#125;
&#125;;
</code></pre>
<ol start="3">
<li>boolean数组</li>
</ol>
<pre><code class="java">boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
</code></pre>
<ol start="4">
<li>Prim算法的核心</li>
</ol>
<pre><code class="java">//编写Prim算法，得到最小生成树
/**
* 
* @param v 从图的第几个顶点开始找
*/
public void Prim(int v) &#123;
    boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
    isVisited[v] = true; //默认设置从第v个顶点开始
    /**用 h1和h2 记录2个顶点的下标*/
    int h1=-1;
    int h2=-1;
    int max=getMax(); // getMax是一个函数，用于获取此矩阵中的最大值，方便后面做比较
    int count=0; //用于统计总路径长度
    HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;();  //储存最后的结果

    for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个
        int minWeight = max;

        //双重循环
        for(int i=0;i&lt;graph.vertex;i++) &#123;
            for(int j=0;j&lt;graph.vertex;j++) &#123;
                //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有
                if(isVisited[i]==true 
                   &amp;&amp; isVisited[j]==false 
                   &amp;&amp; graph.weight[i][j] &lt; minWeight //比目前最大的数要小
                   &amp;&amp; graph.weight[i][j] != 0) &#123; //且不为0
                    minWeight = graph.weight[i][j]; //将最小的换为此时的权重
                    h1=i; 
                    h2=j; //标记这2个点
                &#125;
            &#125;
        &#125;

        isVisited[h2] = true; //第二个点设为已访问，之后会从这一行开始访问
        result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]);
        count += graph.weight[h1][h2];
    &#125;

    System.out.println();
    for(Entry&lt;String, Integer&gt; rst:result.entrySet())
        System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue());
    System.out.println(&quot;Min Path: &quot;+count);

&#125;
</code></pre>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map.Entry;

public class PrimAlgorithm &#123;
    public static void main(String[] args) &#123;
        char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;
        //邻接矩阵的关系用二维数组来表示
        int [][] weight= &#123;
                &#123;0,5,7,0,0,0,2&#125;,
                &#123;5,0,0,9,0,0,3&#125;,
                &#123;7,0,0,0,8,0,0&#125;,
                &#123;0,9,0,0,0,4,0&#125;,
                &#123;0,0,8,0,0,5,4&#125;,
                &#123;0,0,0,4,5,0,6&#125;,
                &#123;2,3,0,0,4,6,0&#125;
        &#125;;
        MinTree tree = new MinTree();
        tree.createGraph(new Graph(data, weight));
        tree.showGraph();
        
        tree.Prim(0);
        
    
    &#125;
    
    
    private static class MinTree&#123;
        private Graph graph;
        //创建图的邻接矩阵
        public void createGraph(Graph g) &#123;
            graph = g;
        &#125;
        
        //打印图
        public void showGraph() &#123;
            for(int[] w:graph.weight)
                System.out.println(Arrays.toString(w));
        &#125;
        
        //编写Prim算法，得到最小生成树
        /**
         * 
         * @param v 从图的第几个顶点开始找
         */
        public void Prim(int v) &#123;
            boolean[] isVisited = new boolean[graph.vertex]; //表示是否访问过
            isVisited[v] = true; //默认设置从第v个顶点开始
            /**用 h1和h2 记录2个顶点的下标*/
            int h1=-1;
            int h2=-1;
            int max=getMax();
            int count=0;
            HashMap&lt;String, Integer&gt; result = new HashMap&lt;&gt;(); 
    
            for(int k=1;k&lt;graph.vertex;k++) &#123; //根据算法，最后边个数应该为vertex-1个
                int minWeight = max;
                
                //双重循环
                for(int i=0;i&lt;graph.vertex;i++) &#123;
                    for(int j=0;j&lt;graph.vertex;j++) &#123;
                        //确定子图中哪2个节点最近，这2个顶点其中一个被访问过，另一个没有
                        if(isVisited[i]==true &amp;&amp; isVisited[j]==false &amp;&amp; graph.weight[i][j] &lt; minWeight &amp;&amp; graph.weight[i][j] != 0) &#123;
                            minWeight = graph.weight[i][j];
                            h1=i;
                            h2=j;
                        &#125;
                    &#125;
                &#125;
                
                isVisited[h2] = true; //设置成访问，之后会从这一行开始访问
                result.put(graph.data[h1]+&quot;-&quot;+graph.data[h2], graph.weight[h1][h2]);
                count += graph.weight[h1][h2];
            &#125;
            
            System.out.println();
            for(Entry&lt;String, Integer&gt; rst:result.entrySet())
                System.out.println(rst.getKey()+&quot; : &quot;+rst.getValue());
            System.out.println(&quot;Min Path: &quot;+count);
            
        &#125;
        
        private int getMax() &#123;
            int max=graph.weight[0][0];
            for(int i=0;i&lt;graph.vertex;i++) &#123;
                for(int j=0;j&lt;graph.vertex;j++) &#123;
                    if(graph.weight[i][j]&gt;max)
                        max = graph.weight[i][j];
                &#125;
            &#125;
            return max;
                
        &#125;
        
        
    &#125;
    
    private static class Graph&#123;
        public int vertex;
        public char[] data;
        int[][] weight;
        Graph(char[] d, int[][] w)&#123;
            vertex = d.length;
            data = d;
            weight = w;
        &#125;
        
        
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210419194332111.png" alt="image-20210419194332111"></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的代码时间复杂度很高，（n^3）， 一般的Prim算法时间复杂度仅（n^2），下面贴出更改后的代码</p>
<pre><code class="java">package algorithm;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;

public class PrimAlgorithm2 &#123;

    private static int INF=Integer.MAX_VALUE;
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        char[] data = &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;
        
        //不相邻的顶点，用INF表示
        int [][] map= &#123;
                &#123;0,5,7,INF,INF,INF,2&#125;,
                &#123;5,0,INF,9,INF,INF,3&#125;,
                &#123;7,INF,0,INF,8,INF,INF&#125;,
                &#123;INF,9,INF,0,INF,4,INF&#125;,
                &#123;INF,INF,8,INF,0,5,4&#125;,
                &#123;INF,INF,INF,4,5,0,6&#125;,
                &#123;2,3,INF,INF,4,6,0&#125;
        &#125;;
        System.out.println(&quot;Start&quot;);
        Prim(1, map, data);
    &#125;
    
    //输入起始顶点，邻接矩阵，顶点信息
    public static void Prim(int start, int[][] map, char[] data) &#123;
        //用于存储最终的各种信息
        HashMap&lt;String, Integer&gt; paths = new HashMap&lt;&gt;();
        //存储整个data长度
        int num = data.length;
        
        //存放前顶点
        int[] pre =new int[num];
        //权重 
        int[] weights = new int[num]; 
        //初始化
        for(int i=0;i&lt;weights.length;i++) &#123;
            weights[i] = map[start][i]; //默认权重以start为基准
            //与start顶点相连
            if(weights[i] !=INF)
                pre[i] =start; //把前节点设为start
        &#125;
        //start自身权重为0 
        weights[start] =0; 
        //start前结点为-1，即不存在
        pre[start] =-1;
        
        //主体程序
        for(int i=0;i&lt; num;i++) &#123;
            //start顶点前面已经初始化过了
            if(i == start)
                continue;
            
            //设置2 个下标，用来记录最短边的顶点
            int j=0;
            int k=0;
            
            //最小长度
            int min = INF;
            
            
            //从左往右对weights遍历， 找出最小边
            while(j &lt; num) &#123;
                //权重最小且不为0
                if(weights[j]!=0 &amp;&amp;weights[j] &lt; min) &#123;
                    min = weights[j];
                    k = j; //赋值
                &#125;
                j++;
            &#125;
            
            //把最小边相连的一个顶点设为0
            weights[k] =0;
            
            //重置权重（比较重要）
            for(int n=0;n&lt;num;n++) &#123;
                //权重不为0， 且新的两顶点之间权重小于目前的
                if(weights[n]!=0 &amp;&amp; map[k][n] &lt; weights[n]) &#123;
                    //更新权重和前节点
                    pre[n] = k; 
                    weights[n] = map[k][n];
                &#125;
            &#125;
            
            
        &#125;
        
        //最小生成树信息
        for(int i=0;i&lt;num;i++) &#123;
            if(pre[i] !=-1) &#123;
                paths.put(data[pre[i]]+&quot;-&quot;+data[i], map[pre[i]][i]);
            &#125;
        &#125;
        
        //打印信息
        int count =0;
        for(Entry&lt;String, Integer&gt; p:paths.entrySet()) &#123;
            count += p.getValue();
            System.out.println(p.getKey()+&quot; : &quot;+p.getValue());
        &#125;
        
        //打印最终长度
        System.out.println(&quot;Least : &quot;+count);
        
    &#125;
&#125;
    
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210528231519025.png" alt="image-20210528231519025"></p>
<p>网友的另一种解法，使用优先队列</p>
<p>这里摘取网友的解法</p>
<blockquote>
<pre><code class="English">1) Initialize keys of all vertices as infinite and 
parent of every vertex as -1.

2) Create an empty priority_queue pq.  Every item
of pq is a pair (weight, vertex). Weight (or 
key) is used used as first item  of pair
as first item is by default used to compare
two pairs.

3) Initialize all vertices as not part of MST yet.
We use boolean array inMST[] for this purpose.
This array is required to make sure that an already
considered vertex is not included in pq again. This
is where Ptim&#39;s implementation differs from Dijkstra.
In Dijkstr&#39;s algorithm, we didn&#39;t need this array as
distances always increase. We require this array here 
because key value of a processed vertex may decrease
if not checked.

4) Insert source vertex into pq and make its key as 0.

5) While either pq doesn&#39;t become empty 
 a) Extract minimum key vertex from pq. 
    Let the extracted vertex be u.

 b) Include u in MST using inMST[u] = true.

 c) Loop through all adjacent of u and do 
    following for every vertex v.

        // If weight of edge (u,v) is smaller than
        // key of v and v is not already in MST
        If inMST[v] = false &amp;&amp; key[v] &gt; weight(u, v)

            (i) Update key of v, i.e., do
                  key[v] = weight(u, v)
            (ii) Insert v into the pq 
            (iv) parent[v] = u

6) Print MST edges using parent array.
</code></pre>
</blockquote>
<h3 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h3><p>Prim算法进一步优化：以二叉堆或者堆Heap的形式来寻找最小值，就像这样</p>
<pre><code class="java">for(int i=queue.size()/2; i &gt;=0 ;i--) &#123; /*Build Heap*/
    BuildHeap(i, queue.size(), queue);
&#125;
</code></pre>
<p>由于我们寻找min时，使用堆来寻找，时间复杂度为O(logN),</p>
<pre><code class="java">// Java program for Prim&#39;s MST for
// adjacency list representation of graph
import java.util.LinkedList;
import java.util.TreeSet;
import java.util.Comparator;

public class prims &#123;
    class node1 &#123;

        // Stores destination vertex in adjacency list
        int dest;

        // Stores weight of a vertex in the adjacency list
        int weight;

        // Constructor
        node1(int a, int b)
        &#123;
            dest = a;
            weight = b;
        &#125;
    &#125;
    static class Graph &#123;

        // Number of vertices in the graph
        int V;

        // List of adjacent nodes of a given vertex
        LinkedList&lt;node1&gt;[] adj;

        // Constructor
        Graph(int e)
        &#123;
            V = e;
            adj = new LinkedList[V];
            for (int o = 0; o &lt; V; o++)
                adj[o] = new LinkedList&lt;&gt;();
        &#125;
    &#125;

    // class to represent a node in PriorityQueue
    // Stores a vertex and its corresponding
    // key value
    class node &#123;
        int vertex;
        int key;
    &#125;

    // Comparator class created for PriorityQueue
    // returns 1 if node0.key &gt; node1.key
    // returns 0 if node0.key &lt; node1.key and
    // returns -1 otherwise
    class comparator implements Comparator&lt;node&gt; &#123;

        @Override
        public int compare(node node0, node node1)
        &#123;
            return node0.key - node1.key;
        &#125;
    &#125;

    // method to add an edge
    // between two vertices
    void addEdge(Graph graph, int src, int dest, int weight)
    &#123;

        node1 node0 = new node1(dest, weight);
        node1 node = new node1(src, weight);
        graph.adj[src].addLast(node0);
        graph.adj[dest].addLast(node);
    &#125;

    // method used to find the mst
    void prims_mst(Graph graph)
    &#123;

        // Whether a vertex is in PriorityQueue or not
        Boolean[] mstset = new Boolean[graph.V];
        node[] e = new node[graph.V];

        // Stores the parents of a vertex
        int[] parent = new int[graph.V];

        for (int o = 0; o &lt; graph.V; o++)
            e[o] = new node();

        for (int o = 0; o &lt; graph.V; o++) &#123;

            // Initialize to false
            mstset[o] = false;

            // Initialize key values to infinity
            e[o].key = Integer.MAX_VALUE;
            e[o].vertex = o;
            parent[o] = -1;
        &#125;

        // Include the source vertex in mstset
        mstset[0] = true;

        // Set key value to 0
        // so that it is extracted first
        // out of PriorityQueue
        e[0].key = 0;

        // Use TreeSet instead of PriorityQueue as the remove function of the PQ is O(n) in java.
        TreeSet&lt;node&gt; queue = new TreeSet&lt;node&gt;(new comparator());

        for (int o = 0; o &lt; graph.V; o++)
            queue.add(e[o]);

        // Loops until the queue is not empty
        while (!queue.isEmpty()) &#123;

            // Extracts a node with min key value
            node node0 = queue.pollFirst();

            // Include that node into mstset
            mstset[node0.vertex] = true;

            // For all adjacent vertex of the extracted vertex V
            for (node1 iterator : graph.adj[node0.vertex]) &#123;

                // If V is in queue
                if (mstset[iterator.dest] == false) &#123;
                    // If the key value of the adjacent vertex is
                    // more than the extracted key
                    // update the key value of adjacent vertex
                    // to update first remove and add the updated vertex
                    if (e[iterator.dest].key &gt; iterator.weight) &#123;
                        queue.remove(e[iterator.dest]);
                        e[iterator.dest].key = iterator.weight;
                        queue.add(e[iterator.dest]);
                        parent[iterator.dest] = node0.vertex;
                    &#125;
                &#125;
            &#125;
        &#125;

        // Prints the vertex pair of mst
        for (int o = 1; o &lt; graph.V; o++)
            System.out.println(parent[o] + &quot; &quot;
                            + &quot;-&quot;
                            + &quot; &quot; + o);
    &#125;

    public static void main(String[] args)
    &#123;
        int V = 9;

        Graph graph = new Graph(V);

        prims e = new prims();

        e.addEdge(graph, 0, 1, 4);
        e.addEdge(graph, 0, 7, 8);
        e.addEdge(graph, 1, 2, 8);
        e.addEdge(graph, 1, 7, 11);
        e.addEdge(graph, 2, 3, 7);
        e.addEdge(graph, 2, 8, 2);
        e.addEdge(graph, 2, 5, 4);
        e.addEdge(graph, 3, 4, 9);
        e.addEdge(graph, 3, 5, 14);
        e.addEdge(graph, 4, 5, 10);
        e.addEdge(graph, 5, 6, 2);
        e.addEdge(graph, 6, 7, 1);
        e.addEdge(graph, 6, 8, 6);
        e.addEdge(graph, 7, 8, 7);

        // Method invoked
        e.prims_mst(graph);
    &#125;
&#125;
// This code is contributed by Vikash Kumar Dubey
</code></pre>
<blockquote>
<p><strong>Time Complexity:</strong> The time complexity of the above code/algorithm looks O(V^2) as there are two nested while loops. If we take a closer look, we can observe that the statements in inner loop are executed O(V+E) times (similar to BFS). The inner loop has decreaseKey() operation which takes O(LogV) time. So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV) (For a connected graph, V = O(E))</p>
</blockquote>
<h3 id="Prim迷宫生成算法"><a href="#Prim迷宫生成算法" class="headerlink" title="Prim迷宫生成算法"></a>Prim迷宫生成算法</h3><p>Wiki ‘s Explanation </p>
<blockquote>
<h3 id="Randomized-Prim’s-algorithm"><a href="#Randomized-Prim’s-algorithm" class="headerlink" title="Randomized Prim’s algorithm"></a>Randomized Prim’s algorithm</h3><p>An animation of generating a 30 by 20 maze using Prim’s algorithm.</p>
<p>This algorithm is a randomized version of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Prim's_algorithm">Prim’s algorithm</a>.</p>
<ol>
<li>Start with a grid full of walls.</li>
<li>Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.</li>
<li>While there are walls in the list:<ol>
<li>Pick a random wall from the list. If only one of the two cells that the wall divides is visited, then:<ol>
<li>Make the wall a passage and mark the unvisited cell as part of the maze.</li>
<li>Add the neighboring walls of the cell to the wall list.</li>
</ol>
</li>
<li>Remove the wall from the list.</li>
</ol>
</li>
</ol>
<p>Note that simply running classical Prim’s on a graph with random edge weights would create mazes stylistically identical to Kruskal’s, because they are both minimal spanning tree algorithms. Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight.</p>
</blockquote>
<ol>
<li>开始让整个图充满墙</li>
</ol>
<p>我们假设所有的墙为0， 所有可以走的点为1，开始时就会生成这样一张图</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210530125025268.png" alt="image-20210530125025268"></p>
<ol start="2">
<li>选择一个点作为起始点，把临墙加入列表</li>
</ol>
<pre><code class="java">//墙类
private static class wall&#123;
        int row; //墙所在的行
        int column; //墙所在的列
        int a_r; //连接墙一边的行
        int a_c;//连接墙一边的列
        int b_r;//连接墙另外一边的行
        int b_c;//连接墙另外一边的列
        wall(int r, int c, int ar, int ac, int br, int bc)&#123;
            row =r;
            column =c;
            a_r = ar;
            a_c =ac;
            b_r =br;
            b_c =bc;
        &#125;
    &#125;
</code></pre>
<p>选取一个点为起始点，我们选取(1,1)这个点，</p>
<pre><code class="java">//获取临墙的方法
private static LinkedList&lt;wall&gt; GetNext(int r, int c, boolean[][] isVisited)&#123;
        LinkedList&lt;wall&gt; list = new LinkedList&lt;&gt;();
        //r 是点所在的行
        //c 是点所在的列
    //这里要考虑到每种顶点周围墙的情况(我们的迷宫是封闭式的，即边界不能被打破)
        if(c&lt;isVisited[0].length-2)
            list.push(new wall(r, c+1, r, c, r, c+2));
        if(c&gt;1)
            list.push(new wall(r, c-1, r, c, r, c-2));
        if(r&lt;isVisited.length-2)
            list.push(new wall(r+1,c, r, c, r+2, c));
        if(r&gt;1)
            list.push(new wall(r-1,c, r, c, r-2, c));
        return list;
    &#125;
</code></pre>
<ol start="3">
<li><p>当列表中还有墙时，随机从中选取一个墙</p>
<ol>
<li><p>如果这个墙只有一个单元格被访问过</p>
<p>从队列中删除这堵墙，让与这堵墙相连的另一边的点的其他墙加入到队列，</p>
</li>
<li><p>墙的两边都被访问过</p>
<p>直接删除这个墙</p>
</li>
</ol>
</li>
</ol>
<pre><code class="java">        isVisited[start_r][start_c] = true;
        LinkedList&lt;wall&gt; list = GetNext(start_c, start_r, isVisited);
        int index=0;
        while(!list.isEmpty()) &#123;
            index = (int)(list.size()*Math.random());
            wall w = list.get(index);
            if(!isVisited[w.b_r][w.b_c]) &#123;
                list.remove(index);
                map[w.row][w.column] =1;
                isVisited[w.b_r][w.b_c] = true; 
                list.addAll(GetNext(w.b_r, w.b_c, isVisited));
            &#125;else if(isVisited[w.a_r][w.a_c] &amp;&amp; isVisited[w.b_r][w.b_c]) &#123;
                list.remove(index);
            &#125;

            
        &#125;
</code></pre>
<p>最终代码</p>
<pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.LinkedList;

public class PrimMazeCreating &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Prim(11,11,1,1);
    &#125;
    
    public static int[][] Prim(int r, int c, int start_r, int start_c) &#123;
        //init map and isVisited
        int[][] map = new int[r][c];
        boolean[][] isVisited = new boolean[r][c];
        for(int i=1;i&lt;map.length;i+=2) &#123;
            for(int j=1;j&lt;map[0].length;j+=2) &#123;
                map[i][j]=1;
            &#125;
        &#125;
        
        isVisited[start_r][start_c] = true;
        LinkedList&lt;wall&gt; list = GetNext(start_c, start_r, isVisited);
        int index=0;
        while(!list.isEmpty()) &#123;
            index = (int)(list.size()*Math.random());
            wall w = list.get(index);
            if(!isVisited[w.b_r][w.b_c]) &#123;
                list.remove(index);
                map[w.row][w.column] =1;
                isVisited[w.b_r][w.b_c] = true; 
                list.addAll(GetNext(w.b_r, w.b_c, isVisited));
            &#125;else if(isVisited[w.a_r][w.a_c] &amp;&amp; isVisited[w.b_r][w.b_c]) &#123;
                list.remove(index);
            &#125;

            
        &#125;
        
//        for(int[] n:map) &#123;
//        System.out.println(Arrays.toString(n));
//    &#125;
        
        return map;

    &#125;
    
    private static LinkedList&lt;wall&gt; GetNext(int r, int c, boolean[][] isVisited)&#123;
        LinkedList&lt;wall&gt; list = new LinkedList&lt;&gt;();
        
        if(c&lt;isVisited[0].length-2)
            list.push(new wall(r, c+1, r, c, r, c+2));
        if(c&gt;1)
            list.push(new wall(r, c-1, r, c, r, c-2));
        if(r&lt;isVisited.length-2)
            list.push(new wall(r+1,c, r, c, r+2, c));
        if(r&gt;1)
            list.push(new wall(r-1,c, r, c, r-2, c));
        return list;
    &#125;
    
    private static class wall&#123;
        int row; 
        int column;
        int a_r;
        int a_c;
        int b_r;
        int b_c;
        wall(int r, int c, int ar, int ac, int br, int bc)&#123;
            row =r;
            column =c;
            a_r = ar;
            a_c =ac;
            b_r =br;
            b_c =bc;
        &#125;
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210530131103722.png" alt="image-20210530131103722"></p>
<p>把迷宫用可视化表示后的结果</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210530131155062.png" alt="image-20210530131155062"></p>
<h2 id="7-Kruskal算法"><a href="#7-Kruskal算法" class="headerlink" title="7. Kruskal算法"></a>7. Kruskal算法</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p>克鲁斯卡尔算法和上面的Prim算法功能都一样，是找出最短总路径；但是Kruskal算法用另外一种方式来解决这个问题</p>
<ul>
<li><ol>
<li>创建每条边的List</li>
</ol>
</li>
<li><ol start="2">
<li>把边添加进List</li>
</ol>
</li>
<li><ol start="3">
<li>对List排序</li>
</ol>
</li>
<li><ol start="4">
<li>从头到尾读取List， 判断边的两个顶点是否形成回路（Disjoint Set并查集）</li>
</ol>
</li>
</ul>
<p>为了将顶点间的边进行排序，我们需要创建一个Edge类且实现comparable接口</p>
<pre><code class="java">//Edge也是一个静态内部类
private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123;
    public int x;
    public int y;
    public int weight;
    Edge(int a, int b, int w)&#123;
        x = a;
        y = b;
        weight = w;
    &#125;

    public String print(E[] data) &#123;
        return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight;
    &#125;

    @Override
    public int compareTo(Edge&lt;String&gt; e) &#123;
        // TODO Auto-generated method stub
        return weight -e.weight;
    &#125;

&#125;
</code></pre>
<p>把所有可能加入list并排序</p>
<pre><code class="java">boolean[][] isVisited = new boolean[data.length][data.length];
LinkedList&lt;Edge&lt;String&gt;&gt; list =  new LinkedList&lt;&gt;();
for(int i=0;i&lt;weight.length;i++) &#123;
    for(int j=0;j&lt;weight.length;j++) &#123;
        if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123;
            list.add(new Edge&lt;String&gt;(i, j, weight[i][j]));
            isVisited[i][j] = true;
            isVisited[j][i] = true;
        &#125;
    &#125;
&#125;

Collections.sort(list);
</code></pre>
<p>克鲁斯卡尔算法的精髓（并查集）</p>
<pre><code class="java">int[] ends = new int[data.length];
for(Edge&lt;String&gt; e:list) &#123;
    if(result.size() == data.length-1)
        break;


    //克鲁斯卡尔算法精髓
    int m = GetEnd(ends, e.x);
    int n = GetEnd(ends, e.y);
    //判断终点是否是一样的，即是否形成回路
    if(m !=n) &#123;
        ends[m]=n;
        result.add(e);
    &#125;

&#125;

/**
     * 获取对应下标的终点
     * @param ends
     * @param i
     * @return
     */
private static int GetEnd(int[] ends, int i) &#123;
    while(ends[i] !=0)
        i = ends[i];
    return i;
&#125;
    
</code></pre>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Collections;
import java.util.LinkedList;

/**
 * Kruskar算法
 * 1. 创建每条边的List
 * 2. 把边添加进List
 * 3. 对List排序
 * 4. 从头到尾读取List， 判断边的两个顶点是否形成回路
 * @author 23881
 *
 */
public class KruskalAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        
//        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;&#125;;
//        int[][] weight= &#123;
//                &#123;0,3,3,7&#125;,
//                &#123;3,0,2,4&#125;,
//                &#123;3,2,0,6&#125;,
//                &#123;7,4,6,0&#125;
//        &#125;;
        
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] weight= &#123;
                &#123;0,12,0,0,0,16,14&#125;,
                &#123;12,0,10,0,0,7,0&#125;,
                &#123;0,10,0,3,5,6,0&#125;,
                &#123;0,0,3,0,4,0,0&#125;,
                &#123;0,0,5,4,0,2,8&#125;,
                &#123;16,7,6,0,2,0,9&#125;,
                &#123;14,0,0,0,8,9,0&#125;
        &#125;;
        
        Kruskar(data, weight);
        

    &#125;
    
    public static void Kruskar(String[] data, int[][] weight) &#123;
        boolean[][] isVisited = new boolean[data.length][data.length];
        LinkedList&lt;Edge&lt;String&gt;&gt; list =  new LinkedList&lt;&gt;();
        LinkedList&lt;Edge&lt;String&gt;&gt; result =  new LinkedList&lt;&gt;();
        for(int i=0;i&lt;weight.length;i++) &#123;
            for(int j=0;j&lt;weight.length;j++) &#123;
                if(isVisited[i][j] == false &amp;&amp; weight[i][j] != 0) &#123;
                    list.add(new Edge&lt;String&gt;(i, j, weight[i][j]));
                    isVisited[i][j] = true;
                    isVisited[j][i] = true;
                &#125;
            &#125;
        &#125;
        
        Collections.sort(list);
        for(Edge&lt;String&gt; e:list) 
            System.out.println(e.print(data));
        System.out.println();
        
        int[] ends = new int[data.length];
        for(Edge&lt;String&gt; e:list) &#123;
            if(result.size() == data.length-1)
                break;
            
            
            //克鲁斯卡尔算法精髓
            int m = GetEnd(ends, e.x);
            int n = GetEnd(ends, e.y);
            //判断终点是否是一样的，即是否形成回路
            if(m !=n) &#123;
                ends[m]=n;
                result.add(e);
            &#125;
                
            
            
            
        &#125;
        
        for(Edge&lt;String&gt; e:result) 
            System.out.println(e.print(data));
    

        
        
    &#125;
    
    /**
     * 获取对应下标的终点
     * @param ends
     * @param i
     * @return
     */
    private static int GetEnd(int[] ends, int i) &#123;
        while(ends[i] !=0)
            i = ends[i];
        return i;
    &#125;
    
    private static class Edge&lt;E&gt; implements Comparable&lt;Edge&lt;String&gt;&gt;&#123;
        public int x;
        public int y;
        public int weight;
        Edge(int a, int b, int w)&#123;
            x = a;
            y = b;
            weight = w;
        &#125;
        
        public String print(E[] data) &#123;
            return data[x]+&quot; &quot;+data[y]+&quot; : &quot;+weight;
        &#125;

        @Override
        public int compareTo(Edge&lt;String&gt; e) &#123;
            // TODO Auto-generated method stub
            return weight -e.weight;
        &#125;
        
    &#125;

&#125;
</code></pre>
<h2 id="8-Dijkstra算法"><a href="#8-Dijkstra算法" class="headerlink" title="8. Dijkstra算法"></a>8. Dijkstra算法</h2><h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p>Dijkstra算法是解决某个顶点到其他顶点的最小路径问题，（邮差问题）</p>
<p>有A, B,C,D,E,F,G七个村庄，此时派出6个邮差从某点出发给另外几个村庄送信，怎样才能让每个邮差最快到达指定的村庄？</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509193626257.png" alt="image-20210509193626257"></p>
<p>村庄连接问题，需要用图与广度优先的知识进行求解</p>
<p>构建一个Graph类，这个类用于存储，每个顶点的前访问顶点， PreNode[ ]， 这个和Disjoint Set很相似，同时我们还在这个Graph类里面存储每个顶点的访问情况与到指定顶点的最短距离</p>
<pre><code class="java">private static class Graph&#123;
        private boolean[] isVisited; //存储是否被访问
        private int[] PreNode; //前结点集合
        private int[] Dis; //存储到每个顶点的最短距离
        private final static int infinity = Integer.MAX_VALUE; //常量
        
        public Graph(int len)&#123;
            //初始化变量
            isVisited = new boolean[len];
            PreNode = new int[len];
            Dis = new int[len];

            //假设每个顶点的前一个顶点都是他们自己
            for(int i=0;i&lt;len;i++) &#123;
                PreNode[i] = -1;
                Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷
        
            &#125;
            
        &#125;

        //展示最短距离
        public void ShowDis() &#123;
            System.out.println(Arrays.toString(Dis));
        &#125;
        
        //展示前顶点
        public void ShowPreNode() &#123;
            System.out.println(Arrays.toString(PreNode));
        &#125;
        
        //展示访问的情况
        public void ShowVisited() &#123;
            System.out.println(Arrays.toString(isVisited));
        &#125;
        
        //获取某个顶点到目标的最短距离
        public int GetDis(int n) &#123;
            return Dis[n];
        &#125;
        
        //设置某顶点到目标的最短距离
        public void SetDis(int n, int m) &#123;
            Dis[n] =m;
        &#125;
        
        //获取前访问顶点
        public int GetPreNode(int n) &#123;
            return PreNode[n];
        &#125;
        
        //设置前访问顶点
        public void SetPreNode(int n, int m) &#123;
            PreNode[n] =m;
        &#125;
        
        //获取顶点的访问状态
        public boolean GetVisited(int n) &#123;
            return isVisited[n];
        &#125;
        
        //设置顶点的访问状态
        public void SetVisited(int n, boolean rst) &#123;
            isVisited[n] = rst;
        &#125;    
    &#125;
</code></pre>
<p><strong>Dijkstra 算法精髓</strong></p>
<p>首先我们要从一个顶点开始，获得与这个顶点连接的顶点</p>
<p>（考虑到之后可能会使用广度优先，我们这里用LinkedList来存储顶点数据）</p>
<pre><code class="java">Graph graph = new Graph(matrix[0].length); //初始化一个Graph类
graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0
LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列
int[] ContainList = new int[matrix[0].length]; //存储顶点是否在队列中 （用于减少时间复杂度）

//把第一个顶点压入队列
list.push(index);
ContainList[index] = 1; //0 表示不在队列中， 1 表示在队列中

//暂时变量
int dis=0;
int temp =0;

//结束的条件就是队列为空
while(!list.isEmpty()) &#123;
    temp = list.pop(); //从队列中pop一个元素
    ContainList[temp] =0;
    //寻找与此元素相连的顶点
    for(int i=0;i&lt;matrix[temp].length;i++) &#123;
        //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点
        if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123;
            //获取此时的路径长度
            dis = matrix[temp][i]+graph.GetDis(temp);
            //如果这个长度小于已有的长度
            if(dis&lt;graph.GetDis(i)) &#123;
                //对原顶点的长度进行替换
                graph.SetPreNode(i, temp);
                //修改preNode
                graph.SetDis(i, dis);
                
                //能够被压入队列的条件：没被访问过且不在队列中
                if(!graph.GetVisited(i) &amp;&amp; ContainList[i]==0) &#123;
                    list.push(i);
                     ContainList[i] =1;
                &#125;
            &#125;
        &#125;
    &#125;
    //一个顶点完成遍历后，将其设置为已访问
    graph.SetVisited(temp, true);
&#125;

//打印最终结果
 graph.ShowDis();
</code></pre>
<p>最终</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.LinkedList;

public class DijkstraAlgorithm2 &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] matrix = &#123;
                &#123;0,5,7,0,0,0,2&#125;,
                &#123;5,0,0,9,0,0,3&#125;,
                &#123;7,0,0,0,8,0,0&#125;,
                &#123;0,9,0,0,0,4,0&#125;,
                &#123;0,0,8,0,0,5,4&#125;,
                &#123;0,0,0,4,5,0,6&#125;,
                &#123;2,3,0,0,4,6,0&#125;
        &#125;;
    
        Dijkstra(matrix, 0);
    &#125;
    
    /*结束条件：队列为空
     * 判断条件：not preNode
     *     改变Dis与Pre条件
     *         小于已有距离
     *     压入条件
     *         not visited 且 不在队列中
     * 
     * 遍历完一个点后，将此点改为isvisited
     * */
    
    //index is the start vertex, matrix is the adjacent matrix(graph)
    public static void Dijkstra(int[][] matrix, int index) &#123;
        Graph graph = new Graph(matrix[0].length); //初始化一个Graph类
        graph.SetDis(index, 0); //index是目标顶点，所以该顶点到自身的距离为0
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); //存储顶点的队列
       int[] ContainList = new int[matrix[0].length];
        //把第一个顶点压入队列
        list.push(index);
        ContainList[index] = 1;

        //暂时变量
        int dis=0;
        int temp =0;

        //结束的条件就是队列为空
        while(!list.isEmpty()) &#123;
            temp = list.pop(); //从队列中pop一个元素
            ContainList[temp] =0;
            //寻找与此元素相连的顶点
            for(int i=0;i&lt;matrix[temp].length;i++) &#123;
                //判断条件，相连的顶点不能是自己的preNode,同时要与其相连的顶点
                if(matrix[temp][i]!=0 &amp;&amp; graph.GetPreNode(i)!=temp) &#123;
                    //获取此时的路径长度
                    dis = matrix[temp][i]+graph.GetDis(temp);
                    //如果这个长度小于已有的长度
                    if(dis&lt;graph.GetDis(i)) &#123;
                        //对原顶点的长度进行替换
                        graph.SetPreNode(i, temp);
                        //修改preNode
                        graph.SetDis(i, dis);

                        //能够被压入队列的条件：没被访问过且不在队列中
                        if(!graph.GetVisited(i) &amp;&amp; ContainList[i]==0) &#123;
                            list.push(i);
                             ContainList[i] =1;
                        &#125;
                    &#125;
                &#125;
            &#125;
            //一个顶点完成遍历后，将其设置为已访问
            graph.SetVisited(temp, true);
        &#125;
         graph.ShowDis();
        
    &#125;
    
    
    
    
    private static class Graph&#123;
        private boolean[] isVisited; //存储是否被访问
        private int[] PreNode; //前结点集合
        private int[] Dis; //存储到每个顶点的最短距离
        private final static int infinity = Integer.MAX_VALUE; //常量
        
        public Graph(int len)&#123;
            //初始化变量
            isVisited = new boolean[len];
            PreNode = new int[len];
            Dis = new int[len];

            //假设每个顶点的前一个顶点都是他们自己
            for(int i=0;i&lt;len;i++) &#123;
                PreNode[i] = -1;
                Dis[i] = infinity; //假设开始到每个顶点的最短距离为无穷
        
            &#125;
            
        &#125;

        //展示最短距离
        public void ShowDis() &#123;
            System.out.println(Arrays.toString(Dis));
        &#125;
        
        //展示前顶点
        public void ShowPreNode() &#123;
            System.out.println(Arrays.toString(PreNode));
        &#125;
        
        //展示访问的情况
        public void ShowVisited() &#123;
            System.out.println(Arrays.toString(isVisited));
        &#125;
        
        //获取某个顶点到目标的最短距离
        public int GetDis(int n) &#123;
            return Dis[n];
        &#125;
        
        //设置某顶点到目标的最短距离
        public void SetDis(int n, int m) &#123;
            Dis[n] =m;
        &#125;
        
        //获取前访问顶点
        public int GetPreNode(int n) &#123;
            return PreNode[n];
        &#125;
        
        //设置前访问顶点
        public void SetPreNode(int n, int m) &#123;
            PreNode[n] =m;
        &#125;
        
        //获取顶点的访问状态
        public boolean GetVisited(int n) &#123;
            return isVisited[n];
        &#125;
        
        //设置顶点的访问状态
        public void SetVisited(int n, boolean rst) &#123;
            isVisited[n] = rst;
        &#125;    
    &#125;

&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509193843994.png" alt="image-20210509193843994"></p>
<h2 id="9-Floyd算法"><a href="#9-Floyd算法" class="headerlink" title="9. Floyd算法"></a>9. Floyd算法</h2><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><p>Floyd算法解决的问题和上面Dijkstra算法解决的问题一样；Floyd算法更容易理解，但是它的运行效率没有Dijkstra算法高</p>
<p>Floyd算法使用3个for循环进行嵌套</p>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210509193750069.png" alt="image-20210509193750069"></p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;

public class FloydAlgorithm &#123;
    public static void main(String[] args) &#123;
        int N=255; //N表示两个顶点间不相连
        String[] data = &#123;&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;&#125;;
        int[][] matrix = &#123;
                &#123;0,5,7,N,N,N,2&#125;,
                &#123;5,0,N,9,N,N,3&#125;,
                &#123;7,N,0,N,8,N,N&#125;,
                &#123;N,9,N,0,N,4,N&#125;,
                &#123;N,N,8,N,0,5,4&#125;,
                &#123;N,N,N,4,5,0,6&#125;,
                &#123;2,3,N,N,4,6,0&#125;
        &#125;;
        Floyd(data, matrix);
        
    &#125;
    
    public static &lt;E&gt; void Floyd(E[] d, int[][] m ) &#123;
        Graph&lt;E&gt; graph = new Graph&lt;&gt;(d, m);
//        graph.showGraph();
        graph.start();
        graph.showGraph();
    &#125;
    
    private static class Graph&lt;E&gt;&#123;
        private E[] data;
        private int[][] matrix;
        Graph(E[] d, int[][] m)&#123;
            
            data = d;
            matrix  = new int[data.length][data.length];
            for(int i=0;i&lt;data.length;i++) &#123;
                for(int j=0;j&lt;data.length;j++) &#123;
                    matrix[i][j] = m[i][j];
                &#125;
            &#125;
        &#125;
        
        public void showGraph() &#123;
            for(int[] m:matrix)
                System.out.println(Arrays.toString(m));
            System.out.println();
            for(int[] m:rst)
                System.out.println(Arrays.toString(m));
            System.out.println();
        &#125;
        
        public void start() &#123;
            int len=0;
            //对中间顶点遍历，k是中间顶点的下标
            for(int k=0;k&lt;data.length;k++) &#123;
                //从i顶点出发
                for(int i=0;i&lt;data.length;i++) &#123;
                    for(int j=0;j&lt;data.length;j++) &#123;
                        len = matrix[i][k] + matrix[k][j]; //从i出发，经过k，到达j的距离
                        if(len &lt; matrix[i][j]) &#123;
                            matrix[i][j] = len; 
                        &#125;
                            
                    &#125;
                &#125;
            &#125;
        &#125;
        
        
    &#125;
&#125;
</code></pre>
<p><img src="/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/image-20210420170808831.png" alt="image-20210420170808831"></p>
<h2 id="10-马踏棋盘算法"><a href="#10-马踏棋盘算法" class="headerlink" title="10. 马踏棋盘算法"></a>10. 马踏棋盘算法</h2><h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3><p>马踏棋盘问题，也称骑士周游问题，在国际象棋中，马只能走日，从某点出发，怎样才能走完棋盘上每个点，要求不重复？</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F202004%2F20200426140756952117.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621422824&t=3d94056536f8433f25ea731348608de9" alt="点击查看源网页"></p>
<p>马踏棋盘是典型的回溯问题，和迷宫问题属于同一类别</p>
<p>我们要考虑马的移动条件，找出下个能走的点</p>
<pre><code class="java">public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123;
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;();
        int X = curPoint.x; //表示列
        int Y = curPoint.y; //表示行
        if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) 
            ps.add(new Point(X-2, Y-1));
        
        if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X-1, Y-2));
        
        if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X+1, Y-2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0)
            ps.add(new Point(X+2, Y-1));
        
        
        if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) 
            ps.add(new Point(X-2, Y+1));
        
        if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X-1, Y+2));
        
        if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X+1, Y+2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row)
            ps.add(new Point(X+2, Y+1));
        
        return ps;
    &#125;
</code></pre>
<p>马在棋盘上走，遇到不能走的点要回溯，回溯需要递归的知识</p>
<pre><code class="java">    private static void Run(int x, int y, int step) &#123;
        ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数)
        isVisited[y][x] = true;
        ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y));
        sort(ps);
        while(!ps.isEmpty())&#123;
            Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点
            if(!isVisited[p.y][p.x])    
                Run(p.x, p.y, step+1);
        &#125;

        //发现走不了，而且还没走完棋盘上每个点，将此点标为未访问，回溯
        if(step &lt; row*coloumn &amp;&amp; ! finish) &#123;
            
            ChessBoard[y][x] = 0;
            isVisited[y][x] = false;
        &#125;else &#123;
            //走完，标为结束
            finish = true;
        &#125;
            
            
    &#125;
</code></pre>
<p> *1. 创建一个二维数组，作为棋盘<br> *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中<br> *3. 遍历ArrayList中的所有位置，看看哪个可以走通<br> *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

/**
 * 马踏棋盘算法
 * @author 23881
 *1. 创建一个二维数组，作为棋盘
 *2. 将当前位置设置为已访问，根据当前位置计算马儿还能走哪些位置（最多有8个）， 并放入到ArrayList中
 *3. 遍历ArrayList中的所有位置，看看哪个可以走通
 *4. 判断马是否完成任务，step，用计数器来统计，最终步数为36，完成不了，设置为0
 */
public class ChessHorseAlgorithm &#123;
    
    
    private static int coloumn;//列
    private static int row; //行
    private static int[][] ChessBoard;
    private static boolean[][] isVisited;
    private static boolean finish = false;
    
    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        Start(8, 8, 2, 1);
    &#125;
    
    /**
     * 
     * @param c 棋盘的列数
     * @param r 棋盘的行数
     * @param x 马位于第x列
     * @param y 马位于第y行
     * @param step 步数
     * 
     */
    public static void Start(int c, int r, int x, int y) &#123;
        coloumn = c;
        row = r;
        ChessBoard = new int[row][coloumn];
        isVisited = new boolean[row][coloumn];
        Run(x, y, 1);
        
        for(int[] cb: ChessBoard)
            System.out.println(Arrays.toString(cb));
    &#125;
    
    private static void Run(int x, int y, int step) &#123;
        ChessBoard[y][x] = step; //给棋盘相应的位置标step(步数)
        isVisited[y][x] = true;
        ArrayList&lt;Point&gt; ps = GetNext(new Point(x, y));
        sort(ps);
        while(!ps.isEmpty())&#123;
            Point p = ps.remove(0); // 取出第一个point,下一步可以去走的点
            if(!isVisited[p.y][p.x])    
                Run(p.x, p.y, step+1);
        &#125;

        if(step &lt; row*coloumn &amp;&amp; ! finish) &#123;
            
            ChessBoard[y][x] = 0;
            isVisited[y][x] = false;
        &#125;else &#123;
            finish = true;
        &#125;
            
            
    &#125;
    
    public static void sort(ArrayList&lt;Point&gt; ps) &#123;
        ps.sort(new Comparator&lt;Point&gt;() &#123;

            @Override
            public int compare(Point arg0, Point arg1) &#123;
                // TODO Auto-generated method stub
                return GetNext(arg0).size() - GetNext(arg1).size();
            &#125;
            
        &#125;);
    &#125;
    
    public static ArrayList&lt;Point&gt; GetNext(Point curPoint) &#123;
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;&gt;();
        int X = curPoint.x; //表示列
        int Y = curPoint.y; //表示行
        if(X-2&gt;=0 &amp;&amp; Y-1 &gt;= 0) 
            ps.add(new Point(X-2, Y-1));
        
        if(X-1 &gt;=0 &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X-1, Y-2));
        
        if(X+1 &lt; coloumn &amp;&amp; Y-2 &gt;=0)
            ps.add(new Point(X+1, Y-2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y-1 &gt;= 0)
            ps.add(new Point(X+2, Y-1));
        
        
        if(X-2&gt;=0 &amp;&amp; Y+1 &lt; row) 
            ps.add(new Point(X-2, Y+1));
        
        if(X-1 &gt;=0 &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X-1, Y+2));
        
        if(X+1 &lt;coloumn &amp;&amp; Y+2 &lt; row)
            ps.add(new Point(X+1, Y+2));
        
        if(X+2 &lt; coloumn &amp;&amp; Y+1 &lt; row)
            ps.add(new Point(X+2, Y+1));
        
        return ps;
    &#125;

&#125;
</code></pre>
<h1 id="算法补充"><a href="#算法补充" class="headerlink" title="算法补充"></a>算法补充</h1><h2 id="A-算法"><a href="#A-算法" class="headerlink" title="A* 算法"></a>A* 算法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>A<em>搜索算法和Dijkestra算法类似，A</em>算法也是使用一个优先队列（优先队列会自我构建二叉min堆），我们每次poll一个元素，这个元素都是priority最小的，当然这个priority是根据我们存入队列中的数据得来的，比如我们往优先队列中存入node节点，这个node节点要实现comparable接口，这样priority queue在添加时会自动排序</p>
<p>在A*算法中，我们要准备2个队列（open_list与close_list）,open_list用于存储可能的节点，而close_list用于存储已经走过且走得通的节点</p>
<p>node节点判断大小的依据是预期代价（G_cost）和实际代价（H_cost）,G_cost可以是此时节点到终点的距离（为了方便计算，我们只取三角形的两边），H_cost可以是从起点到目前节点走过的距离；根据他们代价总和（F=G+H）， 我们就能选取最小代价的点</p>
<p>具体思路</p>
<blockquote>
<pre><code>         a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。
        b. 把这个节点移到 close list 。
        c. 对当前方格的 4个相邻方格的每一个方格？
        ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。
        ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。
        d. 停止，当你
        ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者
        ◆ 查找终点失败，并且 open list 是空的，此时没有路径。
        3. 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。
</code></pre>
</blockquote>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package algorithm;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

import modifier.StaticStudy;

public class AstarAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[][] map = &#123;
                &#123;1,1,1,1,1,1,1,1&#125;,
                &#123;1,0,0,0,0,0,0,1&#125;,
                &#123;1,0,0,0,0,0,0,1&#125;,
                &#123;1,0,0,0,1,0,0,1&#125;,
                &#123;1,0,0,0,1,0,0,1&#125;,
                &#123;1,1,1,1,1,1,1,1&#125;
        &#125;;
//        int[][] map = PrimMazeCreating.Prim(11, 11, 1, 1);
        for(int[] a:map) &#123;
            System.out.println(Arrays.toString(a));
        &#125;
        System.out.println();
//        A_Star(map, 1, 1, map.length-2, map[0].length-2);
        A_Star(map, 2, 2, 2, 6);
        
        for(int[] a:map) &#123;
            System.out.println(Arrays.toString(a));
        &#125;
        
    &#125;
    
    private static class Node implements Comparable&lt;Node&gt;&#123;
        Node parent;
        int row;
        int column;
        int G_cost;
        int H_cost;
        Node(int r, int c, int g, int h, Node p)&#123;
            row = r;
            column =c;
            G_cost = g;
            H_cost =h;
            parent =p;

        &#125;
        
        @Override
        public int compareTo(Node b) &#123;
            // TODO Auto-generated method stub
            return this.G_cost+this.H_cost-b.G_cost-b.H_cost;
        &#125;

        @Override
        public boolean equals(Object obj) &#123;
            // TODO Auto-generated method stub
            Node temp = (Node) obj;
            return temp.row == this.row &amp;&amp; temp.column == this.column;
        &#125;
        
        
    &#125;
    

    public static void A_Star(int[][] map, int begin_r, int begin_c,int end_r, int end_c) &#123;
        PriorityQueue&lt;Node&gt; open_list = new PriorityQueue&lt;&gt;(); 
        PriorityQueue&lt;Node&gt; close_list = new PriorityQueue&lt;&gt;();
        int[][] Node_Status = new int[map.length][map[0].length];
        /**
         * 0 means the node is neigher in open_list nor in close_list
         * 1 means the node is in open_list
         * 2 means the node is in close_list
         * 
         */
        int temp_g = Get_G(begin_r, begin_c, end_r, end_c);
        int temp_h = 0;
        
        open_list.add(new Node(begin_r, begin_c, temp_g, temp_h, null));
        Node_Status[begin_r][begin_c] = 1;
        
        /**
         *     a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。
            b. 把这个节点移到 close list 。
            c. 对当前方格的 4个相邻方格的每一个方格？
            ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。
            ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。
            d. 停止，当你
            ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者
            ◆ 查找终点失败，并且 open list 是空的，此时没有路径。
            3. 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。


         */
        final int wall =1;
        while(!open_list.isEmpty()) &#123;
            Node temp = open_list.poll();
            close_list.add(temp); // push the node into close_list
            if(temp.row == end_r&amp;&amp; temp.column == end_c)
                break;
            Node_Status[temp.row][temp.column] = 2; // update the status of this node
            int parent_h = temp.H_cost;
            
            
            //◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作
            if(map[temp.row-1][temp.column]!=wall  &amp;&amp; Node_Status[temp.row-1][temp.column] ==0) &#123;
                //◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值
                Node nn = new Node(temp.row-1, temp.column, Get_G(temp.row-1, temp.column, end_r, end_c), parent_h+1, temp);
//                if(Node_Status[temp.row-1][temp.column] ==0)
                    open_list.add(nn);
                    map[temp.row-1][temp.column] =3;
                
            &#125;
            if(map[temp.row+1][temp.column]!=wall  &amp;&amp; Node_Status[temp.row+1][temp.column] ==0) &#123;

                Node nn = new Node(temp.row+1, temp.column, Get_G(temp.row+1, temp.column, end_r, end_c), parent_h+1, temp);
//                if(Node_Status[temp.row+1][temp.column] ==0)
                    open_list.add(nn);
                    map[temp.row+1][temp.column] =3;
            &#125;
                
            if(map[temp.row][temp.column-1]!=wall  &amp;&amp; Node_Status[temp.row][temp.column-1] ==0) &#123;
                Node nn = new Node(temp.row, temp.column-1, Get_G(temp.row, temp.column-1, end_r, end_c), parent_h+1, temp);
//                if(Node_Status[temp.row][temp.column-1] ==0)
                    open_list.add(nn);
                    map[temp.row][temp.column-1] =3;
            &#125;
                
            if(map[temp.row][temp.column+1]!=wall  &amp;&amp; Node_Status[temp.row][temp.column+1] ==0) &#123;
                Node nn = new Node(temp.row, temp.column+1, Get_G(temp.row, temp.column+1, end_r, end_c), parent_h+1, temp);
//                if(Node_Status[temp.row][temp.column+1] ==0)
                    open_list.add(nn);
                    map[temp.row][temp.column+1]=3;
            &#125;
                
            
            
            
        &#125;
        
    Object[] arr = close_list.toArray();
    Node p =null;
    for(int i=0;i&lt;arr.length;i++) &#123;
        Node temp =(Node)arr[i];
        if(temp.row == end_r &amp;&amp; temp.column == end_c) &#123;
            p = temp;
            break;
        &#125;
    &#125;
    
    
    while(p != null) &#123;
        map[p.row][p.column] =2;
        p = p.parent;
    &#125;
        
        
    &#125;
    
    private static int Get_G(int begin_r, int begin_c,int end_r, int end_c) &#123;
        return Math.abs(end_r-begin_r)+Math.abs(end_c-begin_c);
    &#125;
    
    

&#125;
</code></pre>
<h2 id="Beam-Search-集束算法"><a href="#Beam-Search-集束算法" class="headerlink" title="Beam Search (集束算法)"></a>Beam Search (集束算法)</h2><h2 id="分支界定算法（Branch-and-Bound）"><a href="#分支界定算法（Branch-and-Bound）" class="headerlink" title="分支界定算法（Branch and Bound）"></a>分支界定算法（Branch and Bound）</h2><h2 id="Buchberger算法"><a href="#Buchberger算法" class="headerlink" title="Buchberger算法"></a>Buchberger算法</h2><h2 id="期望-最大算法（EM-Training）"><a href="#期望-最大算法（EM-Training）" class="headerlink" title="期望-最大算法（EM-Training）"></a>期望-最大算法（EM-Training）</h2><h2 id="LLL算法"><a href="#LLL算法" class="headerlink" title="LLL算法"></a>LLL算法</h2><h2 id="最大流量算法（Maximum-flow）"><a href="#最大流量算法（Maximum-flow）" class="headerlink" title="最大流量算法（Maximum flow）"></a>最大流量算法（Maximum flow）</h2><h2 id="PID-算法"><a href="#PID-算法" class="headerlink" title="PID 算法"></a>PID 算法</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>尚硅谷数据结构与算法：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1E4411H73v?p=56&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1E4411H73v?p=56&amp;spm_id_from=pageDriver</a></p>
<p>菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png">https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png</a></p>
<p>参考书：Data Structure And Algorithm Analysis In Java TM, Third Edition, Mark Allen Weiss, PEARSON</p>
<p>A* 算法： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/225466669">https://zhuanlan.zhihu.com/p/225466669</a></p>

    </div>
    
    
    
</div>
                        <footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2024 Yao Xiong
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Yao Xiong
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        


    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>